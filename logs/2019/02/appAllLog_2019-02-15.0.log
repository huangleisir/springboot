2019-02-15 20:46:23.926[INFO ][com.hl.Hao123Application ] Starting Hao123Application on PC-20160220FPSE with PID 8904 (C:\Users\Administrator\IdeaProjects\springboot2\target\classes started by Administrator in C:\Users\Administrator\IdeaProjects\springboot2)
2019-02-15 20:46:23.929[INFO ][com.hl.Hao123Application ] The following profiles are active: dev
2019-02-15 20:46:24.049[INFO ][org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext] Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@436813f3: startup date [Fri Feb 15 20:46:24 CST 2019]; root of context hierarchy
2019-02-15 20:46:24.125[INFO ][org.hibernate.validator.internal.util.Version] HV000001: Hibernate Validator 5.2.4.Final
2019-02-15 20:46:26.090[INFO ][org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainer] Tomcat initialized with port(s): 9080 (http)
2019-02-15 20:46:26.104[INFO ][org.apache.catalina.core.StandardService] Starting service Tomcat
2019-02-15 20:46:26.106[INFO ][org.apache.catalina.core.StandardEngine] Starting Servlet Engine: Apache Tomcat/8.5.4
2019-02-15 20:46:26.363[INFO ][org.apache.catalina.core.ContainerBase.[Tomcat].[localhost].[/]] Initializing Spring embedded WebApplicationContext
2019-02-15 20:46:26.364[INFO ][org.springframework.web.context.ContextLoader] Root WebApplicationContext: initialization completed in 2315 ms
2019-02-15 20:46:26.645[INFO ][org.springframework.boot.web.servlet.ServletRegistrationBean] Mapping servlet: 'dispatcherServlet' to [/]
2019-02-15 20:46:26.654[INFO ][org.springframework.boot.web.servlet.FilterRegistrationBean] Mapping filter: 'characterEncodingFilter' to: [/*]
2019-02-15 20:46:26.654[INFO ][org.springframework.boot.web.servlet.FilterRegistrationBean] Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
2019-02-15 20:46:26.654[INFO ][org.springframework.boot.web.servlet.FilterRegistrationBean] Mapping filter: 'httpPutFormContentFilter' to: [/*]
2019-02-15 20:46:26.654[INFO ][org.springframework.boot.web.servlet.FilterRegistrationBean] Mapping filter: 'requestContextFilter' to: [/*]
2019-02-15 20:46:26.654[INFO ][org.springframework.boot.web.servlet.FilterRegistrationBean] Mapping filter: 'myFilter' to urls: [/*]
2019-02-15 20:46:26.689[INFO ][com.hl.filter.MyFilter   ] MyFilter init............
2019-02-15 20:46:27.108[INFO ][org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter] Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@436813f3: startup date [Fri Feb 15 20:46:24 CST 2019]; root of context hierarchy
2019-02-15 20:46:27.279[INFO ][org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping] Mapped "{[/demo],methods=[GET]}" onto public java.lang.String com.hl.Hao123Application.demo()
2019-02-15 20:46:27.304[INFO ][org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping] Mapped "{[/skip/{name}],methods=[POST]}" onto public java.lang.Object com.hl.Hao123Controller.skip(java.lang.String,javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse) throws java.io.IOException
2019-02-15 20:46:27.304[INFO ][org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping] Mapped "{[/wechat/portal],methods=[GET]}" onto public java.lang.String com.hl.Hao123Controller.demo(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2019-02-15 20:46:27.304[INFO ][org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping] Mapped "{[/tmall],methods=[GET]}" onto public java.lang.Object com.hl.Hao123Controller.tmall(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2019-02-15 20:46:27.305[INFO ][org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping] Mapped "{[/home],methods=[GET]}" onto public java.lang.String com.hl.HomeController.demo()
2019-02-15 20:46:27.307[INFO ][org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping] Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2019-02-15 20:46:27.307[INFO ][org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping] Mapped "{[/error],produces=[text/html]}" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2019-02-15 20:46:27.313[INFO ][org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter] Adding welcome page: class path resource [index.html]
2019-02-15 20:46:27.328[INFO ][org.springframework.web.servlet.handler.SimpleUrlHandlerMapping] Root mapping to handler of type [class org.springframework.web.servlet.mvc.ParameterizableViewController]
2019-02-15 20:46:27.351[INFO ][org.springframework.web.servlet.handler.SimpleUrlHandlerMapping] Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2019-02-15 20:46:27.352[INFO ][org.springframework.web.servlet.handler.SimpleUrlHandlerMapping] Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2019-02-15 20:46:27.432[INFO ][org.springframework.web.servlet.handler.SimpleUrlHandlerMapping] Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2019-02-15 20:46:27.650[INFO ][org.springframework.jmx.export.annotation.AnnotationMBeanExporter] Registering beans for JMX exposure on startup
2019-02-15 20:46:27.674[INFO ][org.apache.coyote.http11.Http11NioProtocol] Initializing ProtocolHandler ["http-nio-9080"]
2019-02-15 20:46:27.685[INFO ][org.apache.coyote.http11.Http11NioProtocol] Starting ProtocolHandler [http-nio-9080]
2019-02-15 20:46:27.699[INFO ][org.apache.tomcat.util.net.NioSelectorPool] Using a shared selector for servlet write/read
2019-02-15 20:46:27.746[INFO ][org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainer] Tomcat started on port(s): 9080 (http)
2019-02-15 20:46:27.751[INFO ][com.hl.Hao123Application ] Started Hao123Application in 5.691 seconds (JVM running for 7.56)
2019-02-15 20:46:28.669[INFO ][org.apache.catalina.core.ContainerBase.[Tomcat].[localhost].[/]] Initializing Spring FrameworkServlet 'dispatcherServlet'
2019-02-15 20:46:28.669[INFO ][org.springframework.web.servlet.DispatcherServlet] FrameworkServlet 'dispatcherServlet': initialization started
2019-02-15 20:46:28.689[INFO ][org.springframework.web.servlet.DispatcherServlet] FrameworkServlet 'dispatcherServlet': initialization completed in 20 ms
2019-02-15 20:46:28.699[INFO ][com.hl.filter.MyFilter   ] MyFilter doFilter.........before
2019-02-15 20:46:28.699[INFO ][com.hl.service.impl.ServilceImpl] --------------------action------------------------
2019-02-15 20:46:28.699[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		-1
2019-02-15 20:46:28.699[INFO ][com.hl.filter.MyFilter   ] ====================
2019-02-15 20:46:28.719[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		-1
2019-02-15 20:46:28.719[INFO ][com.hl.filter.MyFilter   ] request url:		0:0:0:0:0:0:0:1
2019-02-15 20:46:28.719[INFO ][com.hl.filter.MyFilter   ] request parameters:	
2019-02-15 20:46:28.749[INFO ][com.hl.filter.MyFilter   ] MyFilter doFilter.........before
2019-02-15 20:46:28.749[INFO ][com.hl.service.impl.ServilceImpl] --------------------action------------------------
2019-02-15 20:46:28.749[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		-1
2019-02-15 20:46:28.749[INFO ][com.hl.filter.MyFilter   ] ====================
2019-02-15 20:46:28.769[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		-1
2019-02-15 20:46:28.769[INFO ][com.hl.filter.MyFilter   ] request url:		0:0:0:0:0:0:0:1
2019-02-15 20:46:28.779[INFO ][com.hl.filter.MyFilter   ] request parameters:	
2019-02-15 20:46:28.980[INFO ][com.hl.filter.MyFilter   ] MyFilter doFilter.........before
2019-02-15 20:46:28.980[INFO ][com.hl.service.impl.ServilceImpl] --------------------action------------------------
2019-02-15 20:46:28.980[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		-1
2019-02-15 20:46:28.980[INFO ][com.hl.filter.MyFilter   ] ====================
2019-02-15 20:46:29.015[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		-1
2019-02-15 20:46:29.015[INFO ][com.hl.filter.MyFilter   ] request url:		0:0:0:0:0:0:0:1
2019-02-15 20:46:29.015[INFO ][com.hl.filter.MyFilter   ] request parameters:	
2019-02-15 20:46:29.017[INFO ][com.hl.filter.MyFilter   ] MyFilter doFilter.........before
2019-02-15 20:46:29.017[INFO ][com.hl.service.impl.ServilceImpl] --------------------action------------------------
2019-02-15 20:46:29.017[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		-1
2019-02-15 20:46:29.017[INFO ][com.hl.filter.MyFilter   ] ====================
2019-02-15 20:46:29.035[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		-1
2019-02-15 20:46:29.036[INFO ][com.hl.filter.MyFilter   ] request url:		0:0:0:0:0:0:0:1
2019-02-15 20:46:29.036[INFO ][com.hl.filter.MyFilter   ] request parameters:	
2019-02-15 20:46:29.310[INFO ][com.hl.filter.MyFilter   ] MyFilter doFilter.........before
2019-02-15 20:46:29.310[INFO ][com.hl.service.impl.ServilceImpl] --------------------action------------------------
2019-02-15 20:46:29.311[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		12
2019-02-15 20:46:29.311[INFO ][com.hl.filter.MyFilter   ] ====================
2019-02-15 20:46:29.361[INFO ][com.hl.filter.MyFilter   ] MyFilter doFilter.........before
2019-02-15 20:46:29.361[INFO ][com.hl.service.impl.ServilceImpl] --------------------action------------------------
2019-02-15 20:46:29.361[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		10
2019-02-15 20:46:29.361[INFO ][com.hl.filter.MyFilter   ] ====================
2019-02-15 20:46:29.374[INFO ][com.hl.Hao123Controller  ] ---------------~~~~~~~~~~~~name~~~~~weather
2019-02-15 20:46:29.375[INFO ][com.hl.Hao123Controller  ] ---------------~~~~~~~~~~~~name~~~~~token
2019-02-15 20:46:29.390[INFO ][com.hl.Hao123Controller  ] 多线程，异步调用 日志打印方法thread-pool-0---跳转到 weather
2019-02-15 20:46:29.441[INFO ][com.hl.Hao123Controller  ] 多线程，异步调用 日志打印方法thread-pool-0---跳转到 测试号access_token
2019-02-15 20:46:30.345[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		10
2019-02-15 20:46:30.345[INFO ][com.hl.filter.MyFilter   ] request url:		0:0:0:0:0:0:0:1
2019-02-15 20:46:30.345[INFO ][com.hl.filter.MyFilter   ] request parameters:	[name=token,token]
2019-02-15 20:46:31.071[INFO ][com.hl.Hao123Controller  ] null
2019-02-15 20:46:31.075[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		12
2019-02-15 20:46:31.075[INFO ][com.hl.filter.MyFilter   ] request url:		0:0:0:0:0:0:0:1
2019-02-15 20:46:31.075[INFO ][com.hl.filter.MyFilter   ] request parameters:	[name=weather,weather]
2019-02-15 20:46:31.257[INFO ][com.hl.Hao123Application ] -----------{"access_token":"18_6PpgT6MLL1qF3UwHNUh9qXIxcOU01bgnCbT-28-JeEh8hnJX0HV1Tq38r30AMA8tMrGFaZRqtyW_GJ20Renuac8dIQZtiL79pXnNU8cWRKXW6VNPz7GnxKHBEWikZmK22ABgjZxuLC68Ht0_HNGiAEACIB","expires_in":7200}
2019-02-15 20:46:31.257[INFO ][com.hl.Hao123Application ] 更新access_token, 18_6PpgT6MLL1qF3UwHNUh9qXIxcOU01bgnCbT-28-JeEh8hnJX0HV1Tq38r30AMA8tMrGFaZRqtyW_GJ20Renuac8dIQZtiL79pXnNU8cWRKXW6VNPz7GnxKHBEWikZmK22ABgjZxuLC68Ht0_HNGiAEACIB
2019-02-15 20:46:44.537[INFO ][com.hl.filter.MyFilter   ] MyFilter doFilter.........before
2019-02-15 20:46:44.537[INFO ][com.hl.service.impl.ServilceImpl] --------------------action------------------------
2019-02-15 20:46:44.537[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		29
2019-02-15 20:46:44.537[INFO ][com.hl.filter.MyFilter   ] ====================
2019-02-15 20:46:44.547[INFO ][com.hl.Hao123Controller  ] ---------------~~~~~~~~~~~~name~~~~~lilaoshuBigFish
2019-02-15 20:46:44.547[INFO ][com.hl.Hao123Controller  ] 多线程，异步调用 日志打印方法thread-pool-0---跳转到 lilaoshuBigFish
2019-02-15 20:46:44.547[INFO ][com.hl.filter.MyFilter   ] request.getContentLength():		29
2019-02-15 20:46:44.547[INFO ][com.hl.filter.MyFilter   ] request url:		0:0:0:0:0:0:0:1
2019-02-15 20:46:44.547[INFO ][com.hl.filter.MyFilter   ] request parameters:	[name=lilaoshuBigFish,lilaoshuBigFish][data=123]
2019-02-15 20:47:00.769[INFO ][com.hl.Hao123Application ] 22222222222222, 1-  2019-02-15 星期五 下午 20:47:00
2019-02-15 20:47:00.769[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:47:00.769[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 1-  2019-02-15 星期五 下午 20:47:00
2019-02-15 20:47:01.119[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [mT54cA08243936]"}
2019-02-15 20:47:01.119[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [mT54cA08243936]"}
2019-02-15 20:47:30.761[INFO ][com.hl.Hao123Application ] 22222222222222, 2-  68可以在hashcode中使用随机数字吗?

不行，因为同一对象的 hashcode 值必须是相同的2019-02-15 星期五 下午 20:47:30
2019-02-15 20:47:30.761[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:47:30.761[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 2-  68可以在hashcode中使用随机数字吗?

不行，因为同一对象的 hashcode 值必须是相同的2019-02-15 星期五 下午 20:47:30
2019-02-15 20:47:31.021[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [bVQSGa08533935]"}
2019-02-15 20:47:31.021[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [bVQSGa08533935]"}
2019-02-15 20:48:00.762[INFO ][com.hl.Hao123Application ] 22222222222222, 3-  2882019-02-15 星期五 下午 20:48:00
2019-02-15 20:48:00.762[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:48:00.762[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 3-  2882019-02-15 星期五 下午 20:48:00
2019-02-15 20:48:01.072[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [ZApcOa08833950]"}
2019-02-15 20:48:01.072[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [ZApcOa08833950]"}
2019-02-15 20:48:30.762[INFO ][com.hl.Hao123Application ] 22222222222222, 4-  154 7、sql优化

(1)、explain出来的各种item的意义
复制代码

id:每个被独立执行的操作的标志，表示对象被操作的顺序。一般来说， id 值大，先被执行；如果 id 值相同，则顺序从上到下。
select_type：查询中每个 select 子句的类型。
table:名字，被操作的对象名称，通常的表名(或者别名)，但是也有其他格式。
partitions:匹配的分区信息。
type:join 类型。
possible_keys：列出可能会用到的索引。
key:实际用到的索引。
key_len:用到的索引键的平均长度，单位为字节。
ref:表示本行被操作的对象的参照对象，可能是一个常量用 const 表示，也可能是其他表的
key 指向的对象，比如说驱动表的连接列。
rows:估计每次需要扫描的行数。
filtered:rows*filtered/100 表示该步骤最后得到的行数(估计值)。
extra:重要的补充信息。

复制代码

(2)、profile的意义以及使用场景

Profile 用来分析 sql 性能的消耗分布情况。当用 explain 无法解决慢 SQL 的时候，需要用profile 来对 sql 进行更细致的分析，找出 sql 所花的时间大部分消耗在哪个部分，确认 sql的性能瓶颈。

(3)、explain 中的索引问题

Explain 结果中，一般来说，要看到尽量用 index(type 为 const、 ref 等， key 列有值)，避免使用全表扫描(type 显式为 ALL)。比如说有 where 条件且选择性不错的列，需要建立索引。
被驱动表的连接列，也需要建立索引。被驱动表的连接列也可能会跟 where 条件列一起建立联合索引。当有排序或者 group by 的需求时，也可以考虑建立索引来达到直接排序和汇总的需求。

2019-02-15 星期五 下午 20:48:30
2019-02-15 20:48:30.762[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:48:30.762[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 4-  154 7、sql优化

(1)、explain出来的各种item的意义
复制代码

id:每个被独立执行的操作的标志，表示对象被操作的顺序。一般来说， id 值大，先被执行；如果 id 值相同，则顺序从上到下。
select_type：查询中每个 select 子句的类型。
table:名字，被操作的对象名称，通常的表名(或者别名)，但是也有其他格式。
partitions:匹配的分区信息。
type:join 类型。
possible_keys：列出可能会用到的索引。
key:实际用到的索引。
key_len:用到的索引键的平均长度，单位为字节。
ref:表示本行被操作的对象的参照对象，可能是一个常量用 const 表示，也可能是其他表的
key 指向的对象，比如说驱动表的连接列。
rows:估计每次需要扫描的行数。
filtered:rows*filtered/100 表示该步骤最后得到的行数(估计值)。
extra:重要的补充信息。

复制代码

(2)、profile的意义以及使用场景

Profile 用来分析 sql 性能的消耗分布情况。当用 explain 无法解决慢 SQL 的时候，需要用profile 来对 sql 进行更细致的分析，找出 sql 所花的时间大部分消耗在哪个部分，确认 sql的性能瓶颈。

(3)、explain 中的索引问题

Explain 结果中，一般来说，要看到尽量用 index(type 为 const、 ref 等， key 列有值)，避免使用全表扫描(type 显式为 ALL)。比如说有 where 条件且选择性不错的列，需要建立索引。
被驱动表的连接列，也需要建立索引。被驱动表的连接列也可能会跟 where 条件列一起建立联合索引。当有排序或者 group by 的需求时，也可以考虑建立索引来达到直接排序和汇总的需求。

2019-02-15 星期五 下午 20:48:30
2019-02-15 20:48:31.032[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [SJFgBa09138694]"}
2019-02-15 20:48:31.032[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [SJFgBa09138694]"}
2019-02-15 20:49:00.762[INFO ][com.hl.Hao123Application ] 22222222222222, 5-  211 
13.为什么要有事物传播行为？
https://www.cnblogs.com/wang-meng/p/5701982.html2019-02-15 星期五 下午 20:49:00
2019-02-15 20:49:00.762[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:49:00.762[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 5-  211 
13.为什么要有事物传播行为？
https://www.cnblogs.com/wang-meng/p/5701982.html2019-02-15 星期五 下午 20:49:00
2019-02-15 20:49:01.002[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [vv09433933]"}
2019-02-15 20:49:01.002[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [vv09433933]"}
2019-02-15 20:49:30.762[INFO ][com.hl.Hao123Application ] 22222222222222, 6-  119  我记得在oppo面试的时候，问了一个这样的问题，10个写线程，只有一个读线程，那么这个时候有必要加读锁吗。 其实是要加的，加读锁是为了跟写锁互斥。

类图是这样的， ReadWriteLock接口（这个接口跟Lock接口没有半毛钱关系）下面的实现类RenentrantReadWriteLock 张孝祥：读写锁卡农控制粒度比synchronized更加细致，且他只能在代码块上加锁，也就是说她锁的是对象，不能锁类。两个线程要达到互斥的效果，必须用同一个读写锁，那么用ReentrantLock行不行，达不到读写锁这么细颗粒度的控制。

对象下面的读锁和写锁。锁是要上在共享的任务实例的内部方法中的代码块上的，而不是线程代码上。 读锁与读锁不互斥，读锁与写锁互斥，写锁与读锁互斥，写锁与写锁互斥。前提是都是同一个读写锁啊。面试题用读写锁写一个缓存类。 我在总结一下：一个线程读的时候，另一个线程不能写但可以读（正是因为这个特性使得写多读少的场景下提升了性能，因为面试经常问到）， 一个线程写的时候，另一个线程也不能读，夜不能写。欧拉。 从代码语句执行的角度来讲，就是一个线程执行了读锁语句，另一个线程还能执行读锁语句，但不能执行上写锁语句以及后面的代码，一个线程执行了上写锁语句， 另一个线程既不能执行上读锁语句以及后面的语句，也不能执行上写锁以及后面的语句。 我的一个疑问是，既然读锁与读锁不互斥，那么所线程都是读的情况下，还有加读锁的必要吗，那确实没必要，但是如果读的时候不希望有写锁包围的代码被执行， 那就必须要 加读锁，另外一块代码要加写锁。另外，我觉得不要被这个读写的名字局限了，凡是需要用到这个互斥特性的地方都可以使用读写锁。2019-02-15 星期五 下午 20:49:30
2019-02-15 20:49:30.762[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:49:30.762[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 6-  119  我记得在oppo面试的时候，问了一个这样的问题，10个写线程，只有一个读线程，那么这个时候有必要加读锁吗。 其实是要加的，加读锁是为了跟写锁互斥。

类图是这样的， ReadWriteLock接口（这个接口跟Lock接口没有半毛钱关系）下面的实现类RenentrantReadWriteLock 张孝祥：读写锁卡农控制粒度比synchronized更加细致，且他只能在代码块上加锁，也就是说她锁的是对象，不能锁类。两个线程要达到互斥的效果，必须用同一个读写锁，那么用ReentrantLock行不行，达不到读写锁这么细颗粒度的控制。

对象下面的读锁和写锁。锁是要上在共享的任务实例的内部方法中的代码块上的，而不是线程代码上。 读锁与读锁不互斥，读锁与写锁互斥，写锁与读锁互斥，写锁与写锁互斥。前提是都是同一个读写锁啊。面试题用读写锁写一个缓存类。 我在总结一下：一个线程读的时候，另一个线程不能写但可以读（正是因为这个特性使得写多读少的场景下提升了性能，因为面试经常问到）， 一个线程写的时候，另一个线程也不能读，夜不能写。欧拉。 从代码语句执行的角度来讲，就是一个线程执行了读锁语句，另一个线程还能执行读锁语句，但不能执行上写锁语句以及后面的代码，一个线程执行了上写锁语句， 另一个线程既不能执行上读锁语句以及后面的语句，也不能执行上写锁以及后面的语句。 我的一个疑问是，既然读锁与读锁不互斥，那么所线程都是读的情况下，还有加读锁的必要吗，那确实没必要，但是如果读的时候不希望有写锁包围的代码被执行， 那就必须要 加读锁，另外一块代码要加写锁。另外，我觉得不要被这个读写的名字局限了，凡是需要用到这个互斥特性的地方都可以使用读写锁。2019-02-15 星期五 下午 20:49:30
2019-02-15 20:49:31.092[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [ooylHa09738630]"}
2019-02-15 20:49:31.092[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [ooylHa09738630]"}
2019-02-15 20:50:00.762[INFO ][com.hl.Hao123Application ] 22222222222222, 7-  3582019-02-15 星期五 下午 20:50:00
2019-02-15 20:50:00.762[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:50:00.762[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 7-  3582019-02-15 星期五 下午 20:50:00
2019-02-15 20:50:01.062[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [tQdRSa00033936]"}
2019-02-15 20:50:01.062[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [tQdRSa00033936]"}
2019-02-15 20:50:30.762[INFO ][com.hl.Hao123Application ] 22222222222222, 8-  98 面向对象三大特性 六大原则  https://www.cnblogs.com/xijie/p/6068786.html 2019-02-15 星期五 下午 20:50:30
2019-02-15 20:50:30.762[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:50:30.762[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 8-  98 面向对象三大特性 六大原则  https://www.cnblogs.com/xijie/p/6068786.html 2019-02-15 星期五 下午 20:50:30
2019-02-15 20:50:31.022[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [opxm7a0033shc2]"}
2019-02-15 20:50:31.022[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [opxm7a0033shc2]"}
2019-02-15 20:51:00.763[INFO ][com.hl.Hao123Application ] 22222222222222, 9-  99 https://www.cnblogs.com/butterfly100/p/9034281.html   分库分表思路2019-02-15 星期五 下午 20:51:00
2019-02-15 20:51:00.763[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:51:00.763[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 9-  99 https://www.cnblogs.com/butterfly100/p/9034281.html   分库分表思路2019-02-15 星期五 下午 20:51:00
2019-02-15 20:51:01.073[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [sCuMXa00633932]"}
2019-02-15 20:51:01.073[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [sCuMXa00633932]"}
2019-02-15 20:51:30.763[INFO ][com.hl.Hao123Application ] 22222222222222, 10-  3232019-02-15 星期五 下午 20:51:30
2019-02-15 20:51:30.763[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:51:30.763[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 10-  3232019-02-15 星期五 下午 20:51:30
2019-02-15 20:51:31.083[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [nZ3mva00933951]"}
2019-02-15 20:51:31.083[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [nZ3mva00933951]"}
2019-02-15 20:52:00.763[INFO ][com.hl.Hao123Application ] 22222222222222, 11-  3172019-02-15 星期五 下午 20:52:00
2019-02-15 20:52:00.763[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:52:00.763[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 11-  3172019-02-15 星期五 下午 20:52:00
2019-02-15 20:52:01.033[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [KyE2wA01234126]"}
2019-02-15 20:52:01.033[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [KyE2wA01234126]"}
2019-02-15 20:52:30.763[INFO ][com.hl.Hao123Application ] 22222222222222, 12-  121 2019-02-15 星期五 下午 20:52:30
2019-02-15 20:52:30.763[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:52:30.763[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 12-  121 2019-02-15 星期五 下午 20:52:30
2019-02-15 20:52:31.053[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [MWWKkA01534108]"}
2019-02-15 20:52:31.053[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [MWWKkA01534108]"}
2019-02-15 20:53:00.763[INFO ][com.hl.Hao123Application ] 22222222222222, 13-  175 jvm内存溢出分析
2016-11-07 13:47 by 钟绍威, 3689 阅读, 1 评论, 收藏, 编辑概述
jvm中除了程序计数器，其他的区域都有可能会发生内存溢出
内存溢出是什么？
当程序需要申请内存的时候，由于没有足够的内存，此时就会抛出OutOfMemoryError，这就是内存溢出
内存溢出和内存泄漏有什么区别？
内存泄漏是由于使用不当，把一部分内存“丢掉了”，导致这部分内存不可用。
当在堆中创建了对象，后来没有使用这个对象了，又没有把整个对象的相关引用设为null。此时垃圾收集器会认为这个对象是需要的，就不会清理这部分内存。这就会导致这部分内存不可用。
所以内存泄漏会导致可用的内存减少，进而会导致内存溢出。
用到的jvm参数
下面为了说明溢出的情景，会执行一些实例代码，同时需要给jvm指定参数
-Xms 堆最小容量(heap min size)
-Xmx 堆最大容量(heap max size)
-Xss 栈容量(stack size)
-XX:PermSize=size 永生代最小容量
-XX:MaxPermSize=size 永生代最大容量
堆溢出
堆是存放对象的地方，那么只要在堆中疯狂的创建对象，那么堆就会发生内存溢出。
https://www.cnblogs.com/wewill/p/6038528.html2019-02-15 星期五 下午 20:53:00
2019-02-15 20:53:00.763[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:53:00.763[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 13-  175 jvm内存溢出分析
2016-11-07 13:47 by 钟绍威, 3689 阅读, 1 评论, 收藏, 编辑概述
jvm中除了程序计数器，其他的区域都有可能会发生内存溢出
内存溢出是什么？
当程序需要申请内存的时候，由于没有足够的内存，此时就会抛出OutOfMemoryError，这就是内存溢出
内存溢出和内存泄漏有什么区别？
内存泄漏是由于使用不当，把一部分内存“丢掉了”，导致这部分内存不可用。
当在堆中创建了对象，后来没有使用这个对象了，又没有把整个对象的相关引用设为null。此时垃圾收集器会认为这个对象是需要的，就不会清理这部分内存。这就会导致这部分内存不可用。
所以内存泄漏会导致可用的内存减少，进而会导致内存溢出。
用到的jvm参数
下面为了说明溢出的情景，会执行一些实例代码，同时需要给jvm指定参数
-Xms 堆最小容量(heap min size)
-Xmx 堆最大容量(heap max size)
-Xss 栈容量(stack size)
-XX:PermSize=size 永生代最小容量
-XX:MaxPermSize=size 永生代最大容量
堆溢出
堆是存放对象的地方，那么只要在堆中疯狂的创建对象，那么堆就会发生内存溢出。
https://www.cnblogs.com/wewill/p/6038528.html2019-02-15 星期五 下午 20:53:00
2019-02-15 20:53:01.073[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [RvralA01833952]"}
2019-02-15 20:53:01.073[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [RvralA01833952]"}
2019-02-15 20:53:30.773[INFO ][com.hl.Hao123Application ] 22222222222222, 14-  99 https://www.cnblogs.com/butterfly100/p/9034281.html   分库分表思路2019-02-15 星期五 下午 20:53:30
2019-02-15 20:53:30.773[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:53:30.773[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 14-  99 https://www.cnblogs.com/butterfly100/p/9034281.html   分库分表思路2019-02-15 星期五 下午 20:53:30
2019-02-15 20:53:31.043[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [EAJ8cA02134121]"}
2019-02-15 20:53:31.043[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [EAJ8cA02134121]"}
2019-02-15 20:54:00.773[INFO ][com.hl.Hao123Application ] 22222222222222, 15-  2472019-02-15 星期五 下午 20:54:00
2019-02-15 20:54:00.773[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:54:00.773[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 15-  2472019-02-15 星期五 下午 20:54:00
2019-02-15 20:54:01.013[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [UjktJa02433934]"}
2019-02-15 20:54:01.013[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [UjktJa02433934]"}
2019-02-15 20:54:30.774[INFO ][com.hl.Hao123Application ] 22222222222222, 16-  140 3.视图的作用，视图可以更改么？

视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。
视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。
创建视图：create view XXX as XXXXXXXXXXXXXX;
对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。2019-02-15 星期五 下午 20:54:30
2019-02-15 20:54:30.774[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:54:30.774[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 16-  140 3.视图的作用，视图可以更改么？

视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。
视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。
创建视图：create view XXX as XXXXXXXXXXXXXX;
对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。2019-02-15 星期五 下午 20:54:30
2019-02-15 20:54:31.064[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [.W8yeA02734124]"}
2019-02-15 20:54:31.064[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [.W8yeA02734124]"}
2019-02-15 20:55:00.774[INFO ][com.hl.Hao123Application ] 22222222222222, 17-  168 6 、关于 mysql 参数优化的经验
复制代码

首先问他它们线上 mysql 数据库是怎么安装的，如果说是 rpm 安装的，那么我就直接问调优参数了，如果是源码安装的，那么我就要问编译中的一些参数了，比如 my.cnf 以及存储引擎以及字符类型等等。然后从以下几个方面问起：
（ 1） mysql 有哪些 global 内存参数，有哪些 local 内存参数。
Global:
innodb_buffer_pool_size/innodb_additional_mem_pool_size/innodb_log_buffer_size/key_buffer_size/query_cache_size/table_open_cache/table_definition_cache/thread_cache_size
Local:
read_buffer_size/read_rnd_buffer_size/sort_buffer_size/join_buffer_size/binlog_cache_size/tmp_table_size/thread_stack/bulk_insert_buffer_size

（ 2） mysql 的写入参数需要调整哪些？重要的几个写参数的几个值得含义以及适用场景，
比如 innodb_flush_log_at_trx_commit 等。 (求补充)
sync_binlog 设置为 1，保证 binlog 的安全性。
innodb_flush_log_at_trx_commit：
0：事务提交时不将 redo log buffer 写入磁盘(仅每秒进行 master thread 刷新，安全
性最差，性能最好)
1：事务提交时将 redo log buffer 写入磁盘(安全性最好，性能最差， 推荐生产使用)
2：事务提交时仅将 redo log buffer 写入操作系统缓存(安全性和性能都居中，当 mysql宕机但是操作系统不宕机则不丢数据，如果操作系统宕机，最多丢一秒数据)
innodb_io_capacity/innodb_io_capacity_max：看磁盘的性能来定。如果是 HDD 可以设置为 200-几百不等。如果是 SSD，推荐为 4000 左右。 innodb_io_capacity_max 更大一些。
innodb_flush_method 设置为 O_DIRECT。

（ 3） 读取的话，那几个全局的 pool 的值的设置，以及几个 local 的 buffer 的设置。
Global:
innodb_buffer_pool_size:设置为可用内存的 50%-60%左右，如果不够，再慢慢上调。
innodb_additional_mem_pool_size：采用默认值 8M 即可。
innodb_log_buffer_size:默认值 8M 即可。
key_buffer_size:myisam 表需要的 buffer size，选择基本都用 innodb，所以采用默认的 8M 即可。
Local:
join_buffer_size： 当 sql 有 BNL 和 BKA 的时候，需要用的 buffer_size(plain index
scans, range index scans 的时候可能也会用到)。默认为 256k，建议设置为 16M-32M。
read_rnd_buffer_size：当使用 mrr 时，用到的 buffer。默认为 256k，建议设置为16-32M。
read_buffer_size:当顺序扫描一个 myisam 表，需要用到这个 buffer。或者用来决定memory table 的大小。或者所有的 engine 类型做如下操作：order by 的时候用 temporaryfile、 SELECT INTO … OUTFILE 'filename' 、 For caching results of nested queries。默认为 128K，建议为 16M。
sort_buffer_size： sql 语句用来进行 sort 操作(order by,group by)的 buffer。如果 buffer 不够，则需要建立 temporary file。如果在 show global status 中发现有大量的 Sort_merge_passes 值，则需要考虑调大 sort_buffer_size。默认为 256k，建议设置为 16-32M。
binlog_cache_size： 表示每个 session 中存放 transaction 的 binlog 的 cache size。默认 32K。一般使用默认值即可。如果有大事务，可以考虑调大。
thread_stack： 每个进程都需要有，默认为 256K，使用默认值即可。

（ 4） 还有就是著名的 query cache 了，以及 query cache 的适用场景了，这里有一个陷阱，
就是高并发的情况下，比如双十一的时候， query cache 开还是不开，开了怎么保证高并发，不开又有何别的考虑？建议关闭，上了性能反而更差。2019-02-15 星期五 下午 20:55:00
2019-02-15 20:55:00.774[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:55:00.774[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 17-  168 6 、关于 mysql 参数优化的经验
复制代码

首先问他它们线上 mysql 数据库是怎么安装的，如果说是 rpm 安装的，那么我就直接问调优参数了，如果是源码安装的，那么我就要问编译中的一些参数了，比如 my.cnf 以及存储引擎以及字符类型等等。然后从以下几个方面问起：
（ 1） mysql 有哪些 global 内存参数，有哪些 local 内存参数。
Global:
innodb_buffer_pool_size/innodb_additional_mem_pool_size/innodb_log_buffer_size/key_buffer_size/query_cache_size/table_open_cache/table_definition_cache/thread_cache_size
Local:
read_buffer_size/read_rnd_buffer_size/sort_buffer_size/join_buffer_size/binlog_cache_size/tmp_table_size/thread_stack/bulk_insert_buffer_size

（ 2） mysql 的写入参数需要调整哪些？重要的几个写参数的几个值得含义以及适用场景，
比如 innodb_flush_log_at_trx_commit 等。 (求补充)
sync_binlog 设置为 1，保证 binlog 的安全性。
innodb_flush_log_at_trx_commit：
0：事务提交时不将 redo log buffer 写入磁盘(仅每秒进行 master thread 刷新，安全
性最差，性能最好)
1：事务提交时将 redo log buffer 写入磁盘(安全性最好，性能最差， 推荐生产使用)
2：事务提交时仅将 redo log buffer 写入操作系统缓存(安全性和性能都居中，当 mysql宕机但是操作系统不宕机则不丢数据，如果操作系统宕机，最多丢一秒数据)
innodb_io_capacity/innodb_io_capacity_max：看磁盘的性能来定。如果是 HDD 可以设置为 200-几百不等。如果是 SSD，推荐为 4000 左右。 innodb_io_capacity_max 更大一些。
innodb_flush_method 设置为 O_DIRECT。

（ 3） 读取的话，那几个全局的 pool 的值的设置，以及几个 local 的 buffer 的设置。
Global:
innodb_buffer_pool_size:设置为可用内存的 50%-60%左右，如果不够，再慢慢上调。
innodb_additional_mem_pool_size：采用默认值 8M 即可。
innodb_log_buffer_size:默认值 8M 即可。
key_buffer_size:myisam 表需要的 buffer size，选择基本都用 innodb，所以采用默认的 8M 即可。
Local:
join_buffer_size： 当 sql 有 BNL 和 BKA 的时候，需要用的 buffer_size(plain index
scans, range index scans 的时候可能也会用到)。默认为 256k，建议设置为 16M-32M。
read_rnd_buffer_size：当使用 mrr 时，用到的 buffer。默认为 256k，建议设置为16-32M。
read_buffer_size:当顺序扫描一个 myisam 表，需要用到这个 buffer。或者用来决定memory table 的大小。或者所有的 engine 类型做如下操作：order by 的时候用 temporaryfile、 SELECT INTO … OUTFILE 'filename' 、 For caching results of nested queries。默认为 128K，建议为 16M。
sort_buffer_size： sql 语句用来进行 sort 操作(order by,group by)的 buffer。如果 buffer 不够，则需要建立 temporary file。如果在 show global status 中发现有大量的 Sort_merge_passes 值，则需要考虑调大 sort_buffer_size。默认为 256k，建议设置为 16-32M。
binlog_cache_size： 表示每个 session 中存放 transaction 的 binlog 的 cache size。默认 32K。一般使用默认值即可。如果有大事务，可以考虑调大。
thread_stack： 每个进程都需要有，默认为 256K，使用默认值即可。

（ 4） 还有就是著名的 query cache 了，以及 query cache 的适用场景了，这里有一个陷阱，
就是高并发的情况下，比如双十一的时候， query cache 开还是不开，开了怎么保证高并发，不开又有何别的考虑？建议关闭，上了性能反而更差。2019-02-15 星期五 下午 20:55:00
2019-02-15 20:55:01.084[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [bh__LA03035508]"}
2019-02-15 20:55:01.084[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [bh__LA03035508]"}
2019-02-15 20:55:30.776[INFO ][com.hl.Hao123Application ] 22222222222222, 18-  189 （4）为什么redis需要把所有数据放到内存中？

Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。
如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。2019-02-15 星期五 下午 20:55:30
2019-02-15 20:55:30.776[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:55:30.776[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 18-  189 （4）为什么redis需要把所有数据放到内存中？

Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。
如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。2019-02-15 星期五 下午 20:55:30
2019-02-15 20:55:31.056[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [JUuIrA03334108]"}
2019-02-15 20:55:31.056[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [JUuIrA03334108]"}
2019-02-15 20:56:00.776[INFO ][com.hl.Hao123Application ] 22222222222222, 19-  93 ConcurrentHashMap的并发度是什么?
ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？
ConcurrentHashMap的工作原理
ConcurrentHashMap在jdk 1.6和jdk 1.8实现原理是不同的。
jdk 1.6:
ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。 
具体实现:ConcurrentHashMap内部有一个Segment.
jdk 1.8
在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表->红黑树”的实现。2019-02-15 星期五 下午 20:56:00
2019-02-15 20:56:00.776[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:56:00.776[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 19-  93 ConcurrentHashMap的并发度是什么?
ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？
ConcurrentHashMap的工作原理
ConcurrentHashMap在jdk 1.6和jdk 1.8实现原理是不同的。
jdk 1.6:
ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。 
具体实现:ConcurrentHashMap内部有一个Segment.
jdk 1.8
在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表->红黑树”的实现。2019-02-15 星期五 下午 20:56:00
2019-02-15 20:56:01.056[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [yIq.3a03633955]"}
2019-02-15 20:56:01.056[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [yIq.3a03633955]"}
2019-02-15 20:56:30.776[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  342  电话一面
忽然接到一面面试官的电话，说现在有时间吗，能够接受下电话面试吗？约了周一上午 10 点面试。
周一 10 点面试官准时打电话过来了！
以下是面试的问题：
1、自我介绍
2、Map 的底层结构？（HashMap）
3、线程安全的 Map （concurrentHashMap）简单的说了下这两 1。7 和 1.8 的区别，本想问下要不要深入的讲下（源码级别），结果面试官说不用了。
4、项目 MySQL 的数据量和并发量有多大？
5、你对数据库了解多少？
6、你说下数据库的索引实现和非主键的二级索引
7、项目用的是 SpringBoot ，你能说下 Spring Boot 与 Spring 的区别吗？
8、SpringBoot 的自动配置是怎么做的？
9、MyBatis 定义的接口，怎么找到实现的？
10、Java 内存结构
11、对象是否可 GC？
12、Minor GC 和 Full GC
13、垃圾回收算法
14、垃圾回收器 G1
15、项目里用过 ElasticSearch 和 Hbase，有深入了解他们的调优技巧吗？
16、Spring RestTemplate 的具体实现
17、描述下网页一个 Http 请求，到后端的整个请求过程
18、多线程的常用方法和接口类及线程池的机制
19、总结我的 Java 基础还是不错，但是一些主流的框架源码还是处在使用的状态，需要继续去看源码
20、死锁
21、自己研究比较新的技术，说下成果！
22、你有什么想问的？我就问了下公司那边的情况，这个自由发挥！
最后我知道有二面的面试机会了。
10 来分钟不到，就再次打电话过来约了明早上午 10 点的视频面试。2019-02-15 星期五 下午 20:56:30
2019-02-15 20:56:30.776[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:56:30.776[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  342  电话一面
忽然接到一面面试官的电话，说现在有时间吗，能够接受下电话面试吗？约了周一上午 10 点面试。
周一 10 点面试官准时打电话过来了！
以下是面试的问题：
1、自我介绍
2、Map 的底层结构？（HashMap）
3、线程安全的 Map （concurrentHashMap）简单的说了下这两 1。7 和 1.8 的区别，本想问下要不要深入的讲下（源码级别），结果面试官说不用了。
4、项目 MySQL 的数据量和并发量有多大？
5、你对数据库了解多少？
6、你说下数据库的索引实现和非主键的二级索引
7、项目用的是 SpringBoot ，你能说下 Spring Boot 与 Spring 的区别吗？
8、SpringBoot 的自动配置是怎么做的？
9、MyBatis 定义的接口，怎么找到实现的？
10、Java 内存结构
11、对象是否可 GC？
12、Minor GC 和 Full GC
13、垃圾回收算法
14、垃圾回收器 G1
15、项目里用过 ElasticSearch 和 Hbase，有深入了解他们的调优技巧吗？
16、Spring RestTemplate 的具体实现
17、描述下网页一个 Http 请求，到后端的整个请求过程
18、多线程的常用方法和接口类及线程池的机制
19、总结我的 Java 基础还是不错，但是一些主流的框架源码还是处在使用的状态，需要继续去看源码
20、死锁
21、自己研究比较新的技术，说下成果！
22、你有什么想问的？我就问了下公司那边的情况，这个自由发挥！
最后我知道有二面的面试机会了。
10 来分钟不到，就再次打电话过来约了明早上午 10 点的视频面试。2019-02-15 星期五 下午 20:56:30
2019-02-15 20:56:31.078[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [glwrVA03934120]"}
2019-02-15 20:56:31.078[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [glwrVA03934120]"}
2019-02-15 20:57:00.768[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  105 import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class ThreadA {
	static int i = 1;
	public static void main(String[] args) {
		fixedThreadPool();
		singleThreadPool();
		cachedThreadPool();
	}
	public static void fixedThreadPool() {
		ExecutorService es = Executors.newFixedThreadPool(3);
		for (int i = 1; i <= 10; i++) {
			final int task = i ;
			es.execute(new Runnable() {
				@Override
				public void run() {
					for (int j = 1; j <= 5; j++) { //假设j代表绕操场跑几圈
						System.out.println(Thread.currentThread().getName()+"目前正在跑第"+task+"个任务中的第"+j+"圈");
					}
				}
			});
		}
	}
	public static void singleThreadPool() {
		ExecutorService es = Executors.newSingleThreadExecutor();
		for (int i = 1; i <= 10; i++) {
			final int task = i ;
			es.execute(new Runnable() {
				@Override
				public void run() {
					for (int j = 1; j <= 5; j++) { //假设j代表绕操场跑几圈
						System.out.println(Thread.currentThread().getName()+"目前正在跑第"+task+"个任务中的第"+j+"圈");
					}
				}
			});
		}
	}
	public static void cachedThreadPool() {
		ExecutorService es = Executors.newCachedThreadPool();
		for (int i = 1; i <= 10; i++) {
			final int task = i ;
			es.execute(new Runnable() {
				@Override
				public void run() {
					for (int j = 1; j <= 5; j++) { //假设j代表绕操场跑几圈
						System.out.println(Thread.currentThread().getName()+"目前正在跑第"+task+"个任务中的第"+j+"圈");
					}
				}
			});
		}
	}
}
2019-02-15 星期五 下午 20:57:00
2019-02-15 20:57:00.768[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:57:00.768[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  105 import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class ThreadA {
	static int i = 1;
	public static void main(String[] args) {
		fixedThreadPool();
		singleThreadPool();
		cachedThreadPool();
	}
	public static void fixedThreadPool() {
		ExecutorService es = Executors.newFixedThreadPool(3);
		for (int i = 1; i <= 10; i++) {
			final int task = i ;
			es.execute(new Runnable() {
				@Override
				public void run() {
					for (int j = 1; j <= 5; j++) { //假设j代表绕操场跑几圈
						System.out.println(Thread.currentThread().getName()+"目前正在跑第"+task+"个任务中的第"+j+"圈");
					}
				}
			});
		}
	}
	public static void singleThreadPool() {
		ExecutorService es = Executors.newSingleThreadExecutor();
		for (int i = 1; i <= 10; i++) {
			final int task = i ;
			es.execute(new Runnable() {
				@Override
				public void run() {
					for (int j = 1; j <= 5; j++) { //假设j代表绕操场跑几圈
						System.out.println(Thread.currentThread().getName()+"目前正在跑第"+task+"个任务中的第"+j+"圈");
					}
				}
			});
		}
	}
	public static void cachedThreadPool() {
		ExecutorService es = Executors.newCachedThreadPool();
		for (int i = 1; i <= 10; i++) {
			final int task = i ;
			es.execute(new Runnable() {
				@Override
				public void run() {
					for (int j = 1; j <= 5; j++) { //假设j代表绕操场跑几圈
						System.out.println(Thread.currentThread().getName()+"目前正在跑第"+task+"个任务中的第"+j+"圈");
					}
				}
			});
		}
	}
}
2019-02-15 星期五 下午 20:57:00
2019-02-15 20:57:01.008[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [cTEVma04234105]"}
2019-02-15 20:57:01.008[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [cTEVma04234105]"}
2019-02-15 20:57:30.770[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  374 mysql  执行计划9个列  id select_type table type possible_keys key key_len ref rows Extra2019-02-15 星期五 下午 20:57:30
2019-02-15 20:57:30.770[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:57:30.770[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  374 mysql  执行计划9个列  id select_type table type possible_keys key key_len ref rows Extra2019-02-15 星期五 下午 20:57:30
2019-02-15 20:57:31.030[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [NU3YGA04534100]"}
2019-02-15 20:57:31.030[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [NU3YGA04534100]"}
2019-02-15 20:58:00.770[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  83  https://www.cnblogs.com/felixzh/p/5869212.html                       Zookeeper的功能以及工作原理2019-02-15 星期五 下午 20:58:00
2019-02-15 20:58:00.770[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:58:00.770[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  83  https://www.cnblogs.com/felixzh/p/5869212.html                       Zookeeper的功能以及工作原理2019-02-15 星期五 下午 20:58:00
2019-02-15 20:58:01.220[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [xFR3Ga04843935]"}
2019-02-15 20:58:01.230[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [xFR3Ga04843935]"}
2019-02-15 20:58:30.770[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  77 https://www.cnblogs.com/stonefeng/p/5693560.html   观察者模式2019-02-15 星期五 下午 20:58:30
2019-02-15 20:58:30.770[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:58:30.770[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  77 https://www.cnblogs.com/stonefeng/p/5693560.html   观察者模式2019-02-15 星期五 下午 20:58:30
2019-02-15 20:58:31.050[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [JA2A.A05138653]"}
2019-02-15 20:58:31.050[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [JA2A.A05138653]"}
2019-02-15 20:59:00.770[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2232019-02-15 星期五 下午 20:59:00
2019-02-15 20:59:00.770[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:59:00.770[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2232019-02-15 星期五 下午 20:59:00
2019-02-15 20:59:01.020[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [e05434100]"}
2019-02-15 20:59:01.020[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [e05434100]"}
2019-02-15 20:59:30.770[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  90 o(1), o(n), o(logn), o(nlogn)
2017年07月15日 21:32:09 Mars93 阅读数：20454 标签： o-1-o-n 更多个人分类： tomcat
在描述算法复杂度时,经常用到o(1), o(n), o(logn), o(nlogn)来表示对应算法的时间复杂度, 这里进行归纳一下它们代表的含义: 
这是算法的时空复杂度的表示。不仅仅用于表示时间复杂度，也用于表示空间复杂度。 
O后面的括号中有一个函数，指明某个算法的耗时/耗空间与数据增长量之间的关系。其中的n代表输入数据的量。 
比如时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。 
再比如时间复杂度O(n^2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。 
再比如O(logn)，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。 
O(nlogn)同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。 
O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）  2019-02-15 星期五 下午 20:59:30
2019-02-15 20:59:30.770[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 20:59:30.770[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  90 o(1), o(n), o(logn), o(nlogn)
2017年07月15日 21:32:09 Mars93 阅读数：20454 标签： o-1-o-n 更多个人分类： tomcat
在描述算法复杂度时,经常用到o(1), o(n), o(logn), o(nlogn)来表示对应算法的时间复杂度, 这里进行归纳一下它们代表的含义: 
这是算法的时空复杂度的表示。不仅仅用于表示时间复杂度，也用于表示空间复杂度。 
O后面的括号中有一个函数，指明某个算法的耗时/耗空间与数据增长量之间的关系。其中的n代表输入数据的量。 
比如时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。 
再比如时间复杂度O(n^2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。 
再比如O(logn)，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。 
O(nlogn)同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。 
O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）  2019-02-15 星期五 下午 20:59:30
2019-02-15 20:59:31.030[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [loKa3a05733933]"}
2019-02-15 20:59:31.030[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [loKa3a05733933]"}
2019-02-15 21:00:00.771[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  191 （6）虚拟内存

当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大.
当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value.
vm-max-threads这个参数,可以设置访问swap文件的线程数,设置最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证.

自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库2019-02-15 星期五 下午 21:00:00
2019-02-15 21:00:00.771[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:00:00.771[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  191 （6）虚拟内存

当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大.
当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value.
vm-max-threads这个参数,可以设置访问swap文件的线程数,设置最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证.

自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库2019-02-15 星期五 下午 21:00:00
2019-02-15 21:00:01.023[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [YSzwta0603shc2]"}
2019-02-15 21:00:01.024[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [YSzwta0603shc2]"}
2019-02-15 21:00:30.773[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  193 （8）读写分离模型

通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。
读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。2019-02-15 星期五 下午 21:00:30
2019-02-15 21:00:30.773[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:00:30.773[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  193 （8）读写分离模型

通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。
读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。2019-02-15 星期五 下午 21:00:30
2019-02-15 21:00:31.043[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [pkC06334122]"}
2019-02-15 21:00:31.043[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [pkC06334122]"}
2019-02-15 21:01:00.776[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  368 这个分布式事务跟孙玄讲的基本一致    interview之前可以拿出来温故一下   https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html2019-02-15 星期五 下午 21:01:00
2019-02-15 21:01:00.776[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:01:00.776[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  368 这个分布式事务跟孙玄讲的基本一致    interview之前可以拿出来温故一下   https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html2019-02-15 星期五 下午 21:01:00
2019-02-15 21:01:01.066[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [z9o9SA06633116]"}
2019-02-15 21:01:01.066[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [z9o9SA06633116]"}
2019-02-15 21:01:30.776[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  7dubbo原理源码  
  https://www.cnblogs.com/gotodsp/p/6532856.html2019-02-15 星期五 下午 21:01:30
2019-02-15 21:01:30.776[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:01:30.776[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  7dubbo原理源码  
  https://www.cnblogs.com/gotodsp/p/6532856.html2019-02-15 星期五 下午 21:01:30
2019-02-15 21:01:31.036[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [SveY8a06933945]"}
2019-02-15 21:01:31.036[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [SveY8a06933945]"}
2019-02-15 21:02:00.776[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  178 内存泄漏  无非是GC没起到该有的作用 或是加载了大对象   Java JVM 内存泄露——全解析和处理办法
   https://www.cnblogs.com/ixenos/p/5674702.html?utm_source=itdadao&utm_medium=referral2019-02-15 星期五 下午 21:02:00
2019-02-15 21:02:00.776[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:02:00.776[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  178 内存泄漏  无非是GC没起到该有的作用 或是加载了大对象   Java JVM 内存泄露——全解析和处理办法
   https://www.cnblogs.com/ixenos/p/5674702.html?utm_source=itdadao&utm_medium=referral2019-02-15 星期五 下午 21:02:00
2019-02-15 21:02:01.026[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [MY21ha07234114]"}
2019-02-15 21:02:01.026[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [MY21ha07234114]"}
2019-02-15 21:02:30.776[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  306 https://mp.weixin.qq.com/s/lbiD1DiDSXyD1Lf8r2RiSQ  SpringBoot 使用线程池
2018 年了，SpringBoot 盛行；来看看在 SpringBoot 中应当怎么配置和使用线程池。
既然用了 SpringBoot ，那自然得发挥 Spring 的特性，所以需要 Spring 来帮我们管理线程池：
@Configuration
public class TreadPoolConfig {
    /**
     * 消费队列线程
     * @return
     */
    @Bean(value = "consumerQueueThreadPool")
    public ExecutorService buildConsumerQueueThreadPool(){
        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
                .setNameFormat("consumer-queue-thread-%d").build();

        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());

        return pool ;
    }
}
使用时：
    @Resource(name = "consumerQueueThreadPool")
    private ExecutorService consumerQueueThreadPool;
    @Override
    public void execute() {

        //消费队列
        for (int i = 0; i < 5; i++) {
            consumerQueueThreadPool.execute(new ConsumerQueueThread());
        }

    }
其实也挺简单，就是创建了一个线程池的 bean，在使用时直接从 Spring 中取出即可。
2019-02-15 星期五 下午 21:02:30
2019-02-15 21:02:30.776[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:02:30.776[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  306 https://mp.weixin.qq.com/s/lbiD1DiDSXyD1Lf8r2RiSQ  SpringBoot 使用线程池
2018 年了，SpringBoot 盛行；来看看在 SpringBoot 中应当怎么配置和使用线程池。
既然用了 SpringBoot ，那自然得发挥 Spring 的特性，所以需要 Spring 来帮我们管理线程池：
@Configuration
public class TreadPoolConfig {
    /**
     * 消费队列线程
     * @return
     */
    @Bean(value = "consumerQueueThreadPool")
    public ExecutorService buildConsumerQueueThreadPool(){
        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
                .setNameFormat("consumer-queue-thread-%d").build();

        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());

        return pool ;
    }
}
使用时：
    @Resource(name = "consumerQueueThreadPool")
    private ExecutorService consumerQueueThreadPool;
    @Override
    public void execute() {

        //消费队列
        for (int i = 0; i < 5; i++) {
            consumerQueueThreadPool.execute(new ConsumerQueueThread());
        }

    }
其实也挺简单，就是创建了一个线程池的 bean，在使用时直接从 Spring 中取出即可。
2019-02-15 星期五 下午 21:02:30
2019-02-15 21:02:31.036[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [nFb9Ra07532066]"}
2019-02-15 21:02:31.036[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [nFb9Ra07532066]"}
2019-02-15 21:03:00.777[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3342019-02-15 星期五 下午 21:03:00
2019-02-15 21:03:00.777[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:03:00.777[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3342019-02-15 星期五 下午 21:03:00
2019-02-15 21:03:01.097[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [GlzCSa07834125]"}
2019-02-15 21:03:01.097[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [GlzCSa07834125]"}
2019-02-15 21:03:30.777[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  82  https://www.cnblogs.com/taosim/articles/4238674.html   redis集群 使用一致性哈希算法2019-02-15 星期五 下午 21:03:30
2019-02-15 21:03:30.777[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:03:30.777[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  82  https://www.cnblogs.com/taosim/articles/4238674.html   redis集群 使用一致性哈希算法2019-02-15 星期五 下午 21:03:30
2019-02-15 21:03:31.027[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [imJfSa08138651]"}
2019-02-15 21:03:31.027[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [imJfSa08138651]"}
2019-02-15 21:04:00.777[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  243 基于k8s、docker、jenkins构建springboot服务
 http://www.mamicode.com/info-detail-2316898.html 2019-02-15 星期五 下午 21:04:00
2019-02-15 21:04:00.777[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:04:00.777[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  243 基于k8s、docker、jenkins构建springboot服务
 http://www.mamicode.com/info-detail-2316898.html 2019-02-15 星期五 下午 21:04:00
2019-02-15 21:04:01.077[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [Ch4hfa08434114]"}
2019-02-15 21:04:01.077[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [Ch4hfa08434114]"}
2019-02-15 21:04:30.777[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  87     @RequestMapping(value = "/showCodes", method = RequestMethod.POST)
    @ResponseBody
    public Object showCodes(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        Map<String, String> map = new HashMap<String, String>();
        map.put("code1", apiCode900500RetNo);
        map.put("code2", apiCode900510RetNo);
        // OutputStream out = resp.getOutputStream();
        // out.write(("{\"code2\":" + apiCode900510RetNo + ",\"code1\":" + apiCode900500RetNo + "}").getBytes());
        // out.flush();
        // out.close();
        return map;
    }    这两种传值给前端的方法是等效的2019-02-15 星期五 下午 21:04:30
2019-02-15 21:04:30.777[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:04:30.777[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  87     @RequestMapping(value = "/showCodes", method = RequestMethod.POST)
    @ResponseBody
    public Object showCodes(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        Map<String, String> map = new HashMap<String, String>();
        map.put("code1", apiCode900500RetNo);
        map.put("code2", apiCode900510RetNo);
        // OutputStream out = resp.getOutputStream();
        // out.write(("{\"code2\":" + apiCode900510RetNo + ",\"code1\":" + apiCode900500RetNo + "}").getBytes());
        // out.flush();
        // out.close();
        return map;
    }    这两种传值给前端的方法是等效的2019-02-15 星期五 下午 21:04:30
2019-02-15 21:04:31.077[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [08734119]"}
2019-02-15 21:04:31.077[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [08734119]"}
2019-02-15 21:05:00.777[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2822019-02-15 星期五 下午 21:05:00
2019-02-15 21:05:00.777[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:05:00.777[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2822019-02-15 星期五 下午 21:05:00
2019-02-15 21:05:01.047[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [ChkBga09034128]"}
2019-02-15 21:05:01.047[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [ChkBga09034128]"}
2019-02-15 21:05:30.777[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  37zookeeper实现服务注册与发现原理2019-02-15 星期五 下午 21:05:30
2019-02-15 21:05:30.777[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:05:30.777[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  37zookeeper实现服务注册与发现原理2019-02-15 星期五 下午 21:05:30
2019-02-15 21:05:31.027[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [7Xxrfa09334119]"}
2019-02-15 21:05:31.027[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [7Xxrfa09334119]"}
2019-02-15 21:06:00.777[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2892019-02-15 星期五 下午 21:06:00
2019-02-15 21:06:00.777[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:06:00.777[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2892019-02-15 星期五 下午 21:06:00
2019-02-15 21:06:01.077[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [mb09638651]"}
2019-02-15 21:06:01.077[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [mb09638651]"}
2019-02-15 21:06:30.777[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  344 Arraylist与linkedlist的区别

a) 都是实现list接口的列表，arraylist是基于数组的数据结构，linkedlist是基于链表的数据结构，当获取特定元素时，ArrayList效率比较快，它通过数组下标即可获取，而linkedlist则需要移动指针。当存储元素与删除元素时linkedlist效率较快，只需要将指针移动指定位置增加或者删除即可，而arraylist需要移动数据。
--------------------- 
作者：白衣染霜华丶 
来源：CSDN 
原文：https://blog.csdn.net/zhangcc233/article/details/77847104 
版权声明：本文为博主原创文章，转载请附上博文链接！2019-02-15 星期五 下午 21:06:30
2019-02-15 21:06:30.777[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:06:30.777[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  344 Arraylist与linkedlist的区别

a) 都是实现list接口的列表，arraylist是基于数组的数据结构，linkedlist是基于链表的数据结构，当获取特定元素时，ArrayList效率比较快，它通过数组下标即可获取，而linkedlist则需要移动指针。当存储元素与删除元素时linkedlist效率较快，只需要将指针移动指定位置增加或者删除即可，而arraylist需要移动数据。
--------------------- 
作者：白衣染霜华丶 
来源：CSDN 
原文：https://blog.csdn.net/zhangcc233/article/details/77847104 
版权声明：本文为博主原创文章，转载请附上博文链接！2019-02-15 星期五 下午 21:06:30
2019-02-15 21:06:31.047[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [ud54409932277]"}
2019-02-15 21:06:31.047[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [ud54409932277]"}
2019-02-15 21:07:00.787[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  106 

这种搞法太粗犷了，每次都新建一个线程，太浪费了，迟早会崩掉的。 看ThreadB1

public class ThreadB {
	static int i = 1;
	public static void main(String[] args) {
		while(true) {
		 new Thread(new Runnable() {
			@Override
			public void run() {
				synchronized (ThreadA.class) {
					if(i<=0) {
						try {
							Thread.currentThread();
							Thread.sleep(200);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						System.out.println("生产者："+(++i));
					}
				}
			}
		}).start();
		 new Thread(new Runnable() {
				@Override
				public void run() {
					synchronized (ThreadA.class) {
						if(i>=1) {
							try {
								Thread.currentThread();
								Thread.sleep(200);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
							System.out.println("消费者："+(--i));
						}
					}
				}
			}).start();
		}
	}
}

2019-02-15 星期五 下午 21:07:00
2019-02-15 21:07:00.787[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:07:00.787[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  106 

这种搞法太粗犷了，每次都新建一个线程，太浪费了，迟早会崩掉的。 看ThreadB1

public class ThreadB {
	static int i = 1;
	public static void main(String[] args) {
		while(true) {
		 new Thread(new Runnable() {
			@Override
			public void run() {
				synchronized (ThreadA.class) {
					if(i<=0) {
						try {
							Thread.currentThread();
							Thread.sleep(200);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						System.out.println("生产者："+(++i));
					}
				}
			}
		}).start();
		 new Thread(new Runnable() {
				@Override
				public void run() {
					synchronized (ThreadA.class) {
						if(i>=1) {
							try {
								Thread.currentThread();
								Thread.sleep(200);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
							System.out.println("消费者："+(--i));
						}
					}
				}
			}).start();
		}
	}
}

2019-02-15 星期五 下午 21:07:00
2019-02-15 21:07:01.067[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [rV6q300234100]"}
2019-02-15 21:07:01.067[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [rV6q300234100]"}
2019-02-15 21:07:30.787[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  153 6、下MySQL数据库cpu飙升到500%的话他怎么处理？

当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，
看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。也有可能是每个 sql 消耗资源并不多，但是突然之间，
有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等

2019-02-15 星期五 下午 21:07:30
2019-02-15 21:07:30.787[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:07:30.787[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  153 6、下MySQL数据库cpu飙升到500%的话他怎么处理？

当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，
看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。也有可能是每个 sql 消耗资源并不多，但是突然之间，
有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等

2019-02-15 星期五 下午 21:07:30
2019-02-15 21:07:31.037[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [7XNqwa00532277]"}
2019-02-15 21:07:31.037[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [7XNqwa00532277]"}
2019-02-15 21:08:00.787[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  227 说明
网上看到大量的文章讲到MVCC都是说给每一行增加两个隐藏的字段分别表示行的创建时间以及过期时间，它们存储的并不是时间，而是事务版本号。
事实上，这种说法并不准确，严格的来讲，InnoDB会给数据库中的每一行增加三个字段，它们分别是DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID。
但是，为了理解的方便，我们可以这样去理解，索引接下来的讲解中也还是用这两个字段的方式去理解。
增删查改
在InnoDB中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。
于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：
SELECT读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
INSERT将当前事务的版本号保存至行的创建版本号
UPDATE新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
DELETE将当前事务的版本号保存至行的删除版本号
快照读和当前读
快照读：读取的是快照版本，也就是历史版本
当前读：读取的是最新版本
普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。2019-02-15 星期五 下午 21:08:00
2019-02-15 21:08:00.787[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:08:00.787[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  227 说明
网上看到大量的文章讲到MVCC都是说给每一行增加两个隐藏的字段分别表示行的创建时间以及过期时间，它们存储的并不是时间，而是事务版本号。
事实上，这种说法并不准确，严格的来讲，InnoDB会给数据库中的每一行增加三个字段，它们分别是DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID。
但是，为了理解的方便，我们可以这样去理解，索引接下来的讲解中也还是用这两个字段的方式去理解。
增删查改
在InnoDB中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。
于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：
SELECT读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
INSERT将当前事务的版本号保存至行的创建版本号
UPDATE新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
DELETE将当前事务的版本号保存至行的删除版本号
快照读和当前读
快照读：读取的是快照版本，也就是历史版本
当前读：读取的是最新版本
普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。2019-02-15 星期五 下午 21:08:00
2019-02-15 21:08:01.147[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [DY2JWA00833952]"}
2019-02-15 21:08:01.147[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [DY2JWA00833952]"}
2019-02-15 21:08:30.787[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  284  ---------------------Merge Tool的使用-------------------------------------------
这个东西只有在有红色双向箭头的时候才可用，否则是灰色的    所以要先使用merge，让代码合并在一起，并标识出冲突，才能使用Merge Tool 
把代码pull下来  或者将另一个分支代码merge到当前分支都可以让冲突出现   有时候需要commit一下 才会让红色冲突出现
另外 要知道  在merge tool  视图  左边是自己workspace里面的代码  右边是远端代码 
注意左边的代码是可以编辑的（不能用ctr + d 快捷键  我也不知道为什么）  右边的代码 不可以编辑
 编辑完之后  将代码  add to  index  一下   这样 红色双向箭头就变成了 黑色星号  （紧张情绪一下子缓解了） 就可以正常提交了2019-02-15 星期五 下午 21:08:30
2019-02-15 21:08:30.787[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:08:30.787[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  284  ---------------------Merge Tool的使用-------------------------------------------
这个东西只有在有红色双向箭头的时候才可用，否则是灰色的    所以要先使用merge，让代码合并在一起，并标识出冲突，才能使用Merge Tool 
把代码pull下来  或者将另一个分支代码merge到当前分支都可以让冲突出现   有时候需要commit一下 才会让红色冲突出现
另外 要知道  在merge tool  视图  左边是自己workspace里面的代码  右边是远端代码 
注意左边的代码是可以编辑的（不能用ctr + d 快捷键  我也不知道为什么）  右边的代码 不可以编辑
 编辑完之后  将代码  add to  index  一下   这样 红色双向箭头就变成了 黑色星号  （紧张情绪一下子缓解了） 就可以正常提交了2019-02-15 星期五 下午 21:08:30
2019-02-15 21:08:31.087[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [aCBFIa01133949]"}
2019-02-15 21:08:31.087[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [aCBFIa01133949]"}
2019-02-15 21:09:00.787[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  75    策略模式  今天看这个类图   感觉无比简单啊  https://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html2019-02-15 星期五 下午 21:09:00
2019-02-15 21:09:00.787[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:09:00.787[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  75    策略模式  今天看这个类图   感觉无比简单啊  https://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html2019-02-15 星期五 下午 21:09:00
2019-02-15 21:09:01.067[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [ZhQeJa01434924]"}
2019-02-15 21:09:01.067[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [ZhQeJa01434924]"}
2019-02-15 21:09:30.787[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  32set是怎么实现不重复的   https://blog.csdn.net/u010698072/article/details/52802179   一句话，用hashMap存储，key值不会重复 所以set也不会重复2019-02-15 星期五 下午 21:09:30
2019-02-15 21:09:30.787[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:09:30.787[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  32set是怎么实现不重复的   https://blog.csdn.net/u010698072/article/details/52802179   一句话，用hashMap存储，key值不会重复 所以set也不会重复2019-02-15 星期五 下午 21:09:30
2019-02-15 21:09:31.047[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [CgUwCa01734123]"}
2019-02-15 21:09:31.047[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [CgUwCa01734123]"}
2019-02-15 21:10:00.787[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3342019-02-15 星期五 下午 21:10:00
2019-02-15 21:10:00.787[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:10:00.787[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3342019-02-15 星期五 下午 21:10:00
2019-02-15 21:10:01.077[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [mxErua02034124]"}
2019-02-15 21:10:01.077[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [mxErua02034124]"}
2019-02-15 21:10:30.787[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3172019-02-15 星期五 下午 21:10:30
2019-02-15 21:10:30.787[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:10:30.787[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3172019-02-15 星期五 下午 21:10:30
2019-02-15 21:10:31.037[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [FVSO7a0233shc2]"}
2019-02-15 21:10:31.037[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [FVSO7a0233shc2]"}
2019-02-15 21:11:00.787[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  299 activemq 的虚拟主题 VitualTopic
创建时间：2016年8月24日(星期三) 晚上7:38 | 分类：未分类 | 天气：深圳多云 | 字数：143  | 另存为... | 打印 | 添加到日历
比如说 银行后台的转账那里的代码，比如要发多种信息，邮件，短信，APP消息，微信消息，这种就要对接多种平台，多个平台内部还是多负载，这个时候你不能直接用队列了，因为只有一个平台的一个负载会收到，也不能用简单的topic，因为所有平台的所有负载都会收到。虚拟主题是为这种情形量身定做的。2019-02-15 星期五 下午 21:11:00
2019-02-15 21:11:00.787[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:11:00.787[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  299 activemq 的虚拟主题 VitualTopic
创建时间：2016年8月24日(星期三) 晚上7:38 | 分类：未分类 | 天气：深圳多云 | 字数：143  | 另存为... | 打印 | 添加到日历
比如说 银行后台的转账那里的代码，比如要发多种信息，邮件，短信，APP消息，微信消息，这种就要对接多种平台，多个平台内部还是多负载，这个时候你不能直接用队列了，因为只有一个平台的一个负载会收到，也不能用简单的topic，因为所有平台的所有负载都会收到。虚拟主题是为这种情形量身定做的。2019-02-15 星期五 下午 21:11:00
2019-02-15 21:11:01.067[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [S02634121]"}
2019-02-15 21:11:01.067[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [S02634121]"}
2019-02-15 21:11:30.787[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  73关于垃圾回收
你知道哪些垃圾回收算法?

垃圾回收从理论上非常容易理解,具体的方法有以下几种: 
1. 标记-清除 
2. 标记-复制 
3. 标记-整理 
4. 分代回收 
更详细的内容参见深入理解垃圾回收算法：

http://blog.csdn.net/dd864140130/article/details/50084471
如何判断一个对象是否应该被回收

这就是所谓的对象存活性判断，常用的方法有两种：1.引用计数法;　2.对象可达性分析。由于引用计数法存在互相引用导致无法进行GC的问题，所以目前JVM虚拟机多使用对象可达性分析算法。
简单的解释一下垃圾回收

Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。
调用System.gc()会发生什么?

通知GC开始工作，但是GC真正开始的时间不确定。2019-02-15 星期五 下午 21:11:30
2019-02-15 21:11:30.787[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:11:30.787[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  73关于垃圾回收
你知道哪些垃圾回收算法?

垃圾回收从理论上非常容易理解,具体的方法有以下几种: 
1. 标记-清除 
2. 标记-复制 
3. 标记-整理 
4. 分代回收 
更详细的内容参见深入理解垃圾回收算法：

http://blog.csdn.net/dd864140130/article/details/50084471
如何判断一个对象是否应该被回收

这就是所谓的对象存活性判断，常用的方法有两种：1.引用计数法;　2.对象可达性分析。由于引用计数法存在互相引用导致无法进行GC的问题，所以目前JVM虚拟机多使用对象可达性分析算法。
简单的解释一下垃圾回收

Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。
调用System.gc()会发生什么?

通知GC开始工作，但是GC真正开始的时间不确定。2019-02-15 星期五 下午 21:11:30
2019-02-15 21:11:31.097[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [iWSNpa02934102]"}
2019-02-15 21:11:31.097[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [iWSNpa02934102]"}
2019-02-15 21:12:00.787[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  269  linux安装elasticsearch
   https://blog.csdn.net/yowrhihoil/article/details/79746430   你看 使用ES的过程是不是这样的  部署好ES  然后添加分词插件  然后就启动定时任务 将业务数据扔进es dml都需要同步到es，可以最后修改时间来判断是否是增量数据，然后同步到es，然后再从es检索2019-02-15 星期五 下午 21:12:00
2019-02-15 21:12:00.787[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:12:00.787[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  269  linux安装elasticsearch
   https://blog.csdn.net/yowrhihoil/article/details/79746430   你看 使用ES的过程是不是这样的  部署好ES  然后添加分词插件  然后就启动定时任务 将业务数据扔进es dml都需要同步到es，可以最后修改时间来判断是否是增量数据，然后同步到es，然后再从es检索2019-02-15 星期五 下午 21:12:00
2019-02-15 21:12:01.057[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [JYp5Sa03238672]"}
2019-02-15 21:12:01.057[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [JYp5Sa03238672]"}
2019-02-15 21:12:30.788[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  343  视频二面
二面面试官先打电话过来，然后加了个微信，开始微信视频面试
这个面试我也不太记得具体面试题目了，下面写的是大概方向的：
1、HashMap，源码级别的问了，包括为什么线程不安全
2、死锁
3、Synchronized 和 ReentrantLock 锁机制，怎么判断重入锁的，会不会是死锁？
4、进程和线程的区别？
5、进程之间如何保证同步？
6、分布式锁
7、对象 GC
8、垃圾回收算法
9、JVM 参数
10、OOM 出现的有哪些场景？为什么会发生？
11、JVM 内存结构说下吧
12、堆和栈的共享问题？
13、有比较过 Http 和 RPC 吗？
14、HttpClient 你说说里面的具体实现吧？（涉及了哪些东西）
15、那要你设计一个高性能的 Http ，你会怎么设计？
二面微信视频面试只记得这么多了。2019-02-15 星期五 下午 21:12:30
2019-02-15 21:12:30.788[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:12:30.788[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  343  视频二面
二面面试官先打电话过来，然后加了个微信，开始微信视频面试
这个面试我也不太记得具体面试题目了，下面写的是大概方向的：
1、HashMap，源码级别的问了，包括为什么线程不安全
2、死锁
3、Synchronized 和 ReentrantLock 锁机制，怎么判断重入锁的，会不会是死锁？
4、进程和线程的区别？
5、进程之间如何保证同步？
6、分布式锁
7、对象 GC
8、垃圾回收算法
9、JVM 参数
10、OOM 出现的有哪些场景？为什么会发生？
11、JVM 内存结构说下吧
12、堆和栈的共享问题？
13、有比较过 Http 和 RPC 吗？
14、HttpClient 你说说里面的具体实现吧？（涉及了哪些东西）
15、那要你设计一个高性能的 Http ，你会怎么设计？
二面微信视频面试只记得这么多了。2019-02-15 星期五 下午 21:12:30
2019-02-15 21:12:31.038[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [jDXPCa0353a394]"}
2019-02-15 21:12:31.038[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [jDXPCa0353a394]"}
2019-02-15 21:13:00.788[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  253 chmod 777  文件或目录
示例：chmod  777 /etc/squid 运行命令后，squid文件夹（目录）的权限就被修改为777（可读可写可执行）。
如果是Ubuntu系统，可能需要加上sudo来执行：
sudo chmod  777 /etc/squid
故事的开始，都会先留一个悬念。
只有程序员能懂的冷笑话系列中，有个比较经典的段子：
请用最简洁的语言描述我国FL。
754。
所以，754是什么意思呢？754是什么意思呢？754是什么意思呢？
下面具体介绍chmod命令。
Linux系统中，每个用户的角色和权限划分的很细致也很严格，每个文件（目录）都设有访问许可权限，利用这种机制来决定某个用户通过某种方式对文件（目录）进行读、写、执行等操作。
操作文件或目录的用户，有3种不同类型：文件所有者、群组用户、其他用户。最高位表示文件所有者的权限值，中间位表示群组用户的权限值，最低位则表示其他用户的权限值，所以，chmod 777中，三个数字7分别对应上面三种用户，权限值都为7。
文件或目录的权限又分为3种：只读、只写、可执行。
权限  权限数值    二进制 具体作用
r   4   00000100    read，读取。当前用户可以读取文件内容，当前用户可以浏览目录。
w   2   00000010    write，写入。当前用户可以新增或修改文件内容，当前用户可以删除、移动目录或目录内文件。
x   1   00000001    execute，执行。当前用户可以执行文件，当前用户可以进入目录。
2019-02-15 星期五 下午 21:13:00
2019-02-15 21:13:00.788[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:13:00.788[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  253 chmod 777  文件或目录
示例：chmod  777 /etc/squid 运行命令后，squid文件夹（目录）的权限就被修改为777（可读可写可执行）。
如果是Ubuntu系统，可能需要加上sudo来执行：
sudo chmod  777 /etc/squid
故事的开始，都会先留一个悬念。
只有程序员能懂的冷笑话系列中，有个比较经典的段子：
请用最简洁的语言描述我国FL。
754。
所以，754是什么意思呢？754是什么意思呢？754是什么意思呢？
下面具体介绍chmod命令。
Linux系统中，每个用户的角色和权限划分的很细致也很严格，每个文件（目录）都设有访问许可权限，利用这种机制来决定某个用户通过某种方式对文件（目录）进行读、写、执行等操作。
操作文件或目录的用户，有3种不同类型：文件所有者、群组用户、其他用户。最高位表示文件所有者的权限值，中间位表示群组用户的权限值，最低位则表示其他用户的权限值，所以，chmod 777中，三个数字7分别对应上面三种用户，权限值都为7。
文件或目录的权限又分为3种：只读、只写、可执行。
权限  权限数值    二进制 具体作用
r   4   00000100    read，读取。当前用户可以读取文件内容，当前用户可以浏览目录。
w   2   00000010    write，写入。当前用户可以新增或修改文件内容，当前用户可以删除、移动目录或目录内文件。
x   1   00000001    execute，执行。当前用户可以执行文件，当前用户可以进入目录。
2019-02-15 星期五 下午 21:13:00
2019-02-15 21:13:01.048[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [SXQGNa03834108]"}
2019-02-15 21:13:01.048[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [SXQGNa03834108]"}
2019-02-15 21:13:30.785[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2402019-02-15 星期五 下午 21:13:30
2019-02-15 21:13:30.785[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:13:30.785[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2402019-02-15 星期五 下午 21:13:30
2019-02-15 21:13:31.220[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [WMhe904134116]"}
2019-02-15 21:13:31.220[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [WMhe904134116]"}
2019-02-15 21:14:00.792[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  257  MVCC  这是读事务永远不会被阻塞的工具。从这篇文章看，读已提交应该叫做，读当前并发的其他事务提交之前的的旧版本数据来保证读事务不会被阻塞。 写事务遇到这种状况当然就被阻塞了。写事务里面会加行锁或者表锁的  如果没有索引，所以update会锁表，如果加了索引，就会锁行https://www.cnblogs.com/wodebudong/articles/7976474.html        1.2 实现 
MVCC 使用时间戳（TS）、递增的事务 ID（T）实现事务一致性。
MVCC 通过维护多版本数据，保证一个读事务永远不会被阻塞。对象 P 维护有多个版本，每个版本会有一个读时间戳（Read TimeStamp, RTS）和 写时间戳（Write TimeStamp, WTS），事务 Ti 读对象 P 的最新版本，该版本早于事务 Ti 的读时间戳 RTS(Ti)。
事务 Ti 要对 P 执行写操作，如果有其他事务 Tk 同时对 P 操作，则 RTS(Ti）必须要早于 RTS(Tk)，即有 RTS(Ti) < RTS(Tk)，这样对 Ti 对 P 的写操作才能完成。一般地，如果其他事务拥有 P 的一个更早的读时间戳的情况下，写操作是不能完成的。打个比方就是在存储前面有一道线，只有等你前面的人的完成了他们的事务，你的修改事务才可以提交完成。
重复说一下：每个对象 P 有一个时间戳 TS，如果事务 Ti 想要对 P 执行写操作，（写要先读）事务的读时间戳是 RTS(Ti)，如果有其他事务拥有一个比较早的时间戳，有 TS(P) < RTS(Ti)，这时事务 Ti 会退出并重新开始。否则，事务 Ti 创建一个 P 的新版本，并设置新版本 P 的时间戳，似的 TS = TS(Ti)。
MVCC 系统明显的缺点是会存储多个版本数据的冗余开销。但同时，读操作永不会被阻塞，这对那些以读操作为主的数据库来说非常重要。MVCC 实现了真的快照隔离（snapshot isolation），然后其他的并发控制方法要么是不完整的快照隔离方式，要么需要较高的性能损耗。
Wikipedia 中的内容有点繁琐，简单地，上面的描述，阐明了在同一数据版本下写操作的限制，已经通过多版本实现快照隔离的优越性。
1.3 示例
TimeObject1Object2
0 "Foo" by T0 "Bar" by T0 
1 "Hello" by T1  
Time=1的时候数据库的状态如上：
T0 写 Object1 为 "Foo"，写 Object2 为 "Bar"；之后 T1 写 Object1 为 "Hello"，保留 Object2 为原始值。 Object1 的新值将取代 Time=0 时刻的旧值，并提供给 T1提交之后的发生的所有事务。Object1的版本号为0的旧数据会被 GC 掉。
如果有一个长事务 T2，在 T1之后对 Object1和 Object2 进行读操作，同时并行地，有事务 T3 做更新：删除 Object2、增加 Object3="Foo-Bar"，在 Time=2 数据的状态如下所示：
TimeObject1Object2Object3
0 "Foo" by T0 "Bar" by T0  
1 "Hello" by T1   
2  (delete)by T3 "Foo-Bar" by T3 
在 Time=2 Object2有一个新版本：标记删除，同时增加了新对象 Object3 。T2 和 T3 并发执行，T2 看到的是数据在 Time=2且 T3提交前的版本，这样 T2读到了 Object2="Bar""且Object1="Hello"。
以上就是 MVCC 在不加锁的情况下实现的快照隔离的读的原理。
1.4 历史
最早于1978年，论文『Naming and Synchronization in a Decentralized Computer System』清晰地介绍了 MVCC，这是公认关于 MVCC 最早的工作。
在1981年，论文『Concurrency Control in Distributed Database System』介绍MVCC的一些细节。
目前支持 MVCC 的数据库，包括 DB2、Oracle、Sybase、SQL Server、MySQL、PG 等所有主流数据库，以及 HBase、Couchbase、Berkeley DB 等 NoSQL 数据库   https://www.cnblogs.com/YFYkuner/p/5178684.html2019-02-15 星期五 下午 21:14:00
2019-02-15 21:14:00.792[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:14:00.792[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  257  MVCC  这是读事务永远不会被阻塞的工具。从这篇文章看，读已提交应该叫做，读当前并发的其他事务提交之前的的旧版本数据来保证读事务不会被阻塞。 写事务遇到这种状况当然就被阻塞了。写事务里面会加行锁或者表锁的  如果没有索引，所以update会锁表，如果加了索引，就会锁行https://www.cnblogs.com/wodebudong/articles/7976474.html        1.2 实现 
MVCC 使用时间戳（TS）、递增的事务 ID（T）实现事务一致性。
MVCC 通过维护多版本数据，保证一个读事务永远不会被阻塞。对象 P 维护有多个版本，每个版本会有一个读时间戳（Read TimeStamp, RTS）和 写时间戳（Write TimeStamp, WTS），事务 Ti 读对象 P 的最新版本，该版本早于事务 Ti 的读时间戳 RTS(Ti)。
事务 Ti 要对 P 执行写操作，如果有其他事务 Tk 同时对 P 操作，则 RTS(Ti）必须要早于 RTS(Tk)，即有 RTS(Ti) < RTS(Tk)，这样对 Ti 对 P 的写操作才能完成。一般地，如果其他事务拥有 P 的一个更早的读时间戳的情况下，写操作是不能完成的。打个比方就是在存储前面有一道线，只有等你前面的人的完成了他们的事务，你的修改事务才可以提交完成。
重复说一下：每个对象 P 有一个时间戳 TS，如果事务 Ti 想要对 P 执行写操作，（写要先读）事务的读时间戳是 RTS(Ti)，如果有其他事务拥有一个比较早的时间戳，有 TS(P) < RTS(Ti)，这时事务 Ti 会退出并重新开始。否则，事务 Ti 创建一个 P 的新版本，并设置新版本 P 的时间戳，似的 TS = TS(Ti)。
MVCC 系统明显的缺点是会存储多个版本数据的冗余开销。但同时，读操作永不会被阻塞，这对那些以读操作为主的数据库来说非常重要。MVCC 实现了真的快照隔离（snapshot isolation），然后其他的并发控制方法要么是不完整的快照隔离方式，要么需要较高的性能损耗。
Wikipedia 中的内容有点繁琐，简单地，上面的描述，阐明了在同一数据版本下写操作的限制，已经通过多版本实现快照隔离的优越性。
1.3 示例
TimeObject1Object2
0 "Foo" by T0 "Bar" by T0 
1 "Hello" by T1  
Time=1的时候数据库的状态如上：
T0 写 Object1 为 "Foo"，写 Object2 为 "Bar"；之后 T1 写 Object1 为 "Hello"，保留 Object2 为原始值。 Object1 的新值将取代 Time=0 时刻的旧值，并提供给 T1提交之后的发生的所有事务。Object1的版本号为0的旧数据会被 GC 掉。
如果有一个长事务 T2，在 T1之后对 Object1和 Object2 进行读操作，同时并行地，有事务 T3 做更新：删除 Object2、增加 Object3="Foo-Bar"，在 Time=2 数据的状态如下所示：
TimeObject1Object2Object3
0 "Foo" by T0 "Bar" by T0  
1 "Hello" by T1   
2  (delete)by T3 "Foo-Bar" by T3 
在 Time=2 Object2有一个新版本：标记删除，同时增加了新对象 Object3 。T2 和 T3 并发执行，T2 看到的是数据在 Time=2且 T3提交前的版本，这样 T2读到了 Object2="Bar""且Object1="Hello"。
以上就是 MVCC 在不加锁的情况下实现的快照隔离的读的原理。
1.4 历史
最早于1978年，论文『Naming and Synchronization in a Decentralized Computer System』清晰地介绍了 MVCC，这是公认关于 MVCC 最早的工作。
在1981年，论文『Concurrency Control in Distributed Database System』介绍MVCC的一些细节。
目前支持 MVCC 的数据库，包括 DB2、Oracle、Sybase、SQL Server、MySQL、PG 等所有主流数据库，以及 HBase、Couchbase、Berkeley DB 等 NoSQL 数据库   https://www.cnblogs.com/YFYkuner/p/5178684.html2019-02-15 星期五 下午 21:14:00
2019-02-15 21:14:01.052[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [kf0O_a04433116]"}
2019-02-15 21:14:01.052[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [kf0O_a04433116]"}
2019-02-15 21:14:30.792[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  96  【深圳】【今日头条深圳研发中心】这真的是一封很认真的招聘贴~~~
liuyaqiu_150 · 3月之前 · 1595 次点击
我们是谁？ Developing a company as a product 是我们的理念 公司是我们团队的产品，员工是我们的用户 我们的工作是打造强大的效率工具和系统，支撑和推动公司更快更好地发展 业务范围涉及企业沟通工具、在线文档、共享日历、人力资源系统等 未来我们会推向市场，帮助更多优秀企业成长 甚至推动全球企业办公模式的变革
我们希望你来， 但我们希望吸引你来的不是免费的咖啡、漂亮的办公室和精美的下午茶 我们希望你和我们一样，最看重的是：『和优秀的人，做有挑战的事』 我们需要一群有才华、有志向的产品、技术、设计人才 能够像今日头条成立之初一样，从零开始打造一个团队
目前效率工程团队已经有数百人的规模 我们的管理理念是 【和优秀的人做有挑战的事，保持简单灵活的机制。提高透明度和信息分享效率，基于愿景目标自我驱动】 我们需要大量的leader、前后端高级工程师、客户端工程师、产品经理和UI设计师 如果你认同我们的价值观 如果你也期望加入这个推动字节跳动高速发展的团队 请和我们联系：liuyaqiu@bytedance.com
需求岗位： 服务端 /后台开发工程师 前端开发工程师 移动端（ Android 、 iOS ）开发工程师 产品经理 UI设计师
工作经验： 2 年以上
工作地点：深圳市南山区南海大道 2163 号来福士广场 15 层
简历投递邮箱：liuyaqiu@bytedance.com2019-02-15 星期五 下午 21:14:30
2019-02-15 21:14:30.792[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:14:30.792[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  96  【深圳】【今日头条深圳研发中心】这真的是一封很认真的招聘贴~~~
liuyaqiu_150 · 3月之前 · 1595 次点击
我们是谁？ Developing a company as a product 是我们的理念 公司是我们团队的产品，员工是我们的用户 我们的工作是打造强大的效率工具和系统，支撑和推动公司更快更好地发展 业务范围涉及企业沟通工具、在线文档、共享日历、人力资源系统等 未来我们会推向市场，帮助更多优秀企业成长 甚至推动全球企业办公模式的变革
我们希望你来， 但我们希望吸引你来的不是免费的咖啡、漂亮的办公室和精美的下午茶 我们希望你和我们一样，最看重的是：『和优秀的人，做有挑战的事』 我们需要一群有才华、有志向的产品、技术、设计人才 能够像今日头条成立之初一样，从零开始打造一个团队
目前效率工程团队已经有数百人的规模 我们的管理理念是 【和优秀的人做有挑战的事，保持简单灵活的机制。提高透明度和信息分享效率，基于愿景目标自我驱动】 我们需要大量的leader、前后端高级工程师、客户端工程师、产品经理和UI设计师 如果你认同我们的价值观 如果你也期望加入这个推动字节跳动高速发展的团队 请和我们联系：liuyaqiu@bytedance.com
需求岗位： 服务端 /后台开发工程师 前端开发工程师 移动端（ Android 、 iOS ）开发工程师 产品经理 UI设计师
工作经验： 2 年以上
工作地点：深圳市南山区南海大道 2163 号来福士广场 15 层
简历投递邮箱：liuyaqiu@bytedance.com2019-02-15 星期五 下午 21:14:30
2019-02-15 21:14:31.032[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [CWP1nA04734106]"}
2019-02-15 21:14:31.032[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [CWP1nA04734106]"}
2019-02-15 21:15:00.786[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  236 前言
此次面试是电话面试，35分钟，面试官态度很好，但是还是jj了。
正文
1.说一下你们的项目。
2.feign与ribbon的区别
3.设计一个从选择电影，影厅，场次，下单整个流程中涉及到的数据库表有哪些。
4.说一下你学过jvm后对你对代码书写和高效性体现在哪？
5.拆分微服务原则是什么。
6.NIO和BIO。
7.Netty用的啥实现。
8.面对高并发这些系统，利用中间件解决，你知道性能优化手段有哪些。
9.抢票系统，50张票并发抢怎么弄。
10.独立引入ribbitmq和redis你踩过的坑。
11.nginx和ribbon的区别。2019-02-15 星期五 下午 21:15:00
2019-02-15 21:15:00.787[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:15:00.788[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  236 前言
此次面试是电话面试，35分钟，面试官态度很好，但是还是jj了。
正文
1.说一下你们的项目。
2.feign与ribbon的区别
3.设计一个从选择电影，影厅，场次，下单整个流程中涉及到的数据库表有哪些。
4.说一下你学过jvm后对你对代码书写和高效性体现在哪？
5.拆分微服务原则是什么。
6.NIO和BIO。
7.Netty用的啥实现。
8.面对高并发这些系统，利用中间件解决，你知道性能优化手段有哪些。
9.抢票系统，50张票并发抢怎么弄。
10.独立引入ribbitmq和redis你踩过的坑。
11.nginx和ribbon的区别。2019-02-15 星期五 下午 21:15:00
2019-02-15 21:15:01.091[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [I2AOdA05033924]"}
2019-02-15 21:15:01.091[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [I2AOdA05033924]"}
2019-02-15 21:15:30.786[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  311 redis 一主二从三哨兵   https://www.cnblogs.com/cheyunhua/p/7940458.html   redis2019-02-15 星期五 下午 21:15:30
2019-02-15 21:15:30.786[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:15:30.786[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  311 redis 一主二从三哨兵   https://www.cnblogs.com/cheyunhua/p/7940458.html   redis2019-02-15 星期五 下午 21:15:30
2019-02-15 21:15:31.056[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [a59gBa0533shb1]"}
2019-02-15 21:15:31.056[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [a59gBa0533shb1]"}
2019-02-15 21:16:00.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  55mybatis中的namespace有什么作用你这样来记忆，mapper文件跟dao接口是一一对应的，dao接口完整名对应namespace，dao的方法名对应sql中的id，就行了

mybatis 中mapper 的namespace有什么用 5 我自己定义的一个sql语句配置 可是我不懂这里的namespace有什么用 SELECT t.* FROM T_article t WHERE t.flag = '1' ORDER BY t.createtime D... 展开 lanmo970 | 浏览 23220 次 推荐于2016-03-01 17:04:57 最佳答案 楼主： 在mybatis中，映射文件中的namespace是用于绑定Dao接口的，即面向接口编程。 当你的namespace绑定接口后，你可以不用写接口实现类，mybatis会通过该绑定自动 帮你找到对应要执行的SQL语句，如下： 假设定义了IArticeDAO接口 public interface IArticleDAO { List selectAllArticle(); } 对于映射文件如下： SELECT t.* FROM T_article t WHERE t.flag = '1' ORDER BY t.createtime DESC 请注意接口中的方法与映射文件中的SQL语句的ID一一对应 。 则在代码中可以直接使用IArticeDAO面向接口编程而不需要再编写实现类。 有问题欢迎提问，满意请采纳，谢谢！2019-02-15 星期五 下午 21:16:00
2019-02-15 21:16:00.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:16:00.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  55mybatis中的namespace有什么作用你这样来记忆，mapper文件跟dao接口是一一对应的，dao接口完整名对应namespace，dao的方法名对应sql中的id，就行了

mybatis 中mapper 的namespace有什么用 5 我自己定义的一个sql语句配置 可是我不懂这里的namespace有什么用 SELECT t.* FROM T_article t WHERE t.flag = '1' ORDER BY t.createtime D... 展开 lanmo970 | 浏览 23220 次 推荐于2016-03-01 17:04:57 最佳答案 楼主： 在mybatis中，映射文件中的namespace是用于绑定Dao接口的，即面向接口编程。 当你的namespace绑定接口后，你可以不用写接口实现类，mybatis会通过该绑定自动 帮你找到对应要执行的SQL语句，如下： 假设定义了IArticeDAO接口 public interface IArticleDAO { List selectAllArticle(); } 对于映射文件如下： SELECT t.* FROM T_article t WHERE t.flag = '1' ORDER BY t.createtime DESC 请注意接口中的方法与映射文件中的SQL语句的ID一一对应 。 则在代码中可以直接使用IArticeDAO面向接口编程而不需要再编写实现类。 有问题欢迎提问，满意请采纳，谢谢！2019-02-15 星期五 下午 21:16:00
2019-02-15 21:16:01.066[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [Oh8nka05633955]"}
2019-02-15 21:16:01.066[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [Oh8nka05633955]"}
2019-02-15 21:16:30.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  187 （2）Reids的特点

Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。
Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。
Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。2019-02-15 星期五 下午 21:16:30
2019-02-15 21:16:30.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:16:30.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  187 （2）Reids的特点

Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。
Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。
Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。2019-02-15 星期五 下午 21:16:30
2019-02-15 21:16:31.096[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [WAVKJA05934123]"}
2019-02-15 21:16:31.096[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [WAVKJA05934123]"}
2019-02-15 21:17:00.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  142  MySQL经典面试题
1、MySQL的复制原理以及流程

(1)、复制基本原理流程

1. 主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；
2. 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；
3. 从：sql执行线程——执行relay log中的语句；

2019-02-15 星期五 下午 21:17:00
2019-02-15 21:17:00.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:17:00.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  142  MySQL经典面试题
1、MySQL的复制原理以及流程

(1)、复制基本原理流程

1. 主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；
2. 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；
3. 从：sql执行线程——执行relay log中的语句；

2019-02-15 星期五 下午 21:17:00
2019-02-15 21:17:01.096[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [sSyjTa0623shc1]"}
2019-02-15 21:17:01.096[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [sSyjTa0623shc1]"}
2019-02-15 21:17:30.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3022019-02-15 星期五 下午 21:17:30
2019-02-15 21:17:30.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:17:30.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3022019-02-15 星期五 下午 21:17:30
2019-02-15 21:17:31.076[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [m9ejrA06534121]"}
2019-02-15 21:17:31.076[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [m9ejrA06534121]"}
2019-02-15 21:18:00.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  149 (4)、2者select  count(*)哪个更快，为什么

myisam更快，因为myisam内部维护了一个计数器，可以直接调取。

(5)、2 者的索引的实现方式

都是 B+树索引， Innodb 是索引组织表， myisam 是堆表， 索引组织表和堆表的区别要熟悉

2019-02-15 星期五 下午 21:18:00
2019-02-15 21:18:00.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:18:00.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  149 (4)、2者select  count(*)哪个更快，为什么

myisam更快，因为myisam内部维护了一个计数器，可以直接调取。

(5)、2 者的索引的实现方式

都是 B+树索引， Innodb 是索引组织表， myisam 是堆表， 索引组织表和堆表的区别要熟悉

2019-02-15 星期五 下午 21:18:00
2019-02-15 21:18:01.096[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [PwRrUa06833954]"}
2019-02-15 21:18:01.096[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [PwRrUa06833954]"}
2019-02-15 21:18:30.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2482019-02-15 星期五 下午 21:18:30
2019-02-15 21:18:30.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:18:30.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2482019-02-15 星期五 下午 21:18:30
2019-02-15 21:18:31.216[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [vmotpA0714shc2]"}
2019-02-15 21:18:31.216[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [vmotpA0714shc2]"}
2019-02-15 21:19:00.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  142  MySQL经典面试题
1、MySQL的复制原理以及流程

(1)、复制基本原理流程

1. 主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；
2. 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；
3. 从：sql执行线程——执行relay log中的语句；

2019-02-15 星期五 下午 21:19:00
2019-02-15 21:19:00.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:19:00.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  142  MySQL经典面试题
1、MySQL的复制原理以及流程

(1)、复制基本原理流程

1. 主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；
2. 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；
3. 从：sql执行线程——执行relay log中的语句；

2019-02-15 星期五 下午 21:19:00
2019-02-15 21:19:01.096[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [zG3Z7a07433949]"}
2019-02-15 21:19:01.096[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [zG3Z7a07433949]"}
2019-02-15 21:19:30.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  232 在MySQL的众多存储引擎中，只有InnoDB支持事务，所有这里说的事务隔离级别指的是InnoDB下的事务隔离级别。
读未提交：一个事务可以读取到另一个事务未提交的修改。这会带来脏读、幻读、不可重复读问题。（基本没用）
读已提交：一个事务只能读取另一个事务已经提交的修改。其避免了脏读，但仍然存在不可重复读和幻读问题。
可重复读：同一个事务中多次读取相同的数据返回的结果是一样的。其避免了脏读和不可重复读问题，但幻读依然存在。
串行化：事务串行执行。避免了以上所有问题。
以上是SQL-92标准中定义的四种隔离级别。在MySQL中，默认的隔离级别是REPEATABLE-READ（可重复读），并且解决了幻读问题。简单的来说，mysql的默认隔离级别解决了脏读、幻读、不可重复读问题。
不可重复读重点在于update和delete，而幻读的重点在于insert。
在这里，我们只讨论可重复读。
你注意 mysql没有用表锁。而是用间隙锁解决了幻读的问题。2019-02-15 星期五 下午 21:19:30
2019-02-15 21:19:30.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:19:30.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  232 在MySQL的众多存储引擎中，只有InnoDB支持事务，所有这里说的事务隔离级别指的是InnoDB下的事务隔离级别。
读未提交：一个事务可以读取到另一个事务未提交的修改。这会带来脏读、幻读、不可重复读问题。（基本没用）
读已提交：一个事务只能读取另一个事务已经提交的修改。其避免了脏读，但仍然存在不可重复读和幻读问题。
可重复读：同一个事务中多次读取相同的数据返回的结果是一样的。其避免了脏读和不可重复读问题，但幻读依然存在。
串行化：事务串行执行。避免了以上所有问题。
以上是SQL-92标准中定义的四种隔离级别。在MySQL中，默认的隔离级别是REPEATABLE-READ（可重复读），并且解决了幻读问题。简单的来说，mysql的默认隔离级别解决了脏读、幻读、不可重复读问题。
不可重复读重点在于update和delete，而幻读的重点在于insert。
在这里，我们只讨论可重复读。
你注意 mysql没有用表锁。而是用间隙锁解决了幻读的问题。2019-02-15 星期五 下午 21:19:30
2019-02-15 21:19:31.106[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [OVJhja07733935]"}
2019-02-15 21:19:31.106[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [OVJhja07733935]"}
2019-02-15 21:20:00.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  162 18、请简洁地描述下 MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？

(1)、事物的4种隔离级别

读未提交(read uncommitted)
读已提交(read committed)
可重复读(repeatable read)
串行(serializable)

(2)、不同级别的现象

Read Uncommitted:可以读取其他 session 未提交的脏数据。
Read Committed:允许不可重复读取，但不允许脏读取。提交后，其他会话可以看到提交的数据。
Repeatable Read: 禁止不可重复读取和脏读取、以及幻读(innodb 独有)。
Serializable: 事务只能一个接着一个地执行，但不能并发执行。事务隔离级别最高。
不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差。

2019-02-15 星期五 下午 21:20:00
2019-02-15 21:20:00.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:20:00.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  162 18、请简洁地描述下 MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？

(1)、事物的4种隔离级别

读未提交(read uncommitted)
读已提交(read committed)
可重复读(repeatable read)
串行(serializable)

(2)、不同级别的现象

Read Uncommitted:可以读取其他 session 未提交的脏数据。
Read Committed:允许不可重复读取，但不允许脏读取。提交后，其他会话可以看到提交的数据。
Repeatable Read: 禁止不可重复读取和脏读取、以及幻读(innodb 独有)。
Serializable: 事务只能一个接着一个地执行，但不能并发执行。事务隔离级别最高。
不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差。

2019-02-15 星期五 下午 21:20:00
2019-02-15 21:20:01.096[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [b3IDpa08034125]"}
2019-02-15 21:20:01.096[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [b3IDpa08034125]"}
2019-02-15 21:20:30.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  218 介绍一下Spring的事物管理

    事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。

开发中为了避免这种情况一般都会进行事务管理。Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管 理，可以通过Spring的注入来完成此功能。spring提供了几个关于事务处理的类：

TransactionDefinition //事务属性定义

TranscationStatus //代表了当前的事务，可以提交，回滚。

PlatformTransactionManager这个是spring提供的用于管理事务的基础接口，其下有一个实现的抽象类 AbstractPlatformTransactionManager,我们使用的事务管理类例如 DataSourceTransactionManager等都是这个类的子类。

一般事务定义步骤：

 

    TransactionDefinition td =newTransactionDefinition();
    TransactionStatus ts = transactionManager.getTransaction(td);
    try{ 
        //do sth
        transactionManager.commit(ts);
    }catch(Exception e){
        transactionManager.rollback(ts);
    }

    spring提供的事务管理可以分为两类：编程式的和声明式的。编程式的，比较灵活，但是代码量大，存在重复的代码比较多；声明式的比编程式的更灵活。 2019-02-15 星期五 下午 21:20:30
2019-02-15 21:20:30.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:20:30.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  218 介绍一下Spring的事物管理

    事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。

开发中为了避免这种情况一般都会进行事务管理。Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管 理，可以通过Spring的注入来完成此功能。spring提供了几个关于事务处理的类：

TransactionDefinition //事务属性定义

TranscationStatus //代表了当前的事务，可以提交，回滚。

PlatformTransactionManager这个是spring提供的用于管理事务的基础接口，其下有一个实现的抽象类 AbstractPlatformTransactionManager,我们使用的事务管理类例如 DataSourceTransactionManager等都是这个类的子类。

一般事务定义步骤：

 

    TransactionDefinition td =newTransactionDefinition();
    TransactionStatus ts = transactionManager.getTransaction(td);
    try{ 
        //do sth
        transactionManager.commit(ts);
    }catch(Exception e){
        transactionManager.rollback(ts);
    }

    spring提供的事务管理可以分为两类：编程式的和声明式的。编程式的，比较灵活，但是代码量大，存在重复的代码比较多；声明式的比编程式的更灵活。 2019-02-15 星期五 下午 21:20:30
2019-02-15 21:20:31.076[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [3s6Uya08335508]"}
2019-02-15 21:20:31.076[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [3s6Uya08335508]"}
2019-02-15 21:21:00.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2242019-02-15 星期五 下午 21:21:00
2019-02-15 21:21:00.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:21:00.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2242019-02-15 星期五 下午 21:21:00
2019-02-15 21:21:01.086[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [Mhuvla08634125]"}
2019-02-15 21:21:01.086[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [Mhuvla08634125]"}
2019-02-15 21:21:30.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  139 也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。

第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。

同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：

第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。2019-02-15 星期五 下午 21:21:30
2019-02-15 21:21:30.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:21:30.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  139 也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。

第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。

同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：

第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。2019-02-15 星期五 下午 21:21:30
2019-02-15 21:21:31.086[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [X8.KLA08933955]"}
2019-02-15 21:21:31.086[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [X8.KLA08933955]"}
2019-02-15 21:22:00.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3332019-02-15 星期五 下午 21:22:00
2019-02-15 21:22:00.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:22:00.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3332019-02-15 星期五 下午 21:22:00
2019-02-15 21:22:01.036[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [1x2.ca09234119]"}
2019-02-15 21:22:01.036[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [1x2.ca09234119]"}
2019-02-15 21:22:30.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3352019-02-15 星期五 下午 21:22:30
2019-02-15 21:22:30.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:22:30.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3352019-02-15 星期五 下午 21:22:30
2019-02-15 21:22:31.076[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [i1EQCa09534104]"}
2019-02-15 21:22:31.076[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [i1EQCa09534104]"}
2019-02-15 21:23:00.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  7dubbo原理源码  
  https://www.cnblogs.com/gotodsp/p/6532856.html2019-02-15 星期五 下午 21:23:00
2019-02-15 21:23:00.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:23:00.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  7dubbo原理源码  
  https://www.cnblogs.com/gotodsp/p/6532856.html2019-02-15 星期五 下午 21:23:00
2019-02-15 21:23:00.996[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [LgKo0a09834116]"}
2019-02-15 21:23:00.996[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [LgKo0a09834116]"}
2019-02-15 21:23:30.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  12mysql优化：sql优化；索引优化，执行计划，配置参数优化2019-02-15 星期五 下午 21:23:30
2019-02-15 21:23:30.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:23:30.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  12mysql优化：sql优化；索引优化，执行计划，配置参数优化2019-02-15 星期五 下午 21:23:30
2019-02-15 21:23:31.006[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [7ObCta00134123]"}
2019-02-15 21:23:31.006[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [7ObCta00134123]"}
2019-02-15 21:24:00.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  325 Java多线程：线程安全和非线程安全的集合对象
一、概念：
    线程安全：就是当多线程访问时，采用了加锁的机制；即当一个线程访问该类的某个数据时，会对这个数据进行保护，其他线程不能对其访问，直到该线程读取完之后，其他线程才可以使用。防止出现数据不一致或者数据被污染的情况。
    线程不安全：就是不提供数据访问时的数据保护，多个线程能够同时操作某个数据，从而出现数据不一致或者数据污染的情况。
    对于线程不安全的问题，一般会使用synchronized关键字加锁同步控制。
    线程安全 工作原理： jvm中有一个main memory对象，每一个线程也有自己的working memory，一个线程对于一个变量variable进行操作的时候， 都需要在自己的working memory里创建一个copy,操作完之后再写入main memory。
    当多个线程操作同一个变量variable，就可能出现不可预知的结果。
    而用synchronized的关键是建立一个监控monitor，这个monitor可以是要修改的变量，也可以是其他自己认为合适的对象(方法)，然后通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完加载load到working memory 到 use && 指派assign 到 存储store 再到 main memory的过程。才会释放它得到的锁。这样就实现了所谓的线程安全。
二、线程安全(Thread-safe)的集合对象：
    Vector 线程安全：
    HashTable 线程安全：
    StringBuffer 线程安全：
三、非线程安全的集合对象：
    ArrayList ：
    LinkedList：
    HashMap：
    HashSet：
    TreeMap：
    TreeSet：
    StringBulider：2019-02-15 星期五 下午 21:24:00
2019-02-15 21:24:00.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:24:00.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  325 Java多线程：线程安全和非线程安全的集合对象
一、概念：
    线程安全：就是当多线程访问时，采用了加锁的机制；即当一个线程访问该类的某个数据时，会对这个数据进行保护，其他线程不能对其访问，直到该线程读取完之后，其他线程才可以使用。防止出现数据不一致或者数据被污染的情况。
    线程不安全：就是不提供数据访问时的数据保护，多个线程能够同时操作某个数据，从而出现数据不一致或者数据污染的情况。
    对于线程不安全的问题，一般会使用synchronized关键字加锁同步控制。
    线程安全 工作原理： jvm中有一个main memory对象，每一个线程也有自己的working memory，一个线程对于一个变量variable进行操作的时候， 都需要在自己的working memory里创建一个copy,操作完之后再写入main memory。
    当多个线程操作同一个变量variable，就可能出现不可预知的结果。
    而用synchronized的关键是建立一个监控monitor，这个monitor可以是要修改的变量，也可以是其他自己认为合适的对象(方法)，然后通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完加载load到working memory 到 use && 指派assign 到 存储store 再到 main memory的过程。才会释放它得到的锁。这样就实现了所谓的线程安全。
二、线程安全(Thread-safe)的集合对象：
    Vector 线程安全：
    HashTable 线程安全：
    StringBuffer 线程安全：
三、非线程安全的集合对象：
    ArrayList ：
    LinkedList：
    HashMap：
    HashSet：
    TreeMap：
    TreeSet：
    StringBulider：2019-02-15 星期五 下午 21:24:00
2019-02-15 21:24:01.076[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [QKLxRA00434121]"}
2019-02-15 21:24:01.076[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [QKLxRA00434121]"}
2019-02-15 21:24:30.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2242019-02-15 星期五 下午 21:24:30
2019-02-15 21:24:30.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:24:30.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2242019-02-15 星期五 下午 21:24:30
2019-02-15 21:24:31.046[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [u2smDA00733938]"}
2019-02-15 21:24:31.046[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [u2smDA00733938]"}
2019-02-15 21:25:00.796[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  70 String, StringBuffer和StringBuilder区别

String是字符串常量，final修饰：StringBuffer字符串变量(线程安全)；
StringBuilder 字符串变量(线程不安全)。
String和StringBuffer

String和StringBuffer主要区别是性能：String是不可变对象，每次对String类型进行操作都等同于产生了一个新的String对象，然后指向新的String对象。所以尽量不在对String进行大量的拼接操作，否则会产生很多临时对象，导致GC开始工作，影响系统性能。

StringBuffer是对对象本身操作，而不是产生新的对象，因此在有大量拼接的情况下，我们建议使用StringBuffer。

但是需要注意现在JVM会对String拼接做一定的优化：
String s=“This is only ”+”simple”+”test”会被虚拟机直接优化成String s=“This is only simple test”，此时就不存在拼接过程。2019-02-15 星期五 下午 21:25:00
2019-02-15 21:25:00.796[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:25:00.796[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  70 String, StringBuffer和StringBuilder区别

String是字符串常量，final修饰：StringBuffer字符串变量(线程安全)；
StringBuilder 字符串变量(线程不安全)。
String和StringBuffer

String和StringBuffer主要区别是性能：String是不可变对象，每次对String类型进行操作都等同于产生了一个新的String对象，然后指向新的String对象。所以尽量不在对String进行大量的拼接操作，否则会产生很多临时对象，导致GC开始工作，影响系统性能。

StringBuffer是对对象本身操作，而不是产生新的对象，因此在有大量拼接的情况下，我们建议使用StringBuffer。

但是需要注意现在JVM会对String拼接做一定的优化：
String s=“This is only ”+”simple”+”test”会被虚拟机直接优化成String s=“This is only simple test”，此时就不存在拼接过程。2019-02-15 星期五 下午 21:25:00
2019-02-15 21:25:01.036[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [q8ujnA01033950]"}
2019-02-15 21:25:01.036[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [q8ujnA01033950]"}
2019-02-15 21:25:30.800[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  172 10 、关于有丰富的线上恢复经验的

就问你现在线上数据量有多大，如果是 100G，你用 mysqldump 出来要多久，然后 mysql进去又要多久，如果互联网不允许延时的话，你又怎么做到 恢复单张表的时候保证 nagios不报警。如果有人说 mysqldump 出来 1 个小时就 ok 了，那么我就要问问他 db 服务器是
啥配置了，如果他说 mysql 进去 50 分钟搞定了，那么我也要问问他 db 机器啥配置了，如果是普通的吊丝 pc server，那么真实性，大家懂得。然后如果你用 xtrabackup 备份要多久，恢复要多久，大家都知道 copy-back 这一步要很久，那么你有没有办法对这一块优化。

2019-02-15 星期五 下午 21:25:30
2019-02-15 21:25:30.800[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:25:30.800[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  172 10 、关于有丰富的线上恢复经验的

就问你现在线上数据量有多大，如果是 100G，你用 mysqldump 出来要多久，然后 mysql进去又要多久，如果互联网不允许延时的话，你又怎么做到 恢复单张表的时候保证 nagios不报警。如果有人说 mysqldump 出来 1 个小时就 ok 了，那么我就要问问他 db 服务器是
啥配置了，如果他说 mysql 进去 50 分钟搞定了，那么我也要问问他 db 机器啥配置了，如果是普通的吊丝 pc server，那么真实性，大家懂得。然后如果你用 xtrabackup 备份要多久，恢复要多久，大家都知道 copy-back 这一步要很久，那么你有没有办法对这一块优化。

2019-02-15 星期五 下午 21:25:30
2019-02-15 21:25:31.101[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [Y_ZvHa01333936]"}
2019-02-15 21:25:31.102[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [Y_ZvHa01333936]"}
2019-02-15 21:26:00.802[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  266 try 里面爆出异常的地方开始后面的代码不会再执行了  只会执行 catch里面以及以后的2019-02-15 星期五 下午 21:26:00
2019-02-15 21:26:00.802[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:26:00.802[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  266 try 里面爆出异常的地方开始后面的代码不会再执行了  只会执行 catch里面以及以后的2019-02-15 星期五 下午 21:26:00
2019-02-15 21:26:01.062[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [iKgcCa01633934]"}
2019-02-15 21:26:01.062[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [iKgcCa01633934]"}
2019-02-15 21:26:30.798[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  252 
    MVCC Multi-Version Concurrency Control 多版本并发控制，MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。

中文名
    MVCC 
增    加
    并发性 

被称为
    多版本并发控制 
避    免
    使用锁 
保    存
    某个时间点上的数据快照 

目录

    1 产品简介
    2 说明
    3 比锁定的优势
    4 GBase8的特性

产品简介
大多数的MySQL事务型存储引擎，如InnoDB，Falcon以及PBXT都在使用一种简单的行锁机制。事实上，他们都和另外一种用来增加并发性的被称为“多版本并发控制（MVCC）”的机制来一起使用。MVCC不只使用在MySQL中，Oracle、PostgreSQL，以及其他一些数据库系统也同样使用它。
你可将MVCC看成行级别锁的一种妥协，它在许多情况下避免了使用锁，同时可以提供更小的开销。根据实现的不同，它可以允许非阻塞式读，在写操作进行时只锁定必要的记录。
MVCC会保存某个时间点上的数据快照。这意味着事务可以看到一个一致的数据视图，不管他们需要跑多久。这同时也意味着不同的事务在同一个时间点看到的同一个表的数据可能是不同的。如果你从来没有过这种体验的话，可能理解起来比较抽象，但是随着慢慢地熟悉这种理解将会很容易。
各个存储引擎对于MVCC的实现各不相同。这些不同中的一些包括乐观和悲观并发控制。我们将通过一个简化的InnoDB版本的行为来展示MVCC工作的一个侧面。
InnoDB：通过为每一行记录添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。但是InnoDB并不存储这些事件发生时的实际时间，相反它只存储这些事件发生时的系统版本号。这是一个随着事务的创建而不断增长的数字。每个事务在事务开始时会记录它自己的系统版本号。每个查询必须去检查每行数据的版本号与事务的版本号是否相同。让我们来看看当隔离级别是REPEATABLE READ时这种策略是如何应用到特定的操作的：
SELECT InnoDB必须每行数据来保证它符合两个条件：
1、InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。
2、这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除。这里的不是真正的删除数据，而是标志出来的删除。真正意义的删除是在commit的时候。
符合这两个条件的行可能会被当作查询结果而返回。
INSERT：InnoDB为这个新行记录当前的系统版本号。
DELETE：InnoDB将当前的系统版本号设置为这一行的删除ID。
UPDATE：InnoDB会写一个这行数据的新拷贝，这个拷贝的版本为当前的系统版本号。它同时也会将这个版本号写到旧行的删除版本里。
这种额外的记录所带来的结果就是对于大多数查询来说根本就不需要获得一个锁。他们只是简单地以最快的速度来读取数据，确保只选择符合条件的行。这个方案的缺点在于存储引擎必须为每一行存储更多的数据，做更多的检查工作，处理更多的善后操作。
MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下。READ UNCOMMITED不是MVCC兼容的，因为查询不能找到适合他们事务版本的行版本；它们每次都只能读到最新的版本。SERIABLABLE也不与MVCC兼容，因为读操作会锁定他们返回的每一行数据 [1]  。2019-02-15 星期五 下午 21:26:30
2019-02-15 21:26:30.798[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:26:30.800[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  252 
    MVCC Multi-Version Concurrency Control 多版本并发控制，MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。

中文名
    MVCC 
增    加
    并发性 

被称为
    多版本并发控制 
避    免
    使用锁 
保    存
    某个时间点上的数据快照 

目录

    1 产品简介
    2 说明
    3 比锁定的优势
    4 GBase8的特性

产品简介
大多数的MySQL事务型存储引擎，如InnoDB，Falcon以及PBXT都在使用一种简单的行锁机制。事实上，他们都和另外一种用来增加并发性的被称为“多版本并发控制（MVCC）”的机制来一起使用。MVCC不只使用在MySQL中，Oracle、PostgreSQL，以及其他一些数据库系统也同样使用它。
你可将MVCC看成行级别锁的一种妥协，它在许多情况下避免了使用锁，同时可以提供更小的开销。根据实现的不同，它可以允许非阻塞式读，在写操作进行时只锁定必要的记录。
MVCC会保存某个时间点上的数据快照。这意味着事务可以看到一个一致的数据视图，不管他们需要跑多久。这同时也意味着不同的事务在同一个时间点看到的同一个表的数据可能是不同的。如果你从来没有过这种体验的话，可能理解起来比较抽象，但是随着慢慢地熟悉这种理解将会很容易。
各个存储引擎对于MVCC的实现各不相同。这些不同中的一些包括乐观和悲观并发控制。我们将通过一个简化的InnoDB版本的行为来展示MVCC工作的一个侧面。
InnoDB：通过为每一行记录添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。但是InnoDB并不存储这些事件发生时的实际时间，相反它只存储这些事件发生时的系统版本号。这是一个随着事务的创建而不断增长的数字。每个事务在事务开始时会记录它自己的系统版本号。每个查询必须去检查每行数据的版本号与事务的版本号是否相同。让我们来看看当隔离级别是REPEATABLE READ时这种策略是如何应用到特定的操作的：
SELECT InnoDB必须每行数据来保证它符合两个条件：
1、InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。
2、这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除。这里的不是真正的删除数据，而是标志出来的删除。真正意义的删除是在commit的时候。
符合这两个条件的行可能会被当作查询结果而返回。
INSERT：InnoDB为这个新行记录当前的系统版本号。
DELETE：InnoDB将当前的系统版本号设置为这一行的删除ID。
UPDATE：InnoDB会写一个这行数据的新拷贝，这个拷贝的版本为当前的系统版本号。它同时也会将这个版本号写到旧行的删除版本里。
这种额外的记录所带来的结果就是对于大多数查询来说根本就不需要获得一个锁。他们只是简单地以最快的速度来读取数据，确保只选择符合条件的行。这个方案的缺点在于存储引擎必须为每一行存储更多的数据，做更多的检查工作，处理更多的善后操作。
MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下。READ UNCOMMITED不是MVCC兼容的，因为查询不能找到适合他们事务版本的行版本；它们每次都只能读到最新的版本。SERIABLABLE也不与MVCC兼容，因为读操作会锁定他们返回的每一行数据 [1]  。2019-02-15 星期五 下午 21:26:30
2019-02-15 21:26:31.042[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [IsvL701938641]"}
2019-02-15 21:26:31.042[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [IsvL701938641]"}
2019-02-15 21:27:00.800[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  185 重入读写锁  这里重入有何含义   重入：此锁允许reader和writer按照 ReentrantLock 的样式重新获取读取锁或写入锁。在写入线程保持的所有写入锁都已经释放后，才允许重入reader使用读取锁。 重入 第二次进来  先进来发现资源锁住了，于是乎出去，等待锁释放再进来操作资源。2019-02-15 星期五 下午 21:27:00
2019-02-15 21:27:00.800[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:27:00.800[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  185 重入读写锁  这里重入有何含义   重入：此锁允许reader和writer按照 ReentrantLock 的样式重新获取读取锁或写入锁。在写入线程保持的所有写入锁都已经释放后，才允许重入reader使用读取锁。 重入 第二次进来  先进来发现资源锁住了，于是乎出去，等待锁释放再进来操作资源。2019-02-15 星期五 下午 21:27:00
2019-02-15 21:27:01.060[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [t02232066]"}
2019-02-15 21:27:01.060[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [t02232066]"}
2019-02-15 21:27:30.807[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  257  MVCC  这是读事务永远不会被阻塞的工具。从这篇文章看，读已提交应该叫做，读当前并发的其他事务提交之前的的旧版本数据来保证读事务不会被阻塞。 写事务遇到这种状况当然就被阻塞了。写事务里面会加行锁或者表锁的  如果没有索引，所以update会锁表，如果加了索引，就会锁行https://www.cnblogs.com/wodebudong/articles/7976474.html        1.2 实现 
MVCC 使用时间戳（TS）、递增的事务 ID（T）实现事务一致性。
MVCC 通过维护多版本数据，保证一个读事务永远不会被阻塞。对象 P 维护有多个版本，每个版本会有一个读时间戳（Read TimeStamp, RTS）和 写时间戳（Write TimeStamp, WTS），事务 Ti 读对象 P 的最新版本，该版本早于事务 Ti 的读时间戳 RTS(Ti)。
事务 Ti 要对 P 执行写操作，如果有其他事务 Tk 同时对 P 操作，则 RTS(Ti）必须要早于 RTS(Tk)，即有 RTS(Ti) < RTS(Tk)，这样对 Ti 对 P 的写操作才能完成。一般地，如果其他事务拥有 P 的一个更早的读时间戳的情况下，写操作是不能完成的。打个比方就是在存储前面有一道线，只有等你前面的人的完成了他们的事务，你的修改事务才可以提交完成。
重复说一下：每个对象 P 有一个时间戳 TS，如果事务 Ti 想要对 P 执行写操作，（写要先读）事务的读时间戳是 RTS(Ti)，如果有其他事务拥有一个比较早的时间戳，有 TS(P) < RTS(Ti)，这时事务 Ti 会退出并重新开始。否则，事务 Ti 创建一个 P 的新版本，并设置新版本 P 的时间戳，似的 TS = TS(Ti)。
MVCC 系统明显的缺点是会存储多个版本数据的冗余开销。但同时，读操作永不会被阻塞，这对那些以读操作为主的数据库来说非常重要。MVCC 实现了真的快照隔离（snapshot isolation），然后其他的并发控制方法要么是不完整的快照隔离方式，要么需要较高的性能损耗。
Wikipedia 中的内容有点繁琐，简单地，上面的描述，阐明了在同一数据版本下写操作的限制，已经通过多版本实现快照隔离的优越性。
1.3 示例
TimeObject1Object2
0 "Foo" by T0 "Bar" by T0 
1 "Hello" by T1  
Time=1的时候数据库的状态如上：
T0 写 Object1 为 "Foo"，写 Object2 为 "Bar"；之后 T1 写 Object1 为 "Hello"，保留 Object2 为原始值。 Object1 的新值将取代 Time=0 时刻的旧值，并提供给 T1提交之后的发生的所有事务。Object1的版本号为0的旧数据会被 GC 掉。
如果有一个长事务 T2，在 T1之后对 Object1和 Object2 进行读操作，同时并行地，有事务 T3 做更新：删除 Object2、增加 Object3="Foo-Bar"，在 Time=2 数据的状态如下所示：
TimeObject1Object2Object3
0 "Foo" by T0 "Bar" by T0  
1 "Hello" by T1   
2  (delete)by T3 "Foo-Bar" by T3 
在 Time=2 Object2有一个新版本：标记删除，同时增加了新对象 Object3 。T2 和 T3 并发执行，T2 看到的是数据在 Time=2且 T3提交前的版本，这样 T2读到了 Object2="Bar""且Object1="Hello"。
以上就是 MVCC 在不加锁的情况下实现的快照隔离的读的原理。
1.4 历史
最早于1978年，论文『Naming and Synchronization in a Decentralized Computer System』清晰地介绍了 MVCC，这是公认关于 MVCC 最早的工作。
在1981年，论文『Concurrency Control in Distributed Database System』介绍MVCC的一些细节。
目前支持 MVCC 的数据库，包括 DB2、Oracle、Sybase、SQL Server、MySQL、PG 等所有主流数据库，以及 HBase、Couchbase、Berkeley DB 等 NoSQL 数据库   https://www.cnblogs.com/YFYkuner/p/5178684.html2019-02-15 星期五 下午 21:27:30
2019-02-15 21:27:30.807[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:27:30.807[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  257  MVCC  这是读事务永远不会被阻塞的工具。从这篇文章看，读已提交应该叫做，读当前并发的其他事务提交之前的的旧版本数据来保证读事务不会被阻塞。 写事务遇到这种状况当然就被阻塞了。写事务里面会加行锁或者表锁的  如果没有索引，所以update会锁表，如果加了索引，就会锁行https://www.cnblogs.com/wodebudong/articles/7976474.html        1.2 实现 
MVCC 使用时间戳（TS）、递增的事务 ID（T）实现事务一致性。
MVCC 通过维护多版本数据，保证一个读事务永远不会被阻塞。对象 P 维护有多个版本，每个版本会有一个读时间戳（Read TimeStamp, RTS）和 写时间戳（Write TimeStamp, WTS），事务 Ti 读对象 P 的最新版本，该版本早于事务 Ti 的读时间戳 RTS(Ti)。
事务 Ti 要对 P 执行写操作，如果有其他事务 Tk 同时对 P 操作，则 RTS(Ti）必须要早于 RTS(Tk)，即有 RTS(Ti) < RTS(Tk)，这样对 Ti 对 P 的写操作才能完成。一般地，如果其他事务拥有 P 的一个更早的读时间戳的情况下，写操作是不能完成的。打个比方就是在存储前面有一道线，只有等你前面的人的完成了他们的事务，你的修改事务才可以提交完成。
重复说一下：每个对象 P 有一个时间戳 TS，如果事务 Ti 想要对 P 执行写操作，（写要先读）事务的读时间戳是 RTS(Ti)，如果有其他事务拥有一个比较早的时间戳，有 TS(P) < RTS(Ti)，这时事务 Ti 会退出并重新开始。否则，事务 Ti 创建一个 P 的新版本，并设置新版本 P 的时间戳，似的 TS = TS(Ti)。
MVCC 系统明显的缺点是会存储多个版本数据的冗余开销。但同时，读操作永不会被阻塞，这对那些以读操作为主的数据库来说非常重要。MVCC 实现了真的快照隔离（snapshot isolation），然后其他的并发控制方法要么是不完整的快照隔离方式，要么需要较高的性能损耗。
Wikipedia 中的内容有点繁琐，简单地，上面的描述，阐明了在同一数据版本下写操作的限制，已经通过多版本实现快照隔离的优越性。
1.3 示例
TimeObject1Object2
0 "Foo" by T0 "Bar" by T0 
1 "Hello" by T1  
Time=1的时候数据库的状态如上：
T0 写 Object1 为 "Foo"，写 Object2 为 "Bar"；之后 T1 写 Object1 为 "Hello"，保留 Object2 为原始值。 Object1 的新值将取代 Time=0 时刻的旧值，并提供给 T1提交之后的发生的所有事务。Object1的版本号为0的旧数据会被 GC 掉。
如果有一个长事务 T2，在 T1之后对 Object1和 Object2 进行读操作，同时并行地，有事务 T3 做更新：删除 Object2、增加 Object3="Foo-Bar"，在 Time=2 数据的状态如下所示：
TimeObject1Object2Object3
0 "Foo" by T0 "Bar" by T0  
1 "Hello" by T1   
2  (delete)by T3 "Foo-Bar" by T3 
在 Time=2 Object2有一个新版本：标记删除，同时增加了新对象 Object3 。T2 和 T3 并发执行，T2 看到的是数据在 Time=2且 T3提交前的版本，这样 T2读到了 Object2="Bar""且Object1="Hello"。
以上就是 MVCC 在不加锁的情况下实现的快照隔离的读的原理。
1.4 历史
最早于1978年，论文『Naming and Synchronization in a Decentralized Computer System』清晰地介绍了 MVCC，这是公认关于 MVCC 最早的工作。
在1981年，论文『Concurrency Control in Distributed Database System』介绍MVCC的一些细节。
目前支持 MVCC 的数据库，包括 DB2、Oracle、Sybase、SQL Server、MySQL、PG 等所有主流数据库，以及 HBase、Couchbase、Berkeley DB 等 NoSQL 数据库   https://www.cnblogs.com/YFYkuner/p/5178684.html2019-02-15 星期五 下午 21:27:30
2019-02-15 21:27:31.087[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [3GK02538630]"}
2019-02-15 21:27:31.087[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [3GK02538630]"}
2019-02-15 21:28:00.800[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  120 
并发编程的目的是为了让程序运行得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行。在进行并发编程时，
如果希望通过多线程执行任务让程序运行得更快，会面临非常多的挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题，
本章会介绍几种并发编程的挑战以及解决方案。

对于多核CPU，多线程才起优化作用2019-02-15 星期五 下午 21:28:00
2019-02-15 21:28:00.800[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:28:00.800[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  120 
并发编程的目的是为了让程序运行得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行。在进行并发编程时，
如果希望通过多线程执行任务让程序运行得更快，会面临非常多的挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题，
本章会介绍几种并发编程的挑战以及解决方案。

对于多核CPU，多线程才起优化作用2019-02-15 星期五 下午 21:28:00
2019-02-15 21:28:01.070[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [yEpWFa02833938]"}
2019-02-15 21:28:01.070[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [yEpWFa02833938]"}
2019-02-15 21:28:30.800[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  304 接口设计原则     高内聚 低耦合
好的接口应当满足设计模式六大原则, 很多设计模式, 框架都是基于高内聚低耦合这个出发点的.
1单一职责原则: 一个类只负责一个功能领域中的相应职责.
2开闭原则: 一个软件实体应当对扩展开放，对修改关闭.
3里氏代换原则: 所有引用基类（父类）的地方必须能透明地使用其子类的对象.
4依赖倒转原则: 抽象不应该依赖于细节, 细节应当依赖于抽象. 换言之, 要针对接口编程, 而不是针对实现编程.
5接口隔离原则: 使用多个专门的接口, 而不使用单一的总接口, 即客户端不应该依赖那些它不需要的接口.
6迪米特法则: 一个软件实体应当尽可能少地与其他实体发生相互作用, 例如外观模式, 对外暴露统一接口.2019-02-15 星期五 下午 21:28:30
2019-02-15 21:28:30.800[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:28:30.800[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  304 接口设计原则     高内聚 低耦合
好的接口应当满足设计模式六大原则, 很多设计模式, 框架都是基于高内聚低耦合这个出发点的.
1单一职责原则: 一个类只负责一个功能领域中的相应职责.
2开闭原则: 一个软件实体应当对扩展开放，对修改关闭.
3里氏代换原则: 所有引用基类（父类）的地方必须能透明地使用其子类的对象.
4依赖倒转原则: 抽象不应该依赖于细节, 细节应当依赖于抽象. 换言之, 要针对接口编程, 而不是针对实现编程.
5接口隔离原则: 使用多个专门的接口, 而不使用单一的总接口, 即客户端不应该依赖那些它不需要的接口.
6迪米特法则: 一个软件实体应当尽可能少地与其他实体发生相互作用, 例如外观模式, 对外暴露统一接口.2019-02-15 星期五 下午 21:28:30
2019-02-15 21:28:31.060[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [vAZL2a03133946]"}
2019-02-15 21:28:31.060[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [vAZL2a03133946]"}
2019-02-15 21:29:00.802[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  202 （3）、队列

Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。

如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。2019-02-15 星期五 下午 21:29:00
2019-02-15 21:29:00.802[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:29:00.802[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  202 （3）、队列

Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。

如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。2019-02-15 星期五 下午 21:29:00
2019-02-15 21:29:01.072[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [0x2xKA03433949]"}
2019-02-15 21:29:01.072[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [0x2xKA03433949]"}
2019-02-15 21:29:30.802[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  60详细描述：
项目介绍：
加拿大BMO银行信用卡运营管理，该项目完成该银行信用卡消费记录测试数据的导入，信用卡消费记录的查询。
工作职责：
1.运用SAX解析XML数据文档，完成测试数据导入，并验证导入数据正确性；
2.运用Java Web（Hibernate，Struts，Spring）技术完成信用卡消费记录的查询；
3.完成优化查询性能，改善java，SQL代码，存储过程等提升数据库性能的工作。

项目介绍：
香港汇丰银行理财产品开发，完成汇丰银行理财产品的第一期开发，实现客户投资前向客户演示保险，基金等理财产品的购买，收益获取的演示功能。
工作职责：
主要负责客户需求分析，代码实现以及单元测试，文档编写，完成理财演示功能中收益预估。主要技术：Hibernate3，struts2，Spring3，webService。2019-02-15 星期五 下午 21:29:30
2019-02-15 21:29:30.802[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:29:30.802[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  60详细描述：
项目介绍：
加拿大BMO银行信用卡运营管理，该项目完成该银行信用卡消费记录测试数据的导入，信用卡消费记录的查询。
工作职责：
1.运用SAX解析XML数据文档，完成测试数据导入，并验证导入数据正确性；
2.运用Java Web（Hibernate，Struts，Spring）技术完成信用卡消费记录的查询；
3.完成优化查询性能，改善java，SQL代码，存储过程等提升数据库性能的工作。

项目介绍：
香港汇丰银行理财产品开发，完成汇丰银行理财产品的第一期开发，实现客户投资前向客户演示保险，基金等理财产品的购买，收益获取的演示功能。
工作职责：
主要负责客户需求分析，代码实现以及单元测试，文档编写，完成理财演示功能中收益预估。主要技术：Hibernate3，struts2，Spring3，webService。2019-02-15 星期五 下午 21:29:30
2019-02-15 21:29:31.362[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [gAQChA03745508]"}
2019-02-15 21:29:31.362[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [gAQChA03745508]"}
2019-02-15 21:30:00.804[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  87     @RequestMapping(value = "/showCodes", method = RequestMethod.POST)
    @ResponseBody
    public Object showCodes(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        Map<String, String> map = new HashMap<String, String>();
        map.put("code1", apiCode900500RetNo);
        map.put("code2", apiCode900510RetNo);
        // OutputStream out = resp.getOutputStream();
        // out.write(("{\"code2\":" + apiCode900510RetNo + ",\"code1\":" + apiCode900500RetNo + "}").getBytes());
        // out.flush();
        // out.close();
        return map;
    }    这两种传值给前端的方法是等效的2019-02-15 星期五 下午 21:30:00
2019-02-15 21:30:00.804[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:30:00.804[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  87     @RequestMapping(value = "/showCodes", method = RequestMethod.POST)
    @ResponseBody
    public Object showCodes(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        Map<String, String> map = new HashMap<String, String>();
        map.put("code1", apiCode900500RetNo);
        map.put("code2", apiCode900510RetNo);
        // OutputStream out = resp.getOutputStream();
        // out.write(("{\"code2\":" + apiCode900510RetNo + ",\"code1\":" + apiCode900500RetNo + "}").getBytes());
        // out.flush();
        // out.close();
        return map;
    }    这两种传值给前端的方法是等效的2019-02-15 星期五 下午 21:30:00
2019-02-15 21:30:01.124[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [s5uvsa04034124]"}
2019-02-15 21:30:01.124[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [s5uvsa04034124]"}
2019-02-15 21:30:30.804[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  256 注意看 当你ll 的时候 linux 界面前方会出现-xrwxrwxwr  这种东西表示什么含义 drwxr-xr-x 2 root root 4096 06-29 14:30 Test 分段解释
d: 这个应该是目录吧 然后2 就是如果是文件夹表示子文件夹数个数. 文件硬链接数或目录子目录数  注意这里的或字
如果一个文件不是目录那么这一字段表示,这个文件所具有的硬链接数,即这个文件总共有多少个文件名.
rwxr-xr-x 这里是三段分开解释.r表示可读W表示可写x表示运行
rwx 表示文件所有者的权限
r-x 表示文件所有者所在组的权限
r-x 表示其他人的权限
第一个 root 用户
第二个 root 用户组
4096 是文件大小
06-29 14:30 是创建时间  不对 是最后更新时间吧 
test 文件名  2019-02-15 星期五 下午 21:30:30
2019-02-15 21:30:30.804[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:30:30.804[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  256 注意看 当你ll 的时候 linux 界面前方会出现-xrwxrwxwr  这种东西表示什么含义 drwxr-xr-x 2 root root 4096 06-29 14:30 Test 分段解释
d: 这个应该是目录吧 然后2 就是如果是文件夹表示子文件夹数个数. 文件硬链接数或目录子目录数  注意这里的或字
如果一个文件不是目录那么这一字段表示,这个文件所具有的硬链接数,即这个文件总共有多少个文件名.
rwxr-xr-x 这里是三段分开解释.r表示可读W表示可写x表示运行
rwx 表示文件所有者的权限
r-x 表示文件所有者所在组的权限
r-x 表示其他人的权限
第一个 root 用户
第二个 root 用户组
4096 是文件大小
06-29 14:30 是创建时间  不对 是最后更新时间吧 
test 文件名  2019-02-15 星期五 下午 21:30:30
2019-02-15 21:30:31.074[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [FqQ6Ca04334126]"}
2019-02-15 21:30:31.074[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [FqQ6Ca04334126]"}
2019-02-15 21:31:00.805[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  94 什么是乐观锁和悲观锁
乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。
悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。乐观锁是可以让你读，但是你先取版本号，update的时候版本号对不上,update语句后面的条件不满足，不让你update,这就是乐观锁；悲观锁，让你先取锁，拿到锁再来读，没拿到，读都不让你读，更不用说写了2019-02-15 星期五 下午 21:31:00
2019-02-15 21:31:00.805[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:31:00.805[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  94 什么是乐观锁和悲观锁
乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。
悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。乐观锁是可以让你读，但是你先取版本号，update的时候版本号对不上,update语句后面的条件不满足，不让你update,这就是乐观锁；悲观锁，让你先取锁，拿到锁再来读，没拿到，读都不让你读，更不用说写了2019-02-15 星期五 下午 21:31:00
2019-02-15 21:31:01.135[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [LvtwCA04638653]"}
2019-02-15 21:31:01.135[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [LvtwCA04638653]"}
2019-02-15 21:31:30.807[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  341 JVM结构原理、GC工作机制详解

答：具体参照：JVM结构、GC工作机制详解     ，说到GC，记住两点：1、GC是负责回收所有无任何引用对象的内存空间。 注意:垃圾回收回收的是无任何引用的对象占据的内存空间而不是对象本身，2、GC回收机制的两种算法，a、引用计数法  b、可达性分析算法（  这里的可达性，大家可以看基础2 Java对象的什么周期），至于更详细的GC算法介绍，大家可以参考：Java GC机制算法2019-02-15 星期五 下午 21:31:30
2019-02-15 21:31:30.807[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:31:30.807[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  341 JVM结构原理、GC工作机制详解

答：具体参照：JVM结构、GC工作机制详解     ，说到GC，记住两点：1、GC是负责回收所有无任何引用对象的内存空间。 注意:垃圾回收回收的是无任何引用的对象占据的内存空间而不是对象本身，2、GC回收机制的两种算法，a、引用计数法  b、可达性分析算法（  这里的可达性，大家可以看基础2 Java对象的什么周期），至于更详细的GC算法介绍，大家可以参考：Java GC机制算法2019-02-15 星期五 下午 21:31:30
2019-02-15 21:31:31.097[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [1ioSSA04934123]"}
2019-02-15 21:31:31.097[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [1ioSSA04934123]"}
2019-02-15 21:32:00.807[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  41适配器模式如何实现2019-02-15 星期五 下午 21:32:00
2019-02-15 21:32:00.807[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:32:00.807[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  41适配器模式如何实现2019-02-15 星期五 下午 21:32:00
2019-02-15 21:32:01.037[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [bjyK5a05234128]"}
2019-02-15 21:32:01.037[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [bjyK5a05234128]"}
2019-02-15 21:32:30.807[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3232019-02-15 星期五 下午 21:32:30
2019-02-15 21:32:30.807[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:32:30.807[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3232019-02-15 星期五 下午 21:32:30
2019-02-15 21:32:31.077[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [CsVMha05534105]"}
2019-02-15 21:32:31.077[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [CsVMha05534105]"}
2019-02-15 21:33:00.807[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3182019-02-15 星期五 下午 21:33:00
2019-02-15 21:33:00.807[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:33:00.807[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3182019-02-15 星期五 下午 21:33:00
2019-02-15 21:33:01.147[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [ZwawTa05833924]"}
2019-02-15 21:33:01.147[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [ZwawTa05833924]"}
2019-02-15 21:33:30.809[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  350 类加载的过程

a) 遇到一个新的类时，首先会到方法区去找class文件，如果没有找到就会去硬盘中找class文件，找到后会返回，将class文件加载到方法区中，在类加载的时候，静态成员变量会被分配到方法区的静态区域，非静态成员变量分配到非静态区域，然后开始给静态成员变量初始化，赋默认值，赋完默认值后，会根据静态成员变量书写的位置赋显示值，然后执行静态代码。当所有的静态代码执行完，类加载才算完成。
--------------------- 
作者：白衣染霜华丶 
来源：CSDN 
原文：https://blog.csdn.net/zhangcc233/article/details/77847104 
版权声明：本文为博主原创文章，转载请附上博文链接！2019-02-15 星期五 下午 21:33:30
2019-02-15 21:33:30.809[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:33:30.809[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  350 类加载的过程

a) 遇到一个新的类时，首先会到方法区去找class文件，如果没有找到就会去硬盘中找class文件，找到后会返回，将class文件加载到方法区中，在类加载的时候，静态成员变量会被分配到方法区的静态区域，非静态成员变量分配到非静态区域，然后开始给静态成员变量初始化，赋默认值，赋完默认值后，会根据静态成员变量书写的位置赋显示值，然后执行静态代码。当所有的静态代码执行完，类加载才算完成。
--------------------- 
作者：白衣染霜华丶 
来源：CSDN 
原文：https://blog.csdn.net/zhangcc233/article/details/77847104 
版权声明：本文为博主原创文章，转载请附上博文链接！2019-02-15 星期五 下午 21:33:30
2019-02-15 21:33:31.059[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [m6pCTA06134114]"}
2019-02-15 21:33:31.059[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [m6pCTA06134114]"}
2019-02-15 21:34:00.809[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  152 5、MySQL binlog的几种日志录入格式以及区别

(1)、 各种日志格式的涵义
复制代码

1.Statement：每一条会修改数据的sql都会记录在binlog中。
优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能 与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，
但是考虑到如果带条 件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所 产生的日志量会增加多少，以及带来的IO性能问题。)
缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,
像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).
使用以下函数的语句也无法被复制：
* LOAD_FILE()
* UUID()
* USER()
* FOUND_ROWS()
* SYSDATE() (除非启动时启用了 --sysdate-is-now 选项)
同时在INSERT ...SELECT 会产生比 RBR 更多的行级锁

2.Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。
优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下 每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题
缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比 如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，
由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。

3.Mixedlevel: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，
也就是在Statement和Row之间选择 一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。

复制代码

 (2)、适用场景

在一条 SQL 操作了多行数据时， statement 更节省空间， row 更占用空间。但是 row模式更可靠。

(3)、结合第一个问题，每一种日志格式在复制中的优劣

Statement 可能占用空间会相对小一些，传送到 slave 的时间可能也短，但是没有 row模式的可靠。 Row 模式在操作多行数据时更占用空间， 但是可靠。

2019-02-15 星期五 下午 21:34:00
2019-02-15 21:34:00.809[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:34:00.809[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  152 5、MySQL binlog的几种日志录入格式以及区别

(1)、 各种日志格式的涵义
复制代码

1.Statement：每一条会修改数据的sql都会记录在binlog中。
优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能 与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，
但是考虑到如果带条 件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所 产生的日志量会增加多少，以及带来的IO性能问题。)
缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,
像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).
使用以下函数的语句也无法被复制：
* LOAD_FILE()
* UUID()
* USER()
* FOUND_ROWS()
* SYSDATE() (除非启动时启用了 --sysdate-is-now 选项)
同时在INSERT ...SELECT 会产生比 RBR 更多的行级锁

2.Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。
优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下 每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题
缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比 如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，
由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。

3.Mixedlevel: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，
也就是在Statement和Row之间选择 一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。

复制代码

 (2)、适用场景

在一条 SQL 操作了多行数据时， statement 更节省空间， row 更占用空间。但是 row模式更可靠。

(3)、结合第一个问题，每一种日志格式在复制中的优劣

Statement 可能占用空间会相对小一些，传送到 slave 的时间可能也短，但是没有 row模式的可靠。 Row 模式在操作多行数据时更占用空间， 但是可靠。

2019-02-15 星期五 下午 21:34:00
2019-02-15 21:34:01.109[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [lnDsAa06434116]"}
2019-02-15 21:34:01.109[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [lnDsAa06434116]"}
2019-02-15 21:34:30.809[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  84  https://www.cnblogs.com/yjd_hycf_space/p/7730690.html     Linux常用命令大全（非常全！！！）
最近都在和Linux打交道，感觉还不错。我觉得Linux相比windows比较麻烦的就是很多东西都要用命令来控制，当然，这也是很多人喜欢linux的原因，比较短小但却功能强大。我将我了解到的命令列举一下，仅供大家参考：
系统信息 
arch 显示机器的处理器架构(1) 
uname -m 显示机器的处理器架构(2) 
uname -r 显示正在使用的内核版本 
dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) 
hdparm -i /dev/hda 罗列一个磁盘的架构特性 
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 
cat /proc/cpuinfo 显示CPU info的信息 
cat /proc/interrupts 显示中断 
cat /proc/meminfo 校验内存使用 
cat /proc/swaps 显示哪些swap被使用 
cat /proc/version 显示内核的版本 
cat /proc/net/dev 显示网络适配器及统计 
cat /proc/mounts 显示已加载的文件系统 
lspci -tv 罗列 PCI 设备 
lsusb -tv 显示 USB 设备 
date 显示系统日期 
cal 2007 显示2007年的日历表 
date 041217002007.00 设置日期和时间 - 月日时分年.秒 
clock -w 将时间修改保存到 BIOS 



关机 (系统的关机、重启以及登出 ) 
shutdown -h now 关闭系统(1) 
init 0 关闭系统(2) 
telinit 0 关闭系统(3) 
shutdown -h hours:minutes & 按预定时间关闭系统 
shutdown -c 取消按预定时间关闭系统 
shutdown -r now 重启(1) 
reboot 重启(2) 
logout 注销 2019-02-15 星期五 下午 21:34:30
2019-02-15 21:34:30.809[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:34:30.809[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  84  https://www.cnblogs.com/yjd_hycf_space/p/7730690.html     Linux常用命令大全（非常全！！！）
最近都在和Linux打交道，感觉还不错。我觉得Linux相比windows比较麻烦的就是很多东西都要用命令来控制，当然，这也是很多人喜欢linux的原因，比较短小但却功能强大。我将我了解到的命令列举一下，仅供大家参考：
系统信息 
arch 显示机器的处理器架构(1) 
uname -m 显示机器的处理器架构(2) 
uname -r 显示正在使用的内核版本 
dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) 
hdparm -i /dev/hda 罗列一个磁盘的架构特性 
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 
cat /proc/cpuinfo 显示CPU info的信息 
cat /proc/interrupts 显示中断 
cat /proc/meminfo 校验内存使用 
cat /proc/swaps 显示哪些swap被使用 
cat /proc/version 显示内核的版本 
cat /proc/net/dev 显示网络适配器及统计 
cat /proc/mounts 显示已加载的文件系统 
lspci -tv 罗列 PCI 设备 
lsusb -tv 显示 USB 设备 
date 显示系统日期 
cal 2007 显示2007年的日历表 
date 041217002007.00 设置日期和时间 - 月日时分年.秒 
clock -w 将时间修改保存到 BIOS 



关机 (系统的关机、重启以及登出 ) 
shutdown -h now 关闭系统(1) 
init 0 关闭系统(2) 
telinit 0 关闭系统(3) 
shutdown -h hours:minutes & 按预定时间关闭系统 
shutdown -c 取消按预定时间关闭系统 
shutdown -r now 重启(1) 
reboot 重启(2) 
logout 注销 2019-02-15 星期五 下午 21:34:30
2019-02-15 21:34:31.059[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [HWJJma06738630]"}
2019-02-15 21:34:31.059[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [HWJJma06738630]"}
2019-02-15 21:35:00.811[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  190 （5）Redis是单进程单线程的

redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销2019-02-15 星期五 下午 21:35:00
2019-02-15 21:35:00.811[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:35:00.811[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  190 （5）Redis是单进程单线程的

redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销2019-02-15 星期五 下午 21:35:00
2019-02-15 21:35:01.181[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [DlHrKA07033932]"}
2019-02-15 21:35:01.181[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [DlHrKA07033932]"}
2019-02-15 21:35:30.811[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  106 

这种搞法太粗犷了，每次都新建一个线程，太浪费了，迟早会崩掉的。 看ThreadB1

public class ThreadB {
	static int i = 1;
	public static void main(String[] args) {
		while(true) {
		 new Thread(new Runnable() {
			@Override
			public void run() {
				synchronized (ThreadA.class) {
					if(i<=0) {
						try {
							Thread.currentThread();
							Thread.sleep(200);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						System.out.println("生产者："+(++i));
					}
				}
			}
		}).start();
		 new Thread(new Runnable() {
				@Override
				public void run() {
					synchronized (ThreadA.class) {
						if(i>=1) {
							try {
								Thread.currentThread();
								Thread.sleep(200);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
							System.out.println("消费者："+(--i));
						}
					}
				}
			}).start();
		}
	}
}

2019-02-15 星期五 下午 21:35:30
2019-02-15 21:35:30.811[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:35:30.811[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  106 

这种搞法太粗犷了，每次都新建一个线程，太浪费了，迟早会崩掉的。 看ThreadB1

public class ThreadB {
	static int i = 1;
	public static void main(String[] args) {
		while(true) {
		 new Thread(new Runnable() {
			@Override
			public void run() {
				synchronized (ThreadA.class) {
					if(i<=0) {
						try {
							Thread.currentThread();
							Thread.sleep(200);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						System.out.println("生产者："+(++i));
					}
				}
			}
		}).start();
		 new Thread(new Runnable() {
				@Override
				public void run() {
					synchronized (ThreadA.class) {
						if(i>=1) {
							try {
								Thread.currentThread();
								Thread.sleep(200);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
							System.out.println("消费者："+(--i));
						}
					}
				}
			}).start();
		}
	}
}

2019-02-15 星期五 下午 21:35:30
2019-02-15 21:35:31.071[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [DzoMlA07333951]"}
2019-02-15 21:35:31.071[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [DzoMlA07333951]"}
2019-02-15 21:36:00.811[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3142019-02-15 星期五 下午 21:36:00
2019-02-15 21:36:00.811[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:36:00.811[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3142019-02-15 星期五 下午 21:36:00
2019-02-15 21:36:01.101[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [wW6n507633952]"}
2019-02-15 21:36:01.101[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [wW6n507633952]"}
2019-02-15 21:36:30.813[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2882019-02-15 星期五 下午 21:36:30
2019-02-15 21:36:30.813[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:36:30.813[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2882019-02-15 星期五 下午 21:36:30
2019-02-15 21:36:31.093[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [we0jvA07934100]"}
2019-02-15 21:36:31.093[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [we0jvA07934100]"}
2019-02-15 21:37:00.813[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  95 https://blog.csdn.net/u013305783/article/details/78563389   SpringBoot使用PageHelper进行分页   // 使用分页插件,核心代码就这一行
        PageHelper.startPage(page, perCount);
        List<AppNoticeDO> appNoticeDOList = appNoticeMapper.getAppNoticeDOList(appNoticeDTO);
        return new PageInfo<>(appNoticeDOList);2019-02-15 星期五 下午 21:37:00
2019-02-15 21:37:00.813[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:37:00.813[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  95 https://blog.csdn.net/u013305783/article/details/78563389   SpringBoot使用PageHelper进行分页   // 使用分页插件,核心代码就这一行
        PageHelper.startPage(page, perCount);
        List<AppNoticeDO> appNoticeDOList = appNoticeMapper.getAppNoticeDOList(appNoticeDTO);
        return new PageInfo<>(appNoticeDOList);2019-02-15 星期五 下午 21:37:00
2019-02-15 21:37:01.073[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [shDeLA08238694]"}
2019-02-15 21:37:01.073[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [shDeLA08238694]"}
2019-02-15 21:37:30.814[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  340 HashMap和Hashtable有什么区别？

1、HashMap是非线程安全的，HashTable是线程安全的。
2、HashMap的键和值都允许有null值存在，而HashTable则不行。
3、因为线程安全的问题，HashMap效率比HashTable的要高。
4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。

31.如何决定选用HashMap还是TreeMap？

对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。
--------------------- 
作者：hopeplus 
来源：CSDN 
原文：https://blog.csdn.net/hope900/article/details/78647466 
版权声明：本文为博主原创文章，转载请附上博文链接！2019-02-15 星期五 下午 21:37:30
2019-02-15 21:37:30.814[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:37:30.814[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  340 HashMap和Hashtable有什么区别？

1、HashMap是非线程安全的，HashTable是线程安全的。
2、HashMap的键和值都允许有null值存在，而HashTable则不行。
3、因为线程安全的问题，HashMap效率比HashTable的要高。
4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。

31.如何决定选用HashMap还是TreeMap？

对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。
--------------------- 
作者：hopeplus 
来源：CSDN 
原文：https://blog.csdn.net/hope900/article/details/78647466 
版权声明：本文为博主原创文章，转载请附上博文链接！2019-02-15 星期五 下午 21:37:30
2019-02-15 21:37:31.064[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [.v7lUA08533941]"}
2019-02-15 21:37:31.064[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [.v7lUA08533941]"}
2019-02-15 21:38:00.814[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  168 6 、关于 mysql 参数优化的经验
复制代码

首先问他它们线上 mysql 数据库是怎么安装的，如果说是 rpm 安装的，那么我就直接问调优参数了，如果是源码安装的，那么我就要问编译中的一些参数了，比如 my.cnf 以及存储引擎以及字符类型等等。然后从以下几个方面问起：
（ 1） mysql 有哪些 global 内存参数，有哪些 local 内存参数。
Global:
innodb_buffer_pool_size/innodb_additional_mem_pool_size/innodb_log_buffer_size/key_buffer_size/query_cache_size/table_open_cache/table_definition_cache/thread_cache_size
Local:
read_buffer_size/read_rnd_buffer_size/sort_buffer_size/join_buffer_size/binlog_cache_size/tmp_table_size/thread_stack/bulk_insert_buffer_size

（ 2） mysql 的写入参数需要调整哪些？重要的几个写参数的几个值得含义以及适用场景，
比如 innodb_flush_log_at_trx_commit 等。 (求补充)
sync_binlog 设置为 1，保证 binlog 的安全性。
innodb_flush_log_at_trx_commit：
0：事务提交时不将 redo log buffer 写入磁盘(仅每秒进行 master thread 刷新，安全
性最差，性能最好)
1：事务提交时将 redo log buffer 写入磁盘(安全性最好，性能最差， 推荐生产使用)
2：事务提交时仅将 redo log buffer 写入操作系统缓存(安全性和性能都居中，当 mysql宕机但是操作系统不宕机则不丢数据，如果操作系统宕机，最多丢一秒数据)
innodb_io_capacity/innodb_io_capacity_max：看磁盘的性能来定。如果是 HDD 可以设置为 200-几百不等。如果是 SSD，推荐为 4000 左右。 innodb_io_capacity_max 更大一些。
innodb_flush_method 设置为 O_DIRECT。

（ 3） 读取的话，那几个全局的 pool 的值的设置，以及几个 local 的 buffer 的设置。
Global:
innodb_buffer_pool_size:设置为可用内存的 50%-60%左右，如果不够，再慢慢上调。
innodb_additional_mem_pool_size：采用默认值 8M 即可。
innodb_log_buffer_size:默认值 8M 即可。
key_buffer_size:myisam 表需要的 buffer size，选择基本都用 innodb，所以采用默认的 8M 即可。
Local:
join_buffer_size： 当 sql 有 BNL 和 BKA 的时候，需要用的 buffer_size(plain index
scans, range index scans 的时候可能也会用到)。默认为 256k，建议设置为 16M-32M。
read_rnd_buffer_size：当使用 mrr 时，用到的 buffer。默认为 256k，建议设置为16-32M。
read_buffer_size:当顺序扫描一个 myisam 表，需要用到这个 buffer。或者用来决定memory table 的大小。或者所有的 engine 类型做如下操作：order by 的时候用 temporaryfile、 SELECT INTO … OUTFILE 'filename' 、 For caching results of nested queries。默认为 128K，建议为 16M。
sort_buffer_size： sql 语句用来进行 sort 操作(order by,group by)的 buffer。如果 buffer 不够，则需要建立 temporary file。如果在 show global status 中发现有大量的 Sort_merge_passes 值，则需要考虑调大 sort_buffer_size。默认为 256k，建议设置为 16-32M。
binlog_cache_size： 表示每个 session 中存放 transaction 的 binlog 的 cache size。默认 32K。一般使用默认值即可。如果有大事务，可以考虑调大。
thread_stack： 每个进程都需要有，默认为 256K，使用默认值即可。

（ 4） 还有就是著名的 query cache 了，以及 query cache 的适用场景了，这里有一个陷阱，
就是高并发的情况下，比如双十一的时候， query cache 开还是不开，开了怎么保证高并发，不开又有何别的考虑？建议关闭，上了性能反而更差。2019-02-15 星期五 下午 21:38:00
2019-02-15 21:38:00.814[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:38:00.814[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  168 6 、关于 mysql 参数优化的经验
复制代码

首先问他它们线上 mysql 数据库是怎么安装的，如果说是 rpm 安装的，那么我就直接问调优参数了，如果是源码安装的，那么我就要问编译中的一些参数了，比如 my.cnf 以及存储引擎以及字符类型等等。然后从以下几个方面问起：
（ 1） mysql 有哪些 global 内存参数，有哪些 local 内存参数。
Global:
innodb_buffer_pool_size/innodb_additional_mem_pool_size/innodb_log_buffer_size/key_buffer_size/query_cache_size/table_open_cache/table_definition_cache/thread_cache_size
Local:
read_buffer_size/read_rnd_buffer_size/sort_buffer_size/join_buffer_size/binlog_cache_size/tmp_table_size/thread_stack/bulk_insert_buffer_size

（ 2） mysql 的写入参数需要调整哪些？重要的几个写参数的几个值得含义以及适用场景，
比如 innodb_flush_log_at_trx_commit 等。 (求补充)
sync_binlog 设置为 1，保证 binlog 的安全性。
innodb_flush_log_at_trx_commit：
0：事务提交时不将 redo log buffer 写入磁盘(仅每秒进行 master thread 刷新，安全
性最差，性能最好)
1：事务提交时将 redo log buffer 写入磁盘(安全性最好，性能最差， 推荐生产使用)
2：事务提交时仅将 redo log buffer 写入操作系统缓存(安全性和性能都居中，当 mysql宕机但是操作系统不宕机则不丢数据，如果操作系统宕机，最多丢一秒数据)
innodb_io_capacity/innodb_io_capacity_max：看磁盘的性能来定。如果是 HDD 可以设置为 200-几百不等。如果是 SSD，推荐为 4000 左右。 innodb_io_capacity_max 更大一些。
innodb_flush_method 设置为 O_DIRECT。

（ 3） 读取的话，那几个全局的 pool 的值的设置，以及几个 local 的 buffer 的设置。
Global:
innodb_buffer_pool_size:设置为可用内存的 50%-60%左右，如果不够，再慢慢上调。
innodb_additional_mem_pool_size：采用默认值 8M 即可。
innodb_log_buffer_size:默认值 8M 即可。
key_buffer_size:myisam 表需要的 buffer size，选择基本都用 innodb，所以采用默认的 8M 即可。
Local:
join_buffer_size： 当 sql 有 BNL 和 BKA 的时候，需要用的 buffer_size(plain index
scans, range index scans 的时候可能也会用到)。默认为 256k，建议设置为 16M-32M。
read_rnd_buffer_size：当使用 mrr 时，用到的 buffer。默认为 256k，建议设置为16-32M。
read_buffer_size:当顺序扫描一个 myisam 表，需要用到这个 buffer。或者用来决定memory table 的大小。或者所有的 engine 类型做如下操作：order by 的时候用 temporaryfile、 SELECT INTO … OUTFILE 'filename' 、 For caching results of nested queries。默认为 128K，建议为 16M。
sort_buffer_size： sql 语句用来进行 sort 操作(order by,group by)的 buffer。如果 buffer 不够，则需要建立 temporary file。如果在 show global status 中发现有大量的 Sort_merge_passes 值，则需要考虑调大 sort_buffer_size。默认为 256k，建议设置为 16-32M。
binlog_cache_size： 表示每个 session 中存放 transaction 的 binlog 的 cache size。默认 32K。一般使用默认值即可。如果有大事务，可以考虑调大。
thread_stack： 每个进程都需要有，默认为 256K，使用默认值即可。

（ 4） 还有就是著名的 query cache 了，以及 query cache 的适用场景了，这里有一个陷阱，
就是高并发的情况下，比如双十一的时候， query cache 开还是不开，开了怎么保证高并发，不开又有何别的考虑？建议关闭，上了性能反而更差。2019-02-15 星期五 下午 21:38:00
2019-02-15 21:38:01.174[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [mGSYWa08843113]"}
2019-02-15 21:38:01.174[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [mGSYWa08843113]"}
2019-02-15 21:38:30.814[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  131  一看就懂的模板方法模式  https://blog.csdn.net/u013565163/article/details/792856172019-02-15 星期五 下午 21:38:30
2019-02-15 21:38:30.814[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:38:30.814[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  131  一看就懂的模板方法模式  https://blog.csdn.net/u013565163/article/details/792856172019-02-15 星期五 下午 21:38:30
2019-02-15 21:38:31.064[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [jEXgGa0913shc1]"}
2019-02-15 21:38:31.064[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [jEXgGa0913shc1]"}
2019-02-15 21:39:00.814[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  235 今天看阿里巴巴的规约扫描这里 创建HashMap要给初始大小  原java1.8中创建hashmap的初始化大小设置标准
 https://blog.csdn.net/alin1215/article/details/78435306   美团面试题 假设明确要存放100个元素 这个 美团招聘给出了一道小题目，关于HashMap的性能问题。问题如下：
java hashmap，如果确定只装载100个元素，new HashMap(?)多少是最佳的，why？
应该给256   100/0.75=133.333   HashMap 初始个数为16 然后一直乘以2  所以我们填这个初始值写其他不是16的倍数 是毫无意义的  另外为了减少rehash次数，尽量用一个明确个数 小于 n*16*0.75  的n*16的最小值 个数小于12 （16），[12，24)取32，[24,48)取64，[48,96)取128，.....所以美团这题要写256 2019-02-15 星期五 下午 21:39:00
2019-02-15 21:39:00.814[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:39:00.814[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  235 今天看阿里巴巴的规约扫描这里 创建HashMap要给初始大小  原java1.8中创建hashmap的初始化大小设置标准
 https://blog.csdn.net/alin1215/article/details/78435306   美团面试题 假设明确要存放100个元素 这个 美团招聘给出了一道小题目，关于HashMap的性能问题。问题如下：
java hashmap，如果确定只装载100个元素，new HashMap(?)多少是最佳的，why？
应该给256   100/0.75=133.333   HashMap 初始个数为16 然后一直乘以2  所以我们填这个初始值写其他不是16的倍数 是毫无意义的  另外为了减少rehash次数，尽量用一个明确个数 小于 n*16*0.75  的n*16的最小值 个数小于12 （16），[12，24)取32，[24,48)取64，[48,96)取128，.....所以美团这题要写256 2019-02-15 星期五 下午 21:39:00
2019-02-15 21:39:01.044[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [GnY09433950]"}
2019-02-15 21:39:01.044[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [GnY09433950]"}
2019-02-15 21:39:30.816[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3712019-02-15 星期五 下午 21:39:30
2019-02-15 21:39:30.816[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:39:30.816[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3712019-02-15 星期五 下午 21:39:30
2019-02-15 21:39:31.096[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [DcGVUa09733954]"}
2019-02-15 21:39:31.096[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [DcGVUa09733954]"}
2019-02-15 21:40:00.816[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3632019-02-15 星期五 下午 21:40:00
2019-02-15 21:40:00.816[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:40:00.816[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3632019-02-15 星期五 下午 21:40:00
2019-02-15 21:40:01.106[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [pWSK1a00033055]"}
2019-02-15 21:40:01.106[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [pWSK1a00033055]"}
2019-02-15 21:40:30.816[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  276 压测环境/高并发环境（比如秒杀，抢火车票）的服务运行状况完全是另外一回事  几乎所有的东西都要重新设计 最脆弱的是数据库  所以要加 缓存  高并发造成资源紧张 可能死锁  另一个 线程太多   上下文切换造成太大开销 tomcat连接数 linux可使用线程数太小 造成请求进步了服务 一直等待 响应耗时 无非就是 网络IO  磁盘IO  剩下就是jvm调用外部服务  jvm内部内耗  包括 分布式锁  线程锁  这种对共享资源争用的发生  以及 没必要的循环  事务一直没有及时提交造成锁表锁行   https://mp.weixin.qq.com/s/uWQMyuNZeO4eJFcEcGHyVg   还有 rpc中间件的参数设置  dubbo连接数   数据库连接池  web容器连接数 线程数   linux线程数的限制放开2019-02-15 星期五 下午 21:40:30
2019-02-15 21:40:30.816[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:40:30.816[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  276 压测环境/高并发环境（比如秒杀，抢火车票）的服务运行状况完全是另外一回事  几乎所有的东西都要重新设计 最脆弱的是数据库  所以要加 缓存  高并发造成资源紧张 可能死锁  另一个 线程太多   上下文切换造成太大开销 tomcat连接数 linux可使用线程数太小 造成请求进步了服务 一直等待 响应耗时 无非就是 网络IO  磁盘IO  剩下就是jvm调用外部服务  jvm内部内耗  包括 分布式锁  线程锁  这种对共享资源争用的发生  以及 没必要的循环  事务一直没有及时提交造成锁表锁行   https://mp.weixin.qq.com/s/uWQMyuNZeO4eJFcEcGHyVg   还有 rpc中间件的参数设置  dubbo连接数   数据库连接池  web容器连接数 线程数   linux线程数的限制放开2019-02-15 星期五 下午 21:40:30
2019-02-15 21:40:31.116[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [YDIX3a00334113]"}
2019-02-15 21:40:31.116[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [YDIX3a00334113]"}
2019-02-15 21:41:00.816[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2019-02-15 星期五 下午 21:41:00
2019-02-15 21:41:00.816[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:41:00.816[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2019-02-15 星期五 下午 21:41:00
2019-02-15 21:41:01.056[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [qnQd700634105]"}
2019-02-15 21:41:01.056[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [qnQd700634105]"}
2019-02-15 21:41:30.818[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  260 事务的几种传播特性
2018年01月09日 13:44:36 AlinaIDE 阅读数：4401更多个人分类： spring
摘自：https://www.cnblogs.com/m-xy/archive/2013/05/14/3077627.html
这时候我们就可以在我们业务逻辑层用HibernateTemplate里面提供的数据操作方法来编写我们的业务逻辑方法了，当然我们的方法必须要 是以我们事务配置里面配置的一样，用save，delete，update，get做我们的方法的开头。需要注意的是，默认情况下运行期异常才会回滚（包 括继承了RuntimeException子类），普通异常是不会滚的。
最后我们顺便总结一下事务的几种传播特性：
1. PROPAGATION_REQUIRED: 如果存在一个事务，则支持当前事务。如果没有事务则开启；
2. PROPAGATION_SUPPORTS: 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行；
3. PROPAGATION_MANDATORY: 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常；
4. PROPAGATION_REQUIRES_NEW: 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起；
5. PROPAGATION_NOT_SUPPORTED: 总是非事务地执行，并挂起任何存在的事务；
6. PROPAGATION_NEVER: 总是非事务地执行，如果存在一个活动事务，则抛出异常；
7. PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。2019-02-15 星期五 下午 21:41:30
2019-02-15 21:41:30.818[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:41:30.818[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  260 事务的几种传播特性
2018年01月09日 13:44:36 AlinaIDE 阅读数：4401更多个人分类： spring
摘自：https://www.cnblogs.com/m-xy/archive/2013/05/14/3077627.html
这时候我们就可以在我们业务逻辑层用HibernateTemplate里面提供的数据操作方法来编写我们的业务逻辑方法了，当然我们的方法必须要 是以我们事务配置里面配置的一样，用save，delete，update，get做我们的方法的开头。需要注意的是，默认情况下运行期异常才会回滚（包 括继承了RuntimeException子类），普通异常是不会滚的。
最后我们顺便总结一下事务的几种传播特性：
1. PROPAGATION_REQUIRED: 如果存在一个事务，则支持当前事务。如果没有事务则开启；
2. PROPAGATION_SUPPORTS: 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行；
3. PROPAGATION_MANDATORY: 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常；
4. PROPAGATION_REQUIRES_NEW: 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起；
5. PROPAGATION_NOT_SUPPORTED: 总是非事务地执行，并挂起任何存在的事务；
6. PROPAGATION_NEVER: 总是非事务地执行，如果存在一个活动事务，则抛出异常；
7. PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。2019-02-15 星期五 下午 21:41:30
2019-02-15 21:41:31.098[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [pkufAA00934129]"}
2019-02-15 21:41:31.098[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [pkufAA00934129]"}
2019-02-15 21:42:00.818[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3692019-02-15 星期五 下午 21:42:00
2019-02-15 21:42:00.818[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:42:00.818[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3692019-02-15 星期五 下午 21:42:00
2019-02-15 21:42:01.118[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [Kld.aA01234106]"}
2019-02-15 21:42:01.118[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [Kld.aA01234106]"}
2019-02-15 21:42:30.818[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  141 4.drop,delete与truncate的区别

drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始 delete删除表中数据，可以加where字句。

（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。

（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。

（3） 一般而言，drop > truncate > delete

（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view

（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。

（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。

（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。

（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚

（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。

（10） Truncate table 表名 速度快,而且效率高,因为:
truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。

（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。

（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。2019-02-15 星期五 下午 21:42:30
2019-02-15 21:42:30.818[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:42:30.818[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  141 4.drop,delete与truncate的区别

drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始 delete删除表中数据，可以加where字句。

（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。

（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。

（3） 一般而言，drop > truncate > delete

（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view

（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。

（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。

（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。

（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚

（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。

（10） Truncate table 表名 速度快,而且效率高,因为:
truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。

（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。

（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。2019-02-15 星期五 下午 21:42:30
2019-02-15 21:42:31.120[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [PkHBka01533938]"}
2019-02-15 21:42:31.120[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [PkHBka01533938]"}
2019-02-15 21:43:00.820[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  272 相信我  没三行代码就会有一个bug2019-02-15 星期五 下午 21:43:00
2019-02-15 21:43:00.820[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:43:00.820[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  272 相信我  没三行代码就会有一个bug2019-02-15 星期五 下午 21:43:00
2019-02-15 21:43:01.090[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [BQKo8a01834106]"}
2019-02-15 21:43:01.090[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [BQKo8a01834106]"}
2019-02-15 21:43:30.820[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  11mysql隔离级别  读未提交 读已提交  可重复读(锁行)  串行化(锁表)  1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

　　2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。（事务 A在这一次事务里面多次读了同一批数据）
　　3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
　　小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表事务隔离级别 	脏读 	不可重复读 	幻读
读未提交（read-uncommitted） 	是 	是 	是
不可重复读（read-committed） 	否 	是 	是
可重复读（repeatable-read） 	否 	否 	是
串行化（serializable） 	否 	否 	否2019-02-15 星期五 下午 21:43:30
2019-02-15 21:43:30.820[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:43:30.820[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  11mysql隔离级别  读未提交 读已提交  可重复读(锁行)  串行化(锁表)  1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

　　2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。（事务 A在这一次事务里面多次读了同一批数据）
　　3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
　　小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表事务隔离级别 	脏读 	不可重复读 	幻读
读未提交（read-uncommitted） 	是 	是 	是
不可重复读（read-committed） 	否 	是 	是
可重复读（repeatable-read） 	否 	否 	是
串行化（serializable） 	否 	否 	否2019-02-15 星期五 下午 21:43:30
2019-02-15 21:43:31.110[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [3w2OTA02133932]"}
2019-02-15 21:43:31.110[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [3w2OTA02133932]"}
2019-02-15 21:44:00.821[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  275 + "总结：\n"
1.除互联网公司或面高级以上的开发，JVM相关的东西不需要了解很深，笔者把复习的重点就放在这里了，是走错了方向，我曾经多次引导每位面试官，考我JVM原理，随便考，他们都回避这个问题，不是说jvm不重要，而是笔者没有能力去面试高级开发。\n"
2.互联网公司面试一定会考你大量数据的处理，数据库及sql的优化以及高并发，安全相关的问题。\n"
3.基本上大公司包括很多互联网大公司用SpringCloud的并不多，他们基本上在5，6年前或者国内刚刚兴起微服务的时候就开始做，所以都用的Dubbo，能用到springcloud项目的都是近两年的新项目。\n" + "4.简历上写什么精通就考你哪个，所以精通不要乱写。\n"
5.简历上最能突出你的优势就是类似于你凭自己的经验解决了很棘手的问题，或让系统性能有很大的提成，比如你用什么方式让你们系统从TPS 50上升到1000甚至更高。\n" + "6.有博客和自己开源项目会大大加分。\n"
7.不要跟面试官说我很会用什么很多开源框架、中间件什么的，他们其实最关注的是你懂，懂和会用完全两码事。\n" + "8.要从话语里突出和说明你学习能力强，善于知识总结和分享。\n"
9.大公司对务实很重要，对精通很重要，好比中间件，哪怕你只会rabbitmq，但是你能说做到完全精通，比你会所有中间件都强的多，简历里不要写很多技术，拿出几个拿手的，上面写上精通，并处理什么什么问题更好。\n"
10.能有带队，独立解决团队所有问题，在team中属于leader的角色一定要写，会加分。\n" + "11.我认为除应届生，java基础并不用过于放太多精力，主要了解一些关键性的底层原理就行，例如cas、volatile、hashmap等。\n"
12.有大型互联网方面的经验要有很大的优势，做一年互联网项目比你做三四年传统项目学到的东西要多得多，并且每位面试官都会跟你提到，传统行业和互联网行业区别很大。\n"
13.再次强调一点，知识储备固然重要，但是精通才是更重要的，东西不再多在于精。相信看我博客的大多都是3年及3年以上的兄台，根据发展方向每个人擅长的领域会不同，比如有些人就擅长数据库性能调优，有些人最擅长非业务性的开发，比如安全，并发处理，容量等，所以，把自己擅长的东西拿出来。\n"
14.还有跟人事聊天警惕性要增加，他们会面带微笑，给你造成轻松的气氛，但是句句话都有坑，可以说杀人于无形，说不定哪句话你就说错了，所以一定要过滤一遍大脑想想他为什么这么问，你该怎么回答。\n"
15.没有一个人是完全做技术的，技术是为业务服务的，真正的能力体现在分析不同的业务用适合他的技术去处理。\n"
16.奉劝许多在选择公司方面纠结的人，一定要选择互联网方面的公司，对做技术而言传统的公司是一个敬老院，如果你年龄到一定程度了，对事业没追求了这是一个不错的选择，否则还有一丝拼搏的精神那么就不要在该奋斗的年纪选择安逸。"2019-02-15 星期五 下午 21:44:00
2019-02-15 21:44:00.821[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:44:00.821[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  275 + "总结：\n"
1.除互联网公司或面高级以上的开发，JVM相关的东西不需要了解很深，笔者把复习的重点就放在这里了，是走错了方向，我曾经多次引导每位面试官，考我JVM原理，随便考，他们都回避这个问题，不是说jvm不重要，而是笔者没有能力去面试高级开发。\n"
2.互联网公司面试一定会考你大量数据的处理，数据库及sql的优化以及高并发，安全相关的问题。\n"
3.基本上大公司包括很多互联网大公司用SpringCloud的并不多，他们基本上在5，6年前或者国内刚刚兴起微服务的时候就开始做，所以都用的Dubbo，能用到springcloud项目的都是近两年的新项目。\n" + "4.简历上写什么精通就考你哪个，所以精通不要乱写。\n"
5.简历上最能突出你的优势就是类似于你凭自己的经验解决了很棘手的问题，或让系统性能有很大的提成，比如你用什么方式让你们系统从TPS 50上升到1000甚至更高。\n" + "6.有博客和自己开源项目会大大加分。\n"
7.不要跟面试官说我很会用什么很多开源框架、中间件什么的，他们其实最关注的是你懂，懂和会用完全两码事。\n" + "8.要从话语里突出和说明你学习能力强，善于知识总结和分享。\n"
9.大公司对务实很重要，对精通很重要，好比中间件，哪怕你只会rabbitmq，但是你能说做到完全精通，比你会所有中间件都强的多，简历里不要写很多技术，拿出几个拿手的，上面写上精通，并处理什么什么问题更好。\n"
10.能有带队，独立解决团队所有问题，在team中属于leader的角色一定要写，会加分。\n" + "11.我认为除应届生，java基础并不用过于放太多精力，主要了解一些关键性的底层原理就行，例如cas、volatile、hashmap等。\n"
12.有大型互联网方面的经验要有很大的优势，做一年互联网项目比你做三四年传统项目学到的东西要多得多，并且每位面试官都会跟你提到，传统行业和互联网行业区别很大。\n"
13.再次强调一点，知识储备固然重要，但是精通才是更重要的，东西不再多在于精。相信看我博客的大多都是3年及3年以上的兄台，根据发展方向每个人擅长的领域会不同，比如有些人就擅长数据库性能调优，有些人最擅长非业务性的开发，比如安全，并发处理，容量等，所以，把自己擅长的东西拿出来。\n"
14.还有跟人事聊天警惕性要增加，他们会面带微笑，给你造成轻松的气氛，但是句句话都有坑，可以说杀人于无形，说不定哪句话你就说错了，所以一定要过滤一遍大脑想想他为什么这么问，你该怎么回答。\n"
15.没有一个人是完全做技术的，技术是为业务服务的，真正的能力体现在分析不同的业务用适合他的技术去处理。\n"
16.奉劝许多在选择公司方面纠结的人，一定要选择互联网方面的公司，对做技术而言传统的公司是一个敬老院，如果你年龄到一定程度了，对事业没追求了这是一个不错的选择，否则还有一丝拼搏的精神那么就不要在该奋斗的年纪选择安逸。"2019-02-15 星期五 下午 21:44:00
2019-02-15 21:44:01.131[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [QD2v702433936]"}
2019-02-15 21:44:01.131[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [QD2v702433936]"}
2019-02-15 21:44:30.821[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  96  【深圳】【今日头条深圳研发中心】这真的是一封很认真的招聘贴~~~
liuyaqiu_150 · 3月之前 · 1595 次点击
我们是谁？ Developing a company as a product 是我们的理念 公司是我们团队的产品，员工是我们的用户 我们的工作是打造强大的效率工具和系统，支撑和推动公司更快更好地发展 业务范围涉及企业沟通工具、在线文档、共享日历、人力资源系统等 未来我们会推向市场，帮助更多优秀企业成长 甚至推动全球企业办公模式的变革
我们希望你来， 但我们希望吸引你来的不是免费的咖啡、漂亮的办公室和精美的下午茶 我们希望你和我们一样，最看重的是：『和优秀的人，做有挑战的事』 我们需要一群有才华、有志向的产品、技术、设计人才 能够像今日头条成立之初一样，从零开始打造一个团队
目前效率工程团队已经有数百人的规模 我们的管理理念是 【和优秀的人做有挑战的事，保持简单灵活的机制。提高透明度和信息分享效率，基于愿景目标自我驱动】 我们需要大量的leader、前后端高级工程师、客户端工程师、产品经理和UI设计师 如果你认同我们的价值观 如果你也期望加入这个推动字节跳动高速发展的团队 请和我们联系：liuyaqiu@bytedance.com
需求岗位： 服务端 /后台开发工程师 前端开发工程师 移动端（ Android 、 iOS ）开发工程师 产品经理 UI设计师
工作经验： 2 年以上
工作地点：深圳市南山区南海大道 2163 号来福士广场 15 层
简历投递邮箱：liuyaqiu@bytedance.com2019-02-15 星期五 下午 21:44:30
2019-02-15 21:44:30.821[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:44:30.821[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  96  【深圳】【今日头条深圳研发中心】这真的是一封很认真的招聘贴~~~
liuyaqiu_150 · 3月之前 · 1595 次点击
我们是谁？ Developing a company as a product 是我们的理念 公司是我们团队的产品，员工是我们的用户 我们的工作是打造强大的效率工具和系统，支撑和推动公司更快更好地发展 业务范围涉及企业沟通工具、在线文档、共享日历、人力资源系统等 未来我们会推向市场，帮助更多优秀企业成长 甚至推动全球企业办公模式的变革
我们希望你来， 但我们希望吸引你来的不是免费的咖啡、漂亮的办公室和精美的下午茶 我们希望你和我们一样，最看重的是：『和优秀的人，做有挑战的事』 我们需要一群有才华、有志向的产品、技术、设计人才 能够像今日头条成立之初一样，从零开始打造一个团队
目前效率工程团队已经有数百人的规模 我们的管理理念是 【和优秀的人做有挑战的事，保持简单灵活的机制。提高透明度和信息分享效率，基于愿景目标自我驱动】 我们需要大量的leader、前后端高级工程师、客户端工程师、产品经理和UI设计师 如果你认同我们的价值观 如果你也期望加入这个推动字节跳动高速发展的团队 请和我们联系：liuyaqiu@bytedance.com
需求岗位： 服务端 /后台开发工程师 前端开发工程师 移动端（ Android 、 iOS ）开发工程师 产品经理 UI设计师
工作经验： 2 年以上
工作地点：深圳市南山区南海大道 2163 号来福士广场 15 层
简历投递邮箱：liuyaqiu@bytedance.com2019-02-15 星期五 下午 21:44:30
2019-02-15 21:44:31.061[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [vgo3802733955]"}
2019-02-15 21:44:31.061[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [vgo3802733955]"}
2019-02-15 21:45:00.821[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  14zookeeper 实现分布式锁  https://blog.csdn.net/qiangcuo6087/article/details/790671362019-02-15 星期五 下午 21:45:00
2019-02-15 21:45:00.821[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:45:00.821[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  14zookeeper 实现分布式锁  https://blog.csdn.net/qiangcuo6087/article/details/790671362019-02-15 星期五 下午 21:45:00
2019-02-15 21:45:01.111[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [6jhdWA03033113]"}
2019-02-15 21:45:01.111[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [6jhdWA03033113]"}
2019-02-15 21:45:30.822[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3182019-02-15 星期五 下午 21:45:30
2019-02-15 21:45:30.822[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:45:30.822[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3182019-02-15 星期五 下午 21:45:30
2019-02-15 21:45:31.072[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [wDdHCA03334127]"}
2019-02-15 21:45:31.072[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [wDdHCA03334127]"}
2019-02-15 21:46:00.822[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  25最新版JDK HashMap的结构2019-02-15 星期五 下午 21:46:00
2019-02-15 21:46:00.822[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:46:00.822[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  25最新版JDK HashMap的结构2019-02-15 星期五 下午 21:46:00
2019-02-15 21:46:01.072[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [ltCQ3a03633954]"}
2019-02-15 21:46:01.072[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [ltCQ3a03633954]"}
2019-02-15 21:46:30.822[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2372019-02-15 星期五 下午 21:46:30
2019-02-15 21:46:30.822[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:46:30.822[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2372019-02-15 星期五 下午 21:46:30
2019-02-15 21:46:31.052[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [_QIYLA03934129]"}
2019-02-15 21:46:31.052[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [_QIYLA03934129]"}
2019-02-15 21:47:00.822[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  106 

这种搞法太粗犷了，每次都新建一个线程，太浪费了，迟早会崩掉的。 看ThreadB1

public class ThreadB {
	static int i = 1;
	public static void main(String[] args) {
		while(true) {
		 new Thread(new Runnable() {
			@Override
			public void run() {
				synchronized (ThreadA.class) {
					if(i<=0) {
						try {
							Thread.currentThread();
							Thread.sleep(200);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						System.out.println("生产者："+(++i));
					}
				}
			}
		}).start();
		 new Thread(new Runnable() {
				@Override
				public void run() {
					synchronized (ThreadA.class) {
						if(i>=1) {
							try {
								Thread.currentThread();
								Thread.sleep(200);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
							System.out.println("消费者："+(--i));
						}
					}
				}
			}).start();
		}
	}
}

2019-02-15 星期五 下午 21:47:00
2019-02-15 21:47:00.822[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:47:00.822[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  106 

这种搞法太粗犷了，每次都新建一个线程，太浪费了，迟早会崩掉的。 看ThreadB1

public class ThreadB {
	static int i = 1;
	public static void main(String[] args) {
		while(true) {
		 new Thread(new Runnable() {
			@Override
			public void run() {
				synchronized (ThreadA.class) {
					if(i<=0) {
						try {
							Thread.currentThread();
							Thread.sleep(200);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						System.out.println("生产者："+(++i));
					}
				}
			}
		}).start();
		 new Thread(new Runnable() {
				@Override
				public void run() {
					synchronized (ThreadA.class) {
						if(i>=1) {
							try {
								Thread.currentThread();
								Thread.sleep(200);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
							System.out.println("消费者："+(--i));
						}
					}
				}
			}).start();
		}
	}
}

2019-02-15 星期五 下午 21:47:00
2019-02-15 21:47:01.112[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [wFNOwA04233955]"}
2019-02-15 21:47:01.112[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [wFNOwA04233955]"}
2019-02-15 21:47:30.822[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  157 13、你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？

主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等

2019-02-15 星期五 下午 21:47:30
2019-02-15 21:47:30.822[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:47:30.822[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  157 13、你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？

主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等

2019-02-15 星期五 下午 21:47:30
2019-02-15 21:47:31.062[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [ZS_bIa04534128]"}
2019-02-15 21:47:31.062[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [ZS_bIa04534128]"}
2019-02-15 21:48:00.822[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  150 3、MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义
(1)、varchar与char的区别

在单字节字符集下， char（ N） 在内部存储的时候总是定长， 而且没有变长字段长度列表中。 在多字节字符集下面， char(N)如果存储的字节数超过 N，那么 char（ N）将和 varchar（ N）没有区别。在多字节字符集下面，如果存
储的字节数少于 N，那么存储 N 个字节，后面补空格，补到 N 字节长度。 都存储变长的数据和变长字段长度列表。 varchar(N)无论是什么字节字符集，都是变长的，即都存储变长数据和变长字段长度列表。

(2)、varchar(50)中50的涵义

最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。

(3)、int（20）中20的涵义

是指显示字符的长度
不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示

(4)、mysql为什么这么设计

对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；

2019-02-15 星期五 下午 21:48:00
2019-02-15 21:48:00.822[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:48:00.822[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  150 3、MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义
(1)、varchar与char的区别

在单字节字符集下， char（ N） 在内部存储的时候总是定长， 而且没有变长字段长度列表中。 在多字节字符集下面， char(N)如果存储的字节数超过 N，那么 char（ N）将和 varchar（ N）没有区别。在多字节字符集下面，如果存
储的字节数少于 N，那么存储 N 个字节，后面补空格，补到 N 字节长度。 都存储变长的数据和变长字段长度列表。 varchar(N)无论是什么字节字符集，都是变长的，即都存储变长数据和变长字段长度列表。

(2)、varchar(50)中50的涵义

最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。

(3)、int（20）中20的涵义

是指显示字符的长度
不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示

(4)、mysql为什么这么设计

对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；

2019-02-15 星期五 下午 21:48:00
2019-02-15 21:48:01.092[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [l1CBKa04833950]"}
2019-02-15 21:48:01.092[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [l1CBKa04833950]"}
2019-02-15 21:48:30.822[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3582019-02-15 星期五 下午 21:48:30
2019-02-15 21:48:30.822[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:48:30.822[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3582019-02-15 星期五 下午 21:48:30
2019-02-15 21:48:31.072[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [_s3u05134128]"}
2019-02-15 21:48:31.072[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [_s3u05134128]"}
2019-02-15 21:49:00.823[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  278 redis 分布式锁加锁正确姿势
可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：
第一个为key，我们使用key来当锁，因为key是唯一的。
第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。
第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；
第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。
第五个为time，与第四个参数相呼应，代表key的过期时间。
总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。
心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。
可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。
那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读【解锁代码-错误示例2】 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：
简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。2019-02-15 星期五 下午 21:49:00
2019-02-15 21:49:00.823[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:49:00.823[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  278 redis 分布式锁加锁正确姿势
可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：
第一个为key，我们使用key来当锁，因为key是唯一的。
第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。
第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；
第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。
第五个为time，与第四个参数相呼应，代表key的过期时间。
总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。
心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。
可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。
那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读【解锁代码-错误示例2】 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：
简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。2019-02-15 星期五 下午 21:49:00
2019-02-15 21:49:01.103[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [j1ArQA0543shb1]"}
2019-02-15 21:49:01.103[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [j1ArQA0543shb1]"}
2019-02-15 21:49:30.823[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  184 查看gc情况  stat -gc -t 4037 10s 2019-02-15 星期五 下午 21:49:30
2019-02-15 21:49:30.823[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:49:30.823[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  184 查看gc情况  stat -gc -t 4037 10s 2019-02-15 星期五 下午 21:49:30
2019-02-15 21:49:31.063[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [kWO1za05733948]"}
2019-02-15 21:49:31.063[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [kWO1za05733948]"}
2019-02-15 21:50:00.823[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  138 图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。

创建索引可以大大提高系统的性能。

第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。2019-02-15 星期五 下午 21:50:00
2019-02-15 21:50:00.823[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:50:00.823[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  138 图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。

创建索引可以大大提高系统的性能。

第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。2019-02-15 星期五 下午 21:50:00
2019-02-15 21:50:01.083[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [k8PXfa0603shc2]"}
2019-02-15 21:50:01.093[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [k8PXfa0603shc2]"}
2019-02-15 21:50:30.823[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  38工厂模式如何实现2019-02-15 星期五 下午 21:50:30
2019-02-15 21:50:30.823[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:50:30.823[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  38工厂模式如何实现2019-02-15 星期五 下午 21:50:30
2019-02-15 21:50:31.083[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [v06338653]"}
2019-02-15 21:50:31.083[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [v06338653]"}
2019-02-15 21:51:00.823[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  227 说明
网上看到大量的文章讲到MVCC都是说给每一行增加两个隐藏的字段分别表示行的创建时间以及过期时间，它们存储的并不是时间，而是事务版本号。
事实上，这种说法并不准确，严格的来讲，InnoDB会给数据库中的每一行增加三个字段，它们分别是DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID。
但是，为了理解的方便，我们可以这样去理解，索引接下来的讲解中也还是用这两个字段的方式去理解。
增删查改
在InnoDB中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。
于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：
SELECT读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
INSERT将当前事务的版本号保存至行的创建版本号
UPDATE新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
DELETE将当前事务的版本号保存至行的删除版本号
快照读和当前读
快照读：读取的是快照版本，也就是历史版本
当前读：读取的是最新版本
普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。2019-02-15 星期五 下午 21:51:00
2019-02-15 21:51:00.823[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:51:00.823[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  227 说明
网上看到大量的文章讲到MVCC都是说给每一行增加两个隐藏的字段分别表示行的创建时间以及过期时间，它们存储的并不是时间，而是事务版本号。
事实上，这种说法并不准确，严格的来讲，InnoDB会给数据库中的每一行增加三个字段，它们分别是DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID。
但是，为了理解的方便，我们可以这样去理解，索引接下来的讲解中也还是用这两个字段的方式去理解。
增删查改
在InnoDB中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。
于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：
SELECT读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
INSERT将当前事务的版本号保存至行的创建版本号
UPDATE新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
DELETE将当前事务的版本号保存至行的删除版本号
快照读和当前读
快照读：读取的是快照版本，也就是历史版本
当前读：读取的是最新版本
普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。2019-02-15 星期五 下午 21:51:00
2019-02-15 21:51:01.073[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [S.FNca06634126]"}
2019-02-15 21:51:01.073[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [S.FNca06634126]"}
2019-02-15 21:51:30.823[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  9oauth2  https://blog.csdn.net/qq1623299667/article/details/784483242019-02-15 星期五 下午 21:51:30
2019-02-15 21:51:30.823[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:51:30.823[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  9oauth2  https://blog.csdn.net/qq1623299667/article/details/784483242019-02-15 星期五 下午 21:51:30
2019-02-15 21:51:31.263[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [w6KB906943946]"}
2019-02-15 21:51:31.263[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [w6KB906943946]"}
2019-02-15 21:52:00.823[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  311 redis 一主二从三哨兵   https://www.cnblogs.com/cheyunhua/p/7940458.html   redis2019-02-15 星期五 下午 21:52:00
2019-02-15 21:52:00.823[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:52:00.823[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  311 redis 一主二从三哨兵   https://www.cnblogs.com/cheyunhua/p/7940458.html   redis2019-02-15 星期五 下午 21:52:00
2019-02-15 21:52:01.053[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [FBMppa07234120]"}
2019-02-15 21:52:01.053[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [FBMppa07234120]"}
2019-02-15 21:52:30.823[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  66a.hashCode()有什么用?与a.equals(b)有什么关系

hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，使用 equal() 方法来判断两个相等的对象，必须具有相同的 hashcode。
将对象放入到集合中时，首先判断要放入对象的hashcode是否已经在集合中存在，不存在则直接放入集合。如果hashcode相等，然后通过equal()方法判断要放入对象与集合中的任意对象是否相等：如果equal()判断不相等，直接将该元素放入集合中，否则不放入。2019-02-15 星期五 下午 21:52:30
2019-02-15 21:52:30.823[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:52:30.823[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  66a.hashCode()有什么用?与a.equals(b)有什么关系

hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，使用 equal() 方法来判断两个相等的对象，必须具有相同的 hashcode。
将对象放入到集合中时，首先判断要放入对象的hashcode是否已经在集合中存在，不存在则直接放入集合。如果hashcode相等，然后通过equal()方法判断要放入对象与集合中的任意对象是否相等：如果equal()判断不相等，直接将该元素放入集合中，否则不放入。2019-02-15 星期五 下午 21:52:30
2019-02-15 21:52:31.053[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [PhT9sa07533951]"}
2019-02-15 21:52:31.053[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [PhT9sa07533951]"}
2019-02-15 21:53:00.833[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  19zookepper2019-02-15 星期五 下午 21:53:00
2019-02-15 21:53:00.833[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:53:00.833[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  19zookepper2019-02-15 星期五 下午 21:53:00
2019-02-15 21:53:01.103[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [9p1dtA07834123]"}
2019-02-15 21:53:01.103[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [9p1dtA07834123]"}
2019-02-15 21:53:30.833[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  266 try 里面爆出异常的地方开始后面的代码不会再执行了  只会执行 catch里面以及以后的2019-02-15 星期五 下午 21:53:30
2019-02-15 21:53:30.833[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:53:30.833[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  266 try 里面爆出异常的地方开始后面的代码不会再执行了  只会执行 catch里面以及以后的2019-02-15 星期五 下午 21:53:30
2019-02-15 21:53:31.083[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [jz5Cda08134105]"}
2019-02-15 21:53:31.083[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [jz5Cda08134105]"}
2019-02-15 21:54:00.825[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2472019-02-15 星期五 下午 21:54:00
2019-02-15 21:54:00.825[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:54:00.825[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2472019-02-15 星期五 下午 21:54:00
2019-02-15 21:54:01.085[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [RT7Nla08432277]"}
2019-02-15 21:54:01.085[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [RT7Nla08432277]"}
2019-02-15 21:54:30.825[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2422019-02-15 星期五 下午 21:54:30
2019-02-15 21:54:30.825[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:54:30.825[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2422019-02-15 星期五 下午 21:54:30
2019-02-15 21:54:31.095[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [HTjXra0873shc1]"}
2019-02-15 21:54:31.095[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [HTjXra0873shc1]"}
2019-02-15 21:55:00.835[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  262  在OLTP系统领域，我们在很多业务场景下都会面临事务一致性方面的需求，例如最经典的Bob给Smith转账的案例。传统的企业开发，系统往往是以单体应用形式存在的，也没有横跨多个数据库。我们通常只需借助开发平台中特有数据访问技术和框架（例如Spring、JDBC、ADO.NET），结合关系型数据库自带的事务管理机制来实现事务性的需求。关系型数据库通常具有ACID特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

而大型互联网平台往往是由一系列分布式系统构成的，开发语言平台和技术栈也相对比较杂，尤其是在SOA和微服务架构盛行的今天，一个看起来简单的功能，内部可能需要调用多个“服务”并操作多个数据库或分片来实现，情况往往会复杂很多。单一的技术手段和解决方案，已经无法应对和满足这些复杂的场景了。
分布式系统的特性
对分布式系统有过研究的读者，可能听说过“CAP定律”、“Base理论”等，非常巧的是，化学理论中ACID是酸、Base恰好是碱。这里笔者不对这些概念做过多的解释，有兴趣的读者可以查看相关参考资料。CAP定律如下图：
原文：https://blog.csdn.net/zhejingyuan/article/details/79480128 
版权声明：本文为博主原创文章，转载请附上博文链接！    https://blog.csdn.net/zhejingyuan/article/details/794801282019-02-15 星期五 下午 21:55:00
2019-02-15 21:55:00.835[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:55:00.835[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  262  在OLTP系统领域，我们在很多业务场景下都会面临事务一致性方面的需求，例如最经典的Bob给Smith转账的案例。传统的企业开发，系统往往是以单体应用形式存在的，也没有横跨多个数据库。我们通常只需借助开发平台中特有数据访问技术和框架（例如Spring、JDBC、ADO.NET），结合关系型数据库自带的事务管理机制来实现事务性的需求。关系型数据库通常具有ACID特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

而大型互联网平台往往是由一系列分布式系统构成的，开发语言平台和技术栈也相对比较杂，尤其是在SOA和微服务架构盛行的今天，一个看起来简单的功能，内部可能需要调用多个“服务”并操作多个数据库或分片来实现，情况往往会复杂很多。单一的技术手段和解决方案，已经无法应对和满足这些复杂的场景了。
分布式系统的特性
对分布式系统有过研究的读者，可能听说过“CAP定律”、“Base理论”等，非常巧的是，化学理论中ACID是酸、Base恰好是碱。这里笔者不对这些概念做过多的解释，有兴趣的读者可以查看相关参考资料。CAP定律如下图：
原文：https://blog.csdn.net/zhejingyuan/article/details/79480128 
版权声明：本文为博主原创文章，转载请附上博文链接！    https://blog.csdn.net/zhejingyuan/article/details/794801282019-02-15 星期五 下午 21:55:00
2019-02-15 21:55:01.455[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [HKhfza0904shb1]"}
2019-02-15 21:55:01.455[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [HKhfza0904shb1]"}
2019-02-15 21:55:30.835[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  367 java判断一个字符串是否是json格式
2017年04月24日 18:53:36 Legendary灬 阅读数：14858
版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/qq_16272049/article/details/70649767
本以为判断一个字符串是否是json格式，常用的json处理工具类会有成型的方法，结果找了一下却没有发现，所以只能用异常来解决这个问题。
这肯定是个非常规的办法 ，不过可以解决问题，记录一下，有更好方法，欢迎提出！
import com.alibaba.fastjson.JSONObject; 

public boolean isJson(String content){
    try {
        JSONObject jsonStr= JSONObject.parseObject(content);
        return  true;
   } catch (Exception e) {
        return false;
  }
}2019-02-15 星期五 下午 21:55:30
2019-02-15 21:55:30.835[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:55:30.835[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  367 java判断一个字符串是否是json格式
2017年04月24日 18:53:36 Legendary灬 阅读数：14858
版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/qq_16272049/article/details/70649767
本以为判断一个字符串是否是json格式，常用的json处理工具类会有成型的方法，结果找了一下却没有发现，所以只能用异常来解决这个问题。
这肯定是个非常规的办法 ，不过可以解决问题，记录一下，有更好方法，欢迎提出！
import com.alibaba.fastjson.JSONObject; 

public boolean isJson(String content){
    try {
        JSONObject jsonStr= JSONObject.parseObject(content);
        return  true;
   } catch (Exception e) {
        return false;
  }
}2019-02-15 星期五 下午 21:55:30
2019-02-15 21:55:31.115[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [egN0Ka09338672]"}
2019-02-15 21:55:31.115[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [egN0Ka09338672]"}
2019-02-15 21:56:00.835[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  101  Condition有点意思
Condition con1 = new Condition.newCondition();
con1.await();   //让当前线程在这里wait();
con1.signal();  //唤醒一个被con1.await()的线程，继续执行后面的代码   
我很想写一个demo，按顺序让线程1，2，3分别执行1，2，3圈，循环往复，一个线程任务不能被其他线程断，可以用重入锁。或者synchronized2019-02-15 星期五 下午 21:56:00
2019-02-15 21:56:00.835[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:56:00.835[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  101  Condition有点意思
Condition con1 = new Condition.newCondition();
con1.await();   //让当前线程在这里wait();
con1.signal();  //唤醒一个被con1.await()的线程，继续执行后面的代码   
我很想写一个demo，按顺序让线程1，2，3分别执行1，2，3圈，循环往复，一个线程任务不能被其他线程断，可以用重入锁。或者synchronized2019-02-15 星期五 下午 21:56:00
2019-02-15 21:56:01.075[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [f7d8mA09632277]"}
2019-02-15 21:56:01.075[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [f7d8mA09632277]"}
2019-02-15 21:56:30.835[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  137 同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：

第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。2019-02-15 星期五 下午 21:56:30
2019-02-15 21:56:30.835[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:56:30.835[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  137 同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：

第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。2019-02-15 星期五 下午 21:56:30
2019-02-15 21:56:31.075[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [C6WQBa09933932]"}
2019-02-15 21:56:31.075[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [C6WQBa09933932]"}
2019-02-15 21:57:00.835[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  161 17、在当前的工作中，你碰到到的最大的 mysql db 问题以及如何解决的？

可以选择一个处理过的比较棘手的案例，或者选择一个老师在课程上讲过的死锁的案例;没有及时 Purge + insert 唯一索引造成的死锁：具体案例可以参考学委笔记。

2019-02-15 星期五 下午 21:57:00
2019-02-15 21:57:00.835[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:57:00.835[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  161 17、在当前的工作中，你碰到到的最大的 mysql db 问题以及如何解决的？

可以选择一个处理过的比较棘手的案例，或者选择一个老师在课程上讲过的死锁的案例;没有及时 Purge + insert 唯一索引造成的死锁：具体案例可以参考学委笔记。

2019-02-15 星期五 下午 21:57:00
2019-02-15 21:57:01.055[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [bm4Dha0023shc2]"}
2019-02-15 21:57:01.055[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [bm4Dha0023shc2]"}
2019-02-15 21:57:30.835[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  153 6、下MySQL数据库cpu飙升到500%的话他怎么处理？

当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，
看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。也有可能是每个 sql 消耗资源并不多，但是突然之间，
有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等

2019-02-15 星期五 下午 21:57:30
2019-02-15 21:57:30.835[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:57:30.835[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  153 6、下MySQL数据库cpu飙升到500%的话他怎么处理？

当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，
看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。也有可能是每个 sql 消耗资源并不多，但是突然之间，
有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等

2019-02-15 星期五 下午 21:57:30
2019-02-15 21:57:31.115[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [xBsHKA00533947]"}
2019-02-15 21:57:31.115[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [xBsHKA00533947]"}
2019-02-15 21:58:00.835[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  126  面试的过程请保持耐心，认真听取，切勿打断求职者，切勿过分争论和反驳
面试结束后尽快给予求职者反馈
技术考察

技术考察主要覆盖基础知识、专业知识和逻辑思维三方面。首先了解求职者经历的项目以及在该项目中承担的角色和工作内容，再以项目为切入点，由浅入深的提出和
基础知识以及专业知识相关的问题，要特别注意这些问题的连贯性，从而考察面试者的功底、逻辑性和解决问题的思路。为了缓和氛围，还可以提一些开放的问题，
那些钟情于技术的 geek 们，在这类问题往往能回答的深入和透彻。

基础知识
熟练掌握一门语言
熟悉基本的数据结构和算法
熟练使用 Linux(Windows)，对操作系统原理的理解
Optional: 数据库、Web Server 和 TCP/IP 等
专业 & 经验
专业知识的考察因业务而异，求职者应该需要了解整个项目的功能，明白自己模块承担的角色，熟悉模块的业务流程以及针对该业务使用到的技术框架，
某些特殊的业务可能会用到算法。
开放问题
你使用过哪些语言，对比它们的异同，谈谈你的感受？
你喜欢哪些技术书籍(博客)？
哪些软件你觉得很棒，为什么？
你通过什么渠道学习新技术知识？
你解决过哪些令你难忘的 bug，并说说解决的过程？
谈谈个人计算机(互联网网络)的发展历史？
谈谈你敬佩的工程师？
谈谈测试的重要性？
一点感受

不推荐纯粹的数学题、智力题等考察题目
不推荐压力面试，群面等面试方式
不推荐做题、现场写代码(时间成本太高，伪代码除外)，不推荐询问杂而无连贯的问题
能给出 github 的求职者往往具有更强的竞争力
面试的方式和考察重点因人而异，本人认为这种方式的面试效率较高，既适合现场面试、又适合电话面试，非常注重基础功底，基础功底扎实的工程师编程能力、
学习能力和调试能力都比较强悍，因为外部各异的技术归根结底总是有诸多相通之处。2019-02-15 星期五 下午 21:58:00
2019-02-15 21:58:00.835[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:58:00.835[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  126  面试的过程请保持耐心，认真听取，切勿打断求职者，切勿过分争论和反驳
面试结束后尽快给予求职者反馈
技术考察

技术考察主要覆盖基础知识、专业知识和逻辑思维三方面。首先了解求职者经历的项目以及在该项目中承担的角色和工作内容，再以项目为切入点，由浅入深的提出和
基础知识以及专业知识相关的问题，要特别注意这些问题的连贯性，从而考察面试者的功底、逻辑性和解决问题的思路。为了缓和氛围，还可以提一些开放的问题，
那些钟情于技术的 geek 们，在这类问题往往能回答的深入和透彻。

基础知识
熟练掌握一门语言
熟悉基本的数据结构和算法
熟练使用 Linux(Windows)，对操作系统原理的理解
Optional: 数据库、Web Server 和 TCP/IP 等
专业 & 经验
专业知识的考察因业务而异，求职者应该需要了解整个项目的功能，明白自己模块承担的角色，熟悉模块的业务流程以及针对该业务使用到的技术框架，
某些特殊的业务可能会用到算法。
开放问题
你使用过哪些语言，对比它们的异同，谈谈你的感受？
你喜欢哪些技术书籍(博客)？
哪些软件你觉得很棒，为什么？
你通过什么渠道学习新技术知识？
你解决过哪些令你难忘的 bug，并说说解决的过程？
谈谈个人计算机(互联网网络)的发展历史？
谈谈你敬佩的工程师？
谈谈测试的重要性？
一点感受

不推荐纯粹的数学题、智力题等考察题目
不推荐压力面试，群面等面试方式
不推荐做题、现场写代码(时间成本太高，伪代码除外)，不推荐询问杂而无连贯的问题
能给出 github 的求职者往往具有更强的竞争力
面试的方式和考察重点因人而异，本人认为这种方式的面试效率较高，既适合现场面试、又适合电话面试，非常注重基础功底，基础功底扎实的工程师编程能力、
学习能力和调试能力都比较强悍，因为外部各异的技术归根结底总是有诸多相通之处。2019-02-15 星期五 下午 21:58:00
2019-02-15 21:58:01.105[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [El5140083shc1]"}
2019-02-15 21:58:01.105[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [El5140083shc1]"}
2019-02-15 21:58:30.835[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  172 10 、关于有丰富的线上恢复经验的

就问你现在线上数据量有多大，如果是 100G，你用 mysqldump 出来要多久，然后 mysql进去又要多久，如果互联网不允许延时的话，你又怎么做到 恢复单张表的时候保证 nagios不报警。如果有人说 mysqldump 出来 1 个小时就 ok 了，那么我就要问问他 db 服务器是
啥配置了，如果他说 mysql 进去 50 分钟搞定了，那么我也要问问他 db 机器啥配置了，如果是普通的吊丝 pc server，那么真实性，大家懂得。然后如果你用 xtrabackup 备份要多久，恢复要多久，大家都知道 copy-back 这一步要很久，那么你有没有办法对这一块优化。

2019-02-15 星期五 下午 21:58:30
2019-02-15 21:58:30.835[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:58:30.835[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  172 10 、关于有丰富的线上恢复经验的

就问你现在线上数据量有多大，如果是 100G，你用 mysqldump 出来要多久，然后 mysql进去又要多久，如果互联网不允许延时的话，你又怎么做到 恢复单张表的时候保证 nagios不报警。如果有人说 mysqldump 出来 1 个小时就 ok 了，那么我就要问问他 db 服务器是
啥配置了，如果他说 mysql 进去 50 分钟搞定了，那么我也要问问他 db 机器啥配置了，如果是普通的吊丝 pc server，那么真实性，大家懂得。然后如果你用 xtrabackup 备份要多久，恢复要多久，大家都知道 copy-back 这一步要很久，那么你有没有办法对这一块优化。

2019-02-15 星期五 下午 21:58:30
2019-02-15 21:58:31.065[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [dJ..Ba01133949]"}
2019-02-15 21:58:31.065[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [dJ..Ba01133949]"}
2019-02-15 21:59:00.835[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  38工厂模式如何实现2019-02-15 星期五 下午 21:59:00
2019-02-15 21:59:00.835[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:59:00.835[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  38工厂模式如何实现2019-02-15 星期五 下午 21:59:00
2019-02-15 21:59:01.095[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [eaL.PA01432066]"}
2019-02-15 21:59:01.095[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [eaL.PA01432066]"}
2019-02-15 21:59:30.835[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2492019-02-15 星期五 下午 21:59:30
2019-02-15 21:59:30.835[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 21:59:30.835[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2492019-02-15 星期五 下午 21:59:30
2019-02-15 21:59:31.095[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [PkSsbA01734102]"}
2019-02-15 21:59:31.095[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [PkSsbA01734102]"}
2019-02-15 22:00:00.835[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3492019-02-15 星期五 下午 22:00:00
2019-02-15 22:00:00.835[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:00:00.835[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3492019-02-15 星期五 下午 22:00:00
2019-02-15 22:00:01.085[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [TdQ2.a02033950]"}
2019-02-15 22:00:01.085[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [TdQ2.a02033950]"}
2019-02-15 22:00:30.835[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3192019-02-15 星期五 下午 22:00:30
2019-02-15 22:00:30.835[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:00:30.835[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3192019-02-15 星期五 下午 22:00:30
2019-02-15 22:00:31.195[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [uvao_02334126]"}
2019-02-15 22:00:31.195[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [uvao_02334126]"}
2019-02-15 22:01:00.836[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  162 18、请简洁地描述下 MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？

(1)、事物的4种隔离级别

读未提交(read uncommitted)
读已提交(read committed)
可重复读(repeatable read)
串行(serializable)

(2)、不同级别的现象

Read Uncommitted:可以读取其他 session 未提交的脏数据。
Read Committed:允许不可重复读取，但不允许脏读取。提交后，其他会话可以看到提交的数据。
Repeatable Read: 禁止不可重复读取和脏读取、以及幻读(innodb 独有)。
Serializable: 事务只能一个接着一个地执行，但不能并发执行。事务隔离级别最高。
不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差。

2019-02-15 星期五 下午 22:01:00
2019-02-15 22:01:00.836[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:01:00.836[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  162 18、请简洁地描述下 MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？

(1)、事物的4种隔离级别

读未提交(read uncommitted)
读已提交(read committed)
可重复读(repeatable read)
串行(serializable)

(2)、不同级别的现象

Read Uncommitted:可以读取其他 session 未提交的脏数据。
Read Committed:允许不可重复读取，但不允许脏读取。提交后，其他会话可以看到提交的数据。
Repeatable Read: 禁止不可重复读取和脏读取、以及幻读(innodb 独有)。
Serializable: 事务只能一个接着一个地执行，但不能并发执行。事务隔离级别最高。
不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差。

2019-02-15 星期五 下午 22:01:00
2019-02-15 22:01:01.136[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [02634129]"}
2019-02-15 22:01:01.136[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [02634129]"}
2019-02-15 22:01:30.836[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  192 （7）分布式

redis支持主从的模式。原则：Master会将数据同步到slave，而slave不会将数据同步到master。Slave启动时会连接master来同步数据。

这是一个典型的分布式读写分离模型。我们可以利用master来插入数据，slave提供检索服务。这样可以有效减少单个机器的并发访问数量2019-02-15 星期五 下午 22:01:30
2019-02-15 22:01:30.836[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:01:30.836[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  192 （7）分布式

redis支持主从的模式。原则：Master会将数据同步到slave，而slave不会将数据同步到master。Slave启动时会连接master来同步数据。

这是一个典型的分布式读写分离模型。我们可以利用master来插入数据，slave提供检索服务。这样可以有效减少单个机器的并发访问数量2019-02-15 星期五 下午 22:01:30
2019-02-15 22:01:31.096[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [aP5hhA02934129]"}
2019-02-15 22:01:31.096[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [aP5hhA02934129]"}
2019-02-15 22:02:00.836[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  173 详解TCP的3次握手和4次挥手   https://blog.csdn.net/kingov/article/details/771556712019-02-15 星期五 下午 22:02:00
2019-02-15 22:02:00.836[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:02:00.836[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  173 详解TCP的3次握手和4次挥手   https://blog.csdn.net/kingov/article/details/771556712019-02-15 星期五 下午 22:02:00
2019-02-15 22:02:01.106[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [P1v9Ha03238641]"}
2019-02-15 22:02:01.106[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [P1v9Ha03238641]"}
2019-02-15 22:02:30.836[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  25最新版JDK HashMap的结构2019-02-15 星期五 下午 22:02:30
2019-02-15 22:02:30.836[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:02:30.836[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  25最新版JDK HashMap的结构2019-02-15 星期五 下午 22:02:30
2019-02-15 22:02:31.236[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [UwR2da03544123]"}
2019-02-15 22:02:31.236[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [UwR2da03544123]"}
2019-02-15 22:03:00.836[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  294 获取Date 不要再去new了  ，太low了 ，/**
     * 获取当前系统时间
     *
     * @return
     */
    public static Date getCurDate() {
        return Calendar.getInstance().getTime();
    }2019-02-15 星期五 下午 22:03:00
2019-02-15 22:03:00.836[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:03:00.836[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  294 获取Date 不要再去new了  ，太low了 ，/**
     * 获取当前系统时间
     *
     * @return
     */
    public static Date getCurDate() {
        return Calendar.getInstance().getTime();
    }2019-02-15 星期五 下午 22:03:00
2019-02-15 22:03:01.136[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [VBvM303834120]"}
2019-02-15 22:03:01.136[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [VBvM303834120]"}
2019-02-15 22:03:30.836[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  167 5、对于有丰富的数据库设计经验

这个对于数据库设计我真的没有太多的经验，我也就只能问问最基础的， mysql 中varchar(60) 60 是啥含义， int(30)中 30 是啥含义？ 如果他都回答对了，那么我就问 mysql中为什么要这么设计呢？
如果他还回答对了，我就继续问 int(20)存储的数字的上限和下限是多少？这个问题难道了全部的 mysql dba 的应聘者，不得不佩服提出这个问题的金总的睿智啊，因为这个问题回答正确了，
那么他确实认认真真地研究了 mysql 的设计中关于字段类型的细节。至 于丰富的设计数据库的经验，不用着急，这不我上面还有更加厉害的 dba吗，他会搞明白的，那就跟我无关了。
varchar(60)的 60 表示最多可以存储 60 个字符。int(30)的 30 表示客户端显示这个字段的宽度。
为何这么设计？说不清楚，请大家补充 。 int(20)的上限为 2147483647(signed)或者4294967295(unsigned)。

2019-02-15 星期五 下午 22:03:30
2019-02-15 22:03:30.836[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:03:30.836[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  167 5、对于有丰富的数据库设计经验

这个对于数据库设计我真的没有太多的经验，我也就只能问问最基础的， mysql 中varchar(60) 60 是啥含义， int(30)中 30 是啥含义？ 如果他都回答对了，那么我就问 mysql中为什么要这么设计呢？
如果他还回答对了，我就继续问 int(20)存储的数字的上限和下限是多少？这个问题难道了全部的 mysql dba 的应聘者，不得不佩服提出这个问题的金总的睿智啊，因为这个问题回答正确了，
那么他确实认认真真地研究了 mysql 的设计中关于字段类型的细节。至 于丰富的设计数据库的经验，不用着急，这不我上面还有更加厉害的 dba吗，他会搞明白的，那就跟我无关了。
varchar(60)的 60 表示最多可以存储 60 个字符。int(30)的 30 表示客户端显示这个字段的宽度。
为何这么设计？说不清楚，请大家补充 。 int(20)的上限为 2147483647(signed)或者4294967295(unsigned)。

2019-02-15 星期五 下午 22:03:30
2019-02-15 22:03:31.116[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [07QgrA04132066]"}
2019-02-15 22:03:31.116[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [07QgrA04132066]"}
2019-02-15 22:04:00.836[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  233 如果redis key过热怎么办  分成多个key来存储2019-02-15 星期五 下午 22:04:00
2019-02-15 22:04:00.836[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:04:00.836[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  233 如果redis key过热怎么办  分成多个key来存储2019-02-15 星期五 下午 22:04:00
2019-02-15 22:04:01.086[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [CwHe904433943]"}
2019-02-15 22:04:01.086[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [CwHe904433943]"}
2019-02-15 22:04:30.836[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  356 am pm:  问一下大佬们，有没有懂Kafka的，Kafka怎么标记消息是否被消费，没有被标记消费的，重复消费，这个应该怎么设置？ 傅文江: offset  2019-02-15 星期五 下午 22:04:30
2019-02-15 22:04:30.836[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:04:30.836[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  356 am pm:  问一下大佬们，有没有懂Kafka的，Kafka怎么标记消息是否被消费，没有被标记消费的，重复消费，这个应该怎么设置？ 傅文江: offset  2019-02-15 星期五 下午 22:04:30
2019-02-15 22:04:31.126[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [xaG5za04731295]"}
2019-02-15 22:04:31.126[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [xaG5za04731295]"}
2019-02-15 22:05:00.836[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  76 String.format(" %s ￥ %s", tornCake.getDesc(), tornCake.price()  这也是一种拼接字符串的方式  JAVA字符串格式化-String.format()和MessageFormat的使用   https://blog.csdn.net/candyguy242/article/details/807822442019-02-15 星期五 下午 22:05:00
2019-02-15 22:05:00.836[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:05:00.836[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  76 String.format(" %s ￥ %s", tornCake.getDesc(), tornCake.price()  这也是一种拼接字符串的方式  JAVA字符串格式化-String.format()和MessageFormat的使用   https://blog.csdn.net/candyguy242/article/details/807822442019-02-15 星期五 下午 22:05:00
2019-02-15 22:05:01.116[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [ubEbUa05033951]"}
2019-02-15 22:05:01.116[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [ubEbUa05033951]"}
2019-02-15 22:05:30.836[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  110 java5里面的读写锁跟mysql里面的读写锁是不是异曲同工之妙
mysql里面的读写锁，昨天配置这个mysql主从配置的时候，还配置了这个读写锁，先给主库上read lock,从库配置完重启后，再释放主库的锁用unlock lock

命令吧好像。

java5的读写锁的妙用，用在缓存的读写里面。是怕出现脏读，幻读。仅仅是get，set操作倒还好，就是怕前面还有if条件判断，那就有可能出现中间wait（if判断完
wait（），
不能马上执行后面的语句，这就完了）2019-02-15 星期五 下午 22:05:30
2019-02-15 22:05:30.836[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:05:30.836[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  110 java5里面的读写锁跟mysql里面的读写锁是不是异曲同工之妙
mysql里面的读写锁，昨天配置这个mysql主从配置的时候，还配置了这个读写锁，先给主库上read lock,从库配置完重启后，再释放主库的锁用unlock lock

命令吧好像。

java5的读写锁的妙用，用在缓存的读写里面。是怕出现脏读，幻读。仅仅是get，set操作倒还好，就是怕前面还有if条件判断，那就有可能出现中间wait（if判断完
wait（），
不能马上执行后面的语句，这就完了）2019-02-15 星期五 下午 22:05:30
2019-02-15 22:05:31.116[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [KfpeUA05333954]"}
2019-02-15 22:05:31.116[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [KfpeUA05333954]"}
2019-02-15 22:06:00.836[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3322019-02-15 星期五 下午 22:06:00
2019-02-15 22:06:00.836[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:06:00.836[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3322019-02-15 星期五 下午 22:06:00
2019-02-15 22:06:01.486[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [yz6kTa05644121]"}
2019-02-15 22:06:01.486[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [yz6kTa05644121]"}
2019-02-15 22:06:30.846[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  264 kill pid

kill pid和kill -s 15 pid含义一样，表示发送一个SIGTERM的信号给对应的程序。程序收到该信号后，将会发生以下事情，

1 程序立刻停止

2 程序释放相应资源后立刻停止

3 程序可能仍然继续运行

大部分程序在接收到SIGTERM信号后，会先释放自己的资源，然后再停止。但也有一些程序在收到信号后，做一些其他事情，并且这些事情是可以配置的。也就是说，SIGTERM多半是会被阻塞，忽略的。


kill -9 pid

kill -9 pid等于kill -s 9 pid，表示强制，尽快终止一个进程。多半admin会用这个命令。
2019-02-15 星期五 下午 22:06:30
2019-02-15 22:06:30.846[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:06:30.846[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  264 kill pid

kill pid和kill -s 15 pid含义一样，表示发送一个SIGTERM的信号给对应的程序。程序收到该信号后，将会发生以下事情，

1 程序立刻停止

2 程序释放相应资源后立刻停止

3 程序可能仍然继续运行

大部分程序在接收到SIGTERM信号后，会先释放自己的资源，然后再停止。但也有一些程序在收到信号后，做一些其他事情，并且这些事情是可以配置的。也就是说，SIGTERM多半是会被阻塞，忽略的。


kill -9 pid

kill -9 pid等于kill -s 9 pid，表示强制，尽快终止一个进程。多半admin会用这个命令。
2019-02-15 星期五 下午 22:06:30
2019-02-15 22:06:31.116[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [x3Jj805933947]"}
2019-02-15 22:06:31.116[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [x3Jj805933947]"}
2019-02-15 22:07:00.846[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  301  乞丐不好意思要饭，结果饿死了；商户不好意思要账，结果自己门店关了；不好意思向心仪的人表白，结果她跟别人走了；不好意思让客户签单，结果客户在别人那里成交了；不要让不好意思成为你人生的绊脚石，凡是让你觉得不好意思的都要马上去做，否则时间会把你的勇气完全消磨掉。说句实在的，我想要赞！2019-02-15 星期五 下午 22:07:00
2019-02-15 22:07:00.846[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:07:00.846[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  301  乞丐不好意思要饭，结果饿死了；商户不好意思要账，结果自己门店关了；不好意思向心仪的人表白，结果她跟别人走了；不好意思让客户签单，结果客户在别人那里成交了；不要让不好意思成为你人生的绊脚石，凡是让你觉得不好意思的都要马上去做，否则时间会把你的勇气完全消磨掉。说句实在的，我想要赞！2019-02-15 星期五 下午 22:07:00
2019-02-15 22:07:01.096[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [YEcnIa06233951]"}
2019-02-15 22:07:01.096[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [YEcnIa06233951]"}
2019-02-15 22:07:30.846[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2492019-02-15 星期五 下午 22:07:30
2019-02-15 22:07:30.846[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:07:30.846[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2492019-02-15 星期五 下午 22:07:30
2019-02-15 22:07:31.116[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [wkzu06533937]"}
2019-02-15 22:07:31.116[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [wkzu06533937]"}
2019-02-15 22:08:00.846[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  141 4.drop,delete与truncate的区别

drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始 delete删除表中数据，可以加where字句。

（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。

（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。

（3） 一般而言，drop > truncate > delete

（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view

（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。

（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。

（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。

（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚

（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。

（10） Truncate table 表名 速度快,而且效率高,因为:
truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。

（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。

（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。2019-02-15 星期五 下午 22:08:00
2019-02-15 22:08:00.846[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:08:00.846[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  141 4.drop,delete与truncate的区别

drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始 delete删除表中数据，可以加where字句。

（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。

（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。

（3） 一般而言，drop > truncate > delete

（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view

（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。

（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。

（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。

（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚

（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。

（10） Truncate table 表名 速度快,而且效率高,因为:
truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。

（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。

（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。2019-02-15 星期五 下午 22:08:00
2019-02-15 22:08:01.496[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [ghDWLa06842066]"}
2019-02-15 22:08:01.506[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [ghDWLa06842066]"}
2019-02-15 22:08:30.846[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  212 Spring的核心类有哪些，各有什么作用？

BeanFactory：产生一个新的实例，可以实现单例模式

BeanWrapper：提供统一的get及set方法

ApplicationContext:提供框架的实现，包括BeanFactory的所有功能
2019-02-15 星期五 下午 22:08:30
2019-02-15 22:08:30.846[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:08:30.846[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  212 Spring的核心类有哪些，各有什么作用？

BeanFactory：产生一个新的实例，可以实现单例模式

BeanWrapper：提供统一的get及set方法

ApplicationContext:提供框架的实现，包括BeanFactory的所有功能
2019-02-15 星期五 下午 22:08:30
2019-02-15 22:08:31.156[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [0Sk5OA07133949]"}
2019-02-15 22:08:31.156[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [0Sk5OA07133949]"}
2019-02-15 22:09:00.848[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  229 4、查询操作：
从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来：
1) 删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除。(即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)
2) 创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert。
（即事务id为2的事务只能读取到create version<=2的已提交的事务的数据集）
补充：
1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.
2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.
原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。
3.串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。
4.通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。2019-02-15 星期五 下午 22:09:00
2019-02-15 22:09:00.848[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:09:00.848[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  229 4、查询操作：
从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来：
1) 删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除。(即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)
2) 创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert。
（即事务id为2的事务只能读取到create version<=2的已提交的事务的数据集）
补充：
1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.
2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.
原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。
3.串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。
4.通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。2019-02-15 星期五 下午 22:09:00
2019-02-15 22:09:01.138[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [jH2407433929]"}
2019-02-15 22:09:01.138[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [jH2407433929]"}
2019-02-15 22:09:30.848[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  337  equals和hashcode为什么要一起重写

object对象中的 public boolean equals(Object obj)，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true； 注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。如下： (1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true  (2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false 如果不重写equals，那么比较的将是对象的引用是否指向同一块内存地址，重写之后目的是为了比较两个对象的value值是否相等。特别指出利用equals比较八大包装对象 （如int，float等）和String类（因为该类已重写了equals和hashcode方法）对象时，默认比较的是值，在比较其它自定义对象时都是比较的引用地址 hashcode是用于散列数据的快速存取，如利用HashSet/HashMap/Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。 这样如果我们对一个对象重写了euqals，意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象， 当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象， 导致混淆，因此，就也需要重写hashcode() 举例说明：  就这个程序进行分析，在第一次添加时，调用了hashcode()方法，将hashcode存入对象中，第二次也一样，然后对hashcode进行比较。hashcode也只用于HashSet/HashMap/Hashtable类存储数据，所以会用于比较，需要重写

总结，自定义类要重写equals方法来进行等值比较，自定义类要重写compareTo方法来进行不同对象大小的比较，重写hashcode方法为了将数据存入HashSet/HashMap/Hashtable类时进行比较2019-02-15 星期五 下午 22:09:30
2019-02-15 22:09:30.848[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:09:30.848[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  337  equals和hashcode为什么要一起重写

object对象中的 public boolean equals(Object obj)，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true； 注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。如下： (1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true  (2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false 如果不重写equals，那么比较的将是对象的引用是否指向同一块内存地址，重写之后目的是为了比较两个对象的value值是否相等。特别指出利用equals比较八大包装对象 （如int，float等）和String类（因为该类已重写了equals和hashcode方法）对象时，默认比较的是值，在比较其它自定义对象时都是比较的引用地址 hashcode是用于散列数据的快速存取，如利用HashSet/HashMap/Hashtable类来存储数据时，都是根据存储对象的hashcode值来进行判断是否相同的。 这样如果我们对一个对象重写了euqals，意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象， 当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象， 导致混淆，因此，就也需要重写hashcode() 举例说明：  就这个程序进行分析，在第一次添加时，调用了hashcode()方法，将hashcode存入对象中，第二次也一样，然后对hashcode进行比较。hashcode也只用于HashSet/HashMap/Hashtable类存储数据，所以会用于比较，需要重写

总结，自定义类要重写equals方法来进行等值比较，自定义类要重写compareTo方法来进行不同对象大小的比较，重写hashcode方法为了将数据存入HashSet/HashMap/Hashtable类时进行比较2019-02-15 星期五 下午 22:09:30
2019-02-15 22:09:31.078[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [UPCpiA0773shc1]"}
2019-02-15 22:09:31.078[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [UPCpiA0773shc1]"}
2019-02-15 22:10:00.848[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  279 网络在线看板 还是很吊的   https://www.leangoo.com/kanban/board_list   2019-02-15 星期五 下午 22:10:00
2019-02-15 22:10:00.848[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:10:00.848[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  279 网络在线看板 还是很吊的   https://www.leangoo.com/kanban/board_list   2019-02-15 星期五 下午 22:10:00
2019-02-15 22:10:01.178[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [pYOJuA08035508]"}
2019-02-15 22:10:01.178[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [pYOJuA08035508]"}
2019-02-15 22:10:30.848[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2892019-02-15 星期五 下午 22:10:30
2019-02-15 22:10:30.848[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:10:30.848[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2892019-02-15 星期五 下午 22:10:30
2019-02-15 22:10:31.108[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [sVZsQA08334129]"}
2019-02-15 22:10:31.108[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [sVZsQA08334129]"}
2019-02-15 22:11:00.848[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  344 Arraylist与linkedlist的区别

a) 都是实现list接口的列表，arraylist是基于数组的数据结构，linkedlist是基于链表的数据结构，当获取特定元素时，ArrayList效率比较快，它通过数组下标即可获取，而linkedlist则需要移动指针。当存储元素与删除元素时linkedlist效率较快，只需要将指针移动指定位置增加或者删除即可，而arraylist需要移动数据。
--------------------- 
作者：白衣染霜华丶 
来源：CSDN 
原文：https://blog.csdn.net/zhangcc233/article/details/77847104 
版权声明：本文为博主原创文章，转载请附上博文链接！2019-02-15 星期五 下午 22:11:00
2019-02-15 22:11:00.848[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:11:00.848[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  344 Arraylist与linkedlist的区别

a) 都是实现list接口的列表，arraylist是基于数组的数据结构，linkedlist是基于链表的数据结构，当获取特定元素时，ArrayList效率比较快，它通过数组下标即可获取，而linkedlist则需要移动指针。当存储元素与删除元素时linkedlist效率较快，只需要将指针移动指定位置增加或者删除即可，而arraylist需要移动数据。
--------------------- 
作者：白衣染霜华丶 
来源：CSDN 
原文：https://blog.csdn.net/zhangcc233/article/details/77847104 
版权声明：本文为博主原创文章，转载请附上博文链接！2019-02-15 星期五 下午 22:11:00
2019-02-15 22:11:01.178[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [Uu5rNa08638641]"}
2019-02-15 22:11:01.178[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [Uu5rNa08638641]"}
2019-02-15 22:11:30.848[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  89    排序算法  时间空间复杂度  https://blog.csdn.net/yushiyi6453/article/details/76407640 2019-02-15 星期五 下午 22:11:30
2019-02-15 22:11:30.848[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:11:30.848[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  89    排序算法  时间空间复杂度  https://blog.csdn.net/yushiyi6453/article/details/76407640 2019-02-15 星期五 下午 22:11:30
2019-02-15 22:11:31.098[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [cw3OHA08934100]"}
2019-02-15 22:11:31.098[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [cw3OHA08934100]"}
2019-02-15 22:12:00.848[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  368 这个分布式事务跟孙玄讲的基本一致    interview之前可以拿出来温故一下   https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html2019-02-15 星期五 下午 22:12:00
2019-02-15 22:12:00.848[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:12:00.848[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  368 这个分布式事务跟孙玄讲的基本一致    interview之前可以拿出来温故一下   https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html2019-02-15 星期五 下午 22:12:00
2019-02-15 22:12:01.108[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [L4Dg809234129]"}
2019-02-15 22:12:01.108[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [L4Dg809234129]"}
2019-02-15 22:12:30.848[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  310 SpringBoot 使用线程池
2018 年了，SpringBoot 盛行；来看看在 SpringBoot 中应当怎么配置和使用线程池。
既然用了 SpringBoot ，那自然得发挥 Spring 的特性，所以需要 Spring 来帮我们管理线程池：
@Configuration
public class TreadPoolConfig {
    /**
     * 消费队列线程
     * @return
     */
    @Bean(value = "consumerQueueThreadPool")
    public ExecutorService buildConsumerQueueThreadPool(){
        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
                .setNameFormat("consumer-queue-thread-%d").build();

        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());

        return pool ;
    }
}
使用时：
    @Resource(name = "consumerQueueThreadPool")
    private ExecutorService consumerQueueThreadPool;
    @Override
    public void execute() {

        //消费队列
        for (int i = 0; i < 5; i++) {
            consumerQueueThreadPool.execute(new ConsumerQueueThread());
        }

    }
其实也挺简单，就是创建了一个线程池的 bean，在使用时直接从 Spring 中取出即可。2019-02-15 星期五 下午 22:12:30
2019-02-15 22:12:30.848[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:12:30.848[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  310 SpringBoot 使用线程池
2018 年了，SpringBoot 盛行；来看看在 SpringBoot 中应当怎么配置和使用线程池。
既然用了 SpringBoot ，那自然得发挥 Spring 的特性，所以需要 Spring 来帮我们管理线程池：
@Configuration
public class TreadPoolConfig {
    /**
     * 消费队列线程
     * @return
     */
    @Bean(value = "consumerQueueThreadPool")
    public ExecutorService buildConsumerQueueThreadPool(){
        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
                .setNameFormat("consumer-queue-thread-%d").build();

        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());

        return pool ;
    }
}
使用时：
    @Resource(name = "consumerQueueThreadPool")
    private ExecutorService consumerQueueThreadPool;
    @Override
    public void execute() {

        //消费队列
        for (int i = 0; i < 5; i++) {
            consumerQueueThreadPool.execute(new ConsumerQueueThread());
        }

    }
其实也挺简单，就是创建了一个线程池的 bean，在使用时直接从 Spring 中取出即可。2019-02-15 星期五 下午 22:12:30
2019-02-15 22:12:31.128[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [IM14pa0953shc2]"}
2019-02-15 22:12:31.128[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [IM14pa0953shc2]"}
2019-02-15 22:13:00.849[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  283 sun eclipse里面的merge tool 怎么使用 https://www.cnblogs.com/wavky/p/3504060.html  merge tool里面是可以左右复制代码的2019-02-15 星期五 下午 22:13:00
2019-02-15 22:13:00.849[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:13:00.849[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  283 sun eclipse里面的merge tool 怎么使用 https://www.cnblogs.com/wavky/p/3504060.html  merge tool里面是可以左右复制代码的2019-02-15 星期五 下午 22:13:00
2019-02-15 22:13:01.069[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [_9qxLa0983shc1]"}
2019-02-15 22:13:01.069[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [_9qxLa0983shc1]"}
2019-02-15 22:13:30.849[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  255 sudo su - 切换到root用户                                                                                                                                                                              2019-02-15 星期五 下午 22:13:30
2019-02-15 22:13:30.849[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:13:30.849[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  255 sudo su - 切换到root用户                                                                                                                                                                              2019-02-15 星期五 下午 22:13:30
2019-02-15 22:13:31.119[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [UIkXka00134126]"}
2019-02-15 22:13:31.119[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [UIkXka00134126]"}
2019-02-15 22:14:00.849[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  243 基于k8s、docker、jenkins构建springboot服务
 http://www.mamicode.com/info-detail-2316898.html 2019-02-15 星期五 下午 22:14:00
2019-02-15 22:14:00.849[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:14:00.849[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  243 基于k8s、docker、jenkins构建springboot服务
 http://www.mamicode.com/info-detail-2316898.html 2019-02-15 星期五 下午 22:14:00
2019-02-15 22:14:01.109[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [nuwuoA00434120]"}
2019-02-15 22:14:01.119[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [nuwuoA00434120]"}
2019-02-15 22:14:30.849[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  375 2019-02-15 星期五 下午 22:14:30
2019-02-15 22:14:30.849[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:14:30.849[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  375 2019-02-15 星期五 下午 22:14:30
2019-02-15 22:14:31.079[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [N6qqCa00733936]"}
2019-02-15 22:14:31.079[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [N6qqCa00733936]"}
2019-02-15 22:15:00.849[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  173 详解TCP的3次握手和4次挥手   https://blog.csdn.net/kingov/article/details/771556712019-02-15 星期五 下午 22:15:00
2019-02-15 22:15:00.849[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:15:00.849[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  173 详解TCP的3次握手和4次挥手   https://blog.csdn.net/kingov/article/details/771556712019-02-15 星期五 下午 22:15:00
2019-02-15 22:15:01.130[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [IKtmTa01038651]"}
2019-02-15 22:15:01.130[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [IKtmTa01038651]"}
2019-02-15 22:15:30.850[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  163 面试中其他的问题：
1、2 年 MySQL DBA 经验
复制代码

其中许多有水分，一看到简历自我介绍，说公司项目的时候，会写上 linux 系统维护，mssql server 项目，或者 oracle data gard 项目，一般如果有这些的话，工作在 3 年到 4年的话，他的 2 年 MySQL DBA 管理经验，是有很大的水分的。刚开始我跟领导说，这些
不用去面试了，肯定 mysql dba 经验不足，领导说先面面看看，于是我就面了，结果很多人卡在基础知识这一环节之上，比如：
（ 1）有的卡在复制原理之上
（ 2）有的卡在 binlog 的日志格式的种类和分别
（ 3）有的卡在 innodb 事务与日志的实现上。
（ 4）有的卡在 innodb 与 myisam 的索引实现方式的理解上面。
.........
个人觉得如果有过真正的 2 年 mysql 专职 dba 经验，那么肯定会在 mysql 的基本原理上有所研究，因为很多问题都不得不让你去仔细研究各种细节，而自 己研究过的细节肯定会记忆深刻，别人问起一定会说的头头是道，起码一些最基本的关键参数比如
Seconds_Behind_Master 为 60 这个值 60 的准确涵义，面试了 10+的 mysql dba，没有一个说的准确，有的说不知道忘记了，有的说是差了 60 秒，有的说是与主上执行时间延后了 60 秒。2019-02-15 星期五 下午 22:15:30
2019-02-15 22:15:30.850[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:15:30.850[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  163 面试中其他的问题：
1、2 年 MySQL DBA 经验
复制代码

其中许多有水分，一看到简历自我介绍，说公司项目的时候，会写上 linux 系统维护，mssql server 项目，或者 oracle data gard 项目，一般如果有这些的话，工作在 3 年到 4年的话，他的 2 年 MySQL DBA 管理经验，是有很大的水分的。刚开始我跟领导说，这些
不用去面试了，肯定 mysql dba 经验不足，领导说先面面看看，于是我就面了，结果很多人卡在基础知识这一环节之上，比如：
（ 1）有的卡在复制原理之上
（ 2）有的卡在 binlog 的日志格式的种类和分别
（ 3）有的卡在 innodb 事务与日志的实现上。
（ 4）有的卡在 innodb 与 myisam 的索引实现方式的理解上面。
.........
个人觉得如果有过真正的 2 年 mysql 专职 dba 经验，那么肯定会在 mysql 的基本原理上有所研究，因为很多问题都不得不让你去仔细研究各种细节，而自 己研究过的细节肯定会记忆深刻，别人问起一定会说的头头是道，起码一些最基本的关键参数比如
Seconds_Behind_Master 为 60 这个值 60 的准确涵义，面试了 10+的 mysql dba，没有一个说的准确，有的说不知道忘记了，有的说是差了 60 秒，有的说是与主上执行时间延后了 60 秒。2019-02-15 星期五 下午 22:15:30
2019-02-15 22:15:31.100[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [avY_Ra01334121]"}
2019-02-15 22:15:31.100[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [avY_Ra01334121]"}
2019-02-15 22:16:00.850[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  134 B-/+Tree索引的性能分析

到这里终于可以分析B-/+Tree索引的性能了。

上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：

每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。

而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

综上所述，用B-Tree作为索引结构效率是非常高的。2019-02-15 星期五 下午 22:16:00
2019-02-15 22:16:00.850[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:16:00.850[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  134 B-/+Tree索引的性能分析

到这里终于可以分析B-/+Tree索引的性能了。

上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：

每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。

而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

综上所述，用B-Tree作为索引结构效率是非常高的。2019-02-15 星期五 下午 22:16:00
2019-02-15 22:16:01.100[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [85fNCA01634116]"}
2019-02-15 22:16:01.100[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [85fNCA01634116]"}
2019-02-15 22:16:30.850[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  157 13、你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？

主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等

2019-02-15 星期五 下午 22:16:30
2019-02-15 22:16:30.850[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:16:30.850[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  157 13、你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？

主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等

2019-02-15 星期五 下午 22:16:30
2019-02-15 22:16:31.070[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [EFAzwa01933934]"}
2019-02-15 22:16:31.070[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [EFAzwa01933934]"}
2019-02-15 22:17:00.850[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  132 一次 HashSet 所引起的并发问题  https://mp.weixin.qq.com/s/-_6fDP6OSse-tL-ptjcbJw    HashSet的本质还是HashMap  如何线程安全的使用HashSet 使用ConcurrentHashMap   value写死成null2019-02-15 星期五 下午 22:17:00
2019-02-15 22:17:00.850[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:17:00.850[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  132 一次 HashSet 所引起的并发问题  https://mp.weixin.qq.com/s/-_6fDP6OSse-tL-ptjcbJw    HashSet的本质还是HashMap  如何线程安全的使用HashSet 使用ConcurrentHashMap   value写死成null2019-02-15 星期五 下午 22:17:00
2019-02-15 22:17:01.110[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [sontfa02233945]"}
2019-02-15 22:17:01.110[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [sontfa02233945]"}
2019-02-15 22:17:30.851[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  243 基于k8s、docker、jenkins构建springboot服务
 http://www.mamicode.com/info-detail-2316898.html 2019-02-15 星期五 下午 22:17:30
2019-02-15 22:17:30.851[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:17:30.851[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  243 基于k8s、docker、jenkins构建springboot服务
 http://www.mamicode.com/info-detail-2316898.html 2019-02-15 星期五 下午 22:17:30
2019-02-15 22:17:31.111[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [gJqotA02534107]"}
2019-02-15 22:17:31.111[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [gJqotA02534107]"}
2019-02-15 22:18:00.851[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  35一致性hash2019-02-15 星期五 下午 22:18:00
2019-02-15 22:18:00.851[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:18:00.851[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  35一致性hash2019-02-15 星期五 下午 22:18:00
2019-02-15 22:18:01.111[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [QkVI_a02833947]"}
2019-02-15 22:18:01.111[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [QkVI_a02833947]"}
2019-02-15 22:18:30.851[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  132 一次 HashSet 所引起的并发问题  https://mp.weixin.qq.com/s/-_6fDP6OSse-tL-ptjcbJw    HashSet的本质还是HashMap  如何线程安全的使用HashSet 使用ConcurrentHashMap   value写死成null2019-02-15 星期五 下午 22:18:30
2019-02-15 22:18:30.851[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:18:30.851[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  132 一次 HashSet 所引起的并发问题  https://mp.weixin.qq.com/s/-_6fDP6OSse-tL-ptjcbJw    HashSet的本质还是HashMap  如何线程安全的使用HashSet 使用ConcurrentHashMap   value写死成null2019-02-15 星期五 下午 22:18:30
2019-02-15 22:18:31.121[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [3cZT7a03134106]"}
2019-02-15 22:18:31.121[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [3cZT7a03134106]"}
2019-02-15 22:19:00.851[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  194 （9）数据分片模型

为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。

可以将每个节点看成都是独立的master，然后通过业务实现数据分片。

结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。2019-02-15 星期五 下午 22:19:00
2019-02-15 22:19:00.851[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:19:00.851[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  194 （9）数据分片模型

为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。

可以将每个节点看成都是独立的master，然后通过业务实现数据分片。

结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。2019-02-15 星期五 下午 22:19:00
2019-02-15 22:19:01.161[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [3lKnwA03433950]"}
2019-02-15 22:19:01.161[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [3lKnwA03433950]"}
2019-02-15 22:19:30.853[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  73关于垃圾回收
你知道哪些垃圾回收算法?

垃圾回收从理论上非常容易理解,具体的方法有以下几种: 
1. 标记-清除 
2. 标记-复制 
3. 标记-整理 
4. 分代回收 
更详细的内容参见深入理解垃圾回收算法：

http://blog.csdn.net/dd864140130/article/details/50084471
如何判断一个对象是否应该被回收

这就是所谓的对象存活性判断，常用的方法有两种：1.引用计数法;　2.对象可达性分析。由于引用计数法存在互相引用导致无法进行GC的问题，所以目前JVM虚拟机多使用对象可达性分析算法。
简单的解释一下垃圾回收

Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。
调用System.gc()会发生什么?

通知GC开始工作，但是GC真正开始的时间不确定。2019-02-15 星期五 下午 22:19:30
2019-02-15 22:19:30.853[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:19:30.853[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  73关于垃圾回收
你知道哪些垃圾回收算法?

垃圾回收从理论上非常容易理解,具体的方法有以下几种: 
1. 标记-清除 
2. 标记-复制 
3. 标记-整理 
4. 分代回收 
更详细的内容参见深入理解垃圾回收算法：

http://blog.csdn.net/dd864140130/article/details/50084471
如何判断一个对象是否应该被回收

这就是所谓的对象存活性判断，常用的方法有两种：1.引用计数法;　2.对象可达性分析。由于引用计数法存在互相引用导致无法进行GC的问题，所以目前JVM虚拟机多使用对象可达性分析算法。
简单的解释一下垃圾回收

Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。
调用System.gc()会发生什么?

通知GC开始工作，但是GC真正开始的时间不确定。2019-02-15 星期五 下午 22:19:30
2019-02-15 22:19:31.103[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [BHsJYa03734123]"}
2019-02-15 22:19:31.103[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [BHsJYa03734123]"}
2019-02-15 22:20:00.853[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  265 eclipse debug 模式 三个tab  变量列表  断点列表  表达式列表2019-02-15 星期五 下午 22:20:00
2019-02-15 22:20:00.853[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:20:00.853[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  265 eclipse debug 模式 三个tab  变量列表  断点列表  表达式列表2019-02-15 星期五 下午 22:20:00
2019-02-15 22:20:01.103[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [iwxk7a04032277]"}
2019-02-15 22:20:01.103[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [iwxk7a04032277]"}
2019-02-15 22:20:30.853[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  271 Arrays.asList(param0,param1 ... paramN),这里这种入参个数不定的方法，其实入参是个数组,你看Arrays.asList 这个名字2019-02-15 星期五 下午 22:20:30
2019-02-15 22:20:30.853[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:20:30.853[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  271 Arrays.asList(param0,param1 ... paramN),这里这种入参个数不定的方法，其实入参是个数组,你看Arrays.asList 这个名字2019-02-15 星期五 下午 22:20:30
2019-02-15 22:20:31.113[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [BXylKA04332066]"}
2019-02-15 22:20:31.113[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [BXylKA04332066]"}
2019-02-15 22:21:00.853[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  227 说明
网上看到大量的文章讲到MVCC都是说给每一行增加两个隐藏的字段分别表示行的创建时间以及过期时间，它们存储的并不是时间，而是事务版本号。
事实上，这种说法并不准确，严格的来讲，InnoDB会给数据库中的每一行增加三个字段，它们分别是DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID。
但是，为了理解的方便，我们可以这样去理解，索引接下来的讲解中也还是用这两个字段的方式去理解。
增删查改
在InnoDB中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。
于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：
SELECT读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
INSERT将当前事务的版本号保存至行的创建版本号
UPDATE新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
DELETE将当前事务的版本号保存至行的删除版本号
快照读和当前读
快照读：读取的是快照版本，也就是历史版本
当前读：读取的是最新版本
普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。2019-02-15 星期五 下午 22:21:00
2019-02-15 22:21:00.853[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:21:00.853[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  227 说明
网上看到大量的文章讲到MVCC都是说给每一行增加两个隐藏的字段分别表示行的创建时间以及过期时间，它们存储的并不是时间，而是事务版本号。
事实上，这种说法并不准确，严格的来讲，InnoDB会给数据库中的每一行增加三个字段，它们分别是DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID。
但是，为了理解的方便，我们可以这样去理解，索引接下来的讲解中也还是用这两个字段的方式去理解。
增删查改
在InnoDB中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。
于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：
SELECT读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
INSERT将当前事务的版本号保存至行的创建版本号
UPDATE新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
DELETE将当前事务的版本号保存至行的删除版本号
快照读和当前读
快照读：读取的是快照版本，也就是历史版本
当前读：读取的是最新版本
普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。2019-02-15 星期五 下午 22:21:00
2019-02-15 22:21:01.123[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [7q8Z904634123]"}
2019-02-15 22:21:01.123[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [7q8Z904634123]"}
2019-02-15 22:21:30.853[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2372019-02-15 星期五 下午 22:21:30
2019-02-15 22:21:30.853[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:21:30.853[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2372019-02-15 星期五 下午 22:21:30
2019-02-15 22:21:31.113[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [30TQBA04933943]"}
2019-02-15 22:21:31.113[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [30TQBA04933943]"}
2019-02-15 22:22:00.853[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2402019-02-15 星期五 下午 22:22:00
2019-02-15 22:22:00.853[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:22:00.853[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2402019-02-15 星期五 下午 22:22:00
2019-02-15 22:22:01.093[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [Mku0Ma05234114]"}
2019-02-15 22:22:01.093[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [Mku0Ma05234114]"}
2019-02-15 22:22:30.853[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  301  乞丐不好意思要饭，结果饿死了；商户不好意思要账，结果自己门店关了；不好意思向心仪的人表白，结果她跟别人走了；不好意思让客户签单，结果客户在别人那里成交了；不要让不好意思成为你人生的绊脚石，凡是让你觉得不好意思的都要马上去做，否则时间会把你的勇气完全消磨掉。说句实在的，我想要赞！2019-02-15 星期五 下午 22:22:30
2019-02-15 22:22:30.853[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:22:30.853[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  301  乞丐不好意思要饭，结果饿死了；商户不好意思要账，结果自己门店关了；不好意思向心仪的人表白，结果她跟别人走了；不好意思让客户签单，结果客户在别人那里成交了；不要让不好意思成为你人生的绊脚石，凡是让你觉得不好意思的都要马上去做，否则时间会把你的勇气完全消磨掉。说句实在的，我想要赞！2019-02-15 星期五 下午 22:22:30
2019-02-15 22:22:31.093[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [Nh4qDa05538694]"}
2019-02-15 22:22:31.093[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [Nh4qDa05538694]"}
2019-02-15 22:23:00.854[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  1222019-02-15 星期五 下午 22:23:00
2019-02-15 22:23:00.854[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:23:00.854[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  1222019-02-15 星期五 下午 22:23:00
2019-02-15 22:23:01.114[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [aIDBNa05833952]"}
2019-02-15 22:23:01.124[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [aIDBNa05833952]"}
2019-02-15 22:23:30.854[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3232019-02-15 星期五 下午 22:23:30
2019-02-15 22:23:30.854[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:23:30.854[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3232019-02-15 星期五 下午 22:23:30
2019-02-15 22:23:31.094[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [4Jr06138672]"}
2019-02-15 22:23:31.094[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [4Jr06138672]"}
2019-02-15 22:24:00.856[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  272 相信我  没三行代码就会有一个bug2019-02-15 星期五 下午 22:24:00
2019-02-15 22:24:00.856[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:24:00.856[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  272 相信我  没三行代码就会有一个bug2019-02-15 星期五 下午 22:24:00
2019-02-15 22:24:01.096[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [lNoJsA06433924]"}
2019-02-15 22:24:01.096[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [lNoJsA06433924]"}
2019-02-15 22:24:30.856[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2472019-02-15 星期五 下午 22:24:30
2019-02-15 22:24:30.856[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:24:30.856[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2472019-02-15 星期五 下午 22:24:30
2019-02-15 22:24:31.076[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [NDRrIa06735508]"}
2019-02-15 22:24:31.076[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [NDRrIa06735508]"}
2019-02-15 22:25:00.857[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  301  乞丐不好意思要饭，结果饿死了；商户不好意思要账，结果自己门店关了；不好意思向心仪的人表白，结果她跟别人走了；不好意思让客户签单，结果客户在别人那里成交了；不要让不好意思成为你人生的绊脚石，凡是让你觉得不好意思的都要马上去做，否则时间会把你的勇气完全消磨掉。说句实在的，我想要赞！2019-02-15 星期五 下午 22:25:00
2019-02-15 22:25:00.857[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:25:00.857[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  301  乞丐不好意思要饭，结果饿死了；商户不好意思要账，结果自己门店关了；不好意思向心仪的人表白，结果她跟别人走了；不好意思让客户签单，结果客户在别人那里成交了；不要让不好意思成为你人生的绊脚石，凡是让你觉得不好意思的都要马上去做，否则时间会把你的勇气完全消磨掉。说句实在的，我想要赞！2019-02-15 星期五 下午 22:25:00
2019-02-15 22:25:01.157[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [3e07034108]"}
2019-02-15 22:25:01.157[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [3e07034108]"}
2019-02-15 22:25:30.857[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  38工厂模式如何实现2019-02-15 星期五 下午 22:25:30
2019-02-15 22:25:30.857[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:25:30.857[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  38工厂模式如何实现2019-02-15 星期五 下午 22:25:30
2019-02-15 22:25:31.147[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [.WgilA07333945]"}
2019-02-15 22:25:31.147[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [.WgilA07333945]"}
2019-02-15 22:26:00.859[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2802019-02-15 星期五 下午 22:26:00
2019-02-15 22:26:00.859[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:26:00.859[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2802019-02-15 星期五 下午 22:26:00
2019-02-15 22:26:01.119[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [tkLNbA07634125]"}
2019-02-15 22:26:01.119[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [tkLNbA07634125]"}
2019-02-15 22:26:30.859[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3622019-02-15 星期五 下午 22:26:30
2019-02-15 22:26:30.859[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:26:30.859[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3622019-02-15 星期五 下午 22:26:30
2019-02-15 22:26:31.109[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [fayqrA07934104]"}
2019-02-15 22:26:31.109[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [fayqrA07934104]"}
2019-02-15 22:27:00.859[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  276 压测环境/高并发环境（比如秒杀，抢火车票）的服务运行状况完全是另外一回事  几乎所有的东西都要重新设计 最脆弱的是数据库  所以要加 缓存  高并发造成资源紧张 可能死锁  另一个 线程太多   上下文切换造成太大开销 tomcat连接数 linux可使用线程数太小 造成请求进步了服务 一直等待 响应耗时 无非就是 网络IO  磁盘IO  剩下就是jvm调用外部服务  jvm内部内耗  包括 分布式锁  线程锁  这种对共享资源争用的发生  以及 没必要的循环  事务一直没有及时提交造成锁表锁行   https://mp.weixin.qq.com/s/uWQMyuNZeO4eJFcEcGHyVg   还有 rpc中间件的参数设置  dubbo连接数   数据库连接池  web容器连接数 线程数   linux线程数的限制放开2019-02-15 星期五 下午 22:27:00
2019-02-15 22:27:00.859[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:27:00.859[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  276 压测环境/高并发环境（比如秒杀，抢火车票）的服务运行状况完全是另外一回事  几乎所有的东西都要重新设计 最脆弱的是数据库  所以要加 缓存  高并发造成资源紧张 可能死锁  另一个 线程太多   上下文切换造成太大开销 tomcat连接数 linux可使用线程数太小 造成请求进步了服务 一直等待 响应耗时 无非就是 网络IO  磁盘IO  剩下就是jvm调用外部服务  jvm内部内耗  包括 分布式锁  线程锁  这种对共享资源争用的发生  以及 没必要的循环  事务一直没有及时提交造成锁表锁行   https://mp.weixin.qq.com/s/uWQMyuNZeO4eJFcEcGHyVg   还有 rpc中间件的参数设置  dubbo连接数   数据库连接池  web容器连接数 线程数   linux线程数的限制放开2019-02-15 星期五 下午 22:27:00
2019-02-15 22:27:01.099[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [xAAosA08234104]"}
2019-02-15 22:27:01.099[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [xAAosA08234104]"}
2019-02-15 22:27:30.859[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3192019-02-15 星期五 下午 22:27:30
2019-02-15 22:27:30.859[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:27:30.859[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3192019-02-15 星期五 下午 22:27:30
2019-02-15 22:27:31.119[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [D9jLuA08534125]"}
2019-02-15 22:27:31.119[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [D9jLuA08534125]"}
2019-02-15 22:28:00.859[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  326  oppo面试题 十个写线程 一个读线程 加写锁之后要不要加读锁？ 当然要，加读锁的目的是为了跟写锁互斥啊，除非你全是读线程，那就不要加锁了，因为只读不写是不会有安全问题的2019-02-15 星期五 下午 22:28:00
2019-02-15 22:28:00.859[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:28:00.859[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  326  oppo面试题 十个写线程 一个读线程 加写锁之后要不要加读锁？ 当然要，加读锁的目的是为了跟写锁互斥啊，除非你全是读线程，那就不要加锁了，因为只读不写是不会有安全问题的2019-02-15 星期五 下午 22:28:00
2019-02-15 22:28:01.129[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [zwTXza08834108]"}
2019-02-15 22:28:01.129[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [zwTXza08834108]"}
2019-02-15 22:28:30.859[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  180 字符串作为值来传递，数组作为对象传递

值传递是不改变原来属性的值的。
所以结果是：goodbbb

String 确定是值传递，。   https://zhidao.baidu.com/question/106796048.html2019-02-15 星期五 下午 22:28:30
2019-02-15 22:28:30.859[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:28:30.859[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  180 字符串作为值来传递，数组作为对象传递

值传递是不改变原来属性的值的。
所以结果是：goodbbb

String 确定是值传递，。   https://zhidao.baidu.com/question/106796048.html2019-02-15 星期五 下午 22:28:30
2019-02-15 22:28:31.119[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [nOR_Sa0913shb1]"}
2019-02-15 22:28:31.119[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [nOR_Sa0913shb1]"}
2019-02-15 22:29:00.869[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2492019-02-15 星期五 下午 22:29:00
2019-02-15 22:29:00.869[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:29:00.869[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2492019-02-15 星期五 下午 22:29:00
2019-02-15 22:29:01.169[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [A6S8sA09434124]"}
2019-02-15 22:29:01.169[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [A6S8sA09434124]"}
2019-02-15 22:29:30.869[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2232019-02-15 星期五 下午 22:29:30
2019-02-15 22:29:30.869[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:29:30.869[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2232019-02-15 星期五 下午 22:29:30
2019-02-15 22:29:31.159[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [6sZPNa0973shc1]"}
2019-02-15 22:29:31.159[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [6sZPNa0973shc1]"}
2019-02-15 22:30:00.861[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  5SpringMVC原理1、  用户发送请求至前端控制器DispatcherServlet。
2、  DispatcherServlet收到请求调用HandlerMapping处理器映射器。
3、  处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
4、  DispatcherServlet调用HandlerAdapter处理器适配器。
5、  HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。
6、  Controller执行完成返回ModelAndView。
7、  HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。
8、  DispatcherServlet将ModelAndView传给ViewReslover视图解析器。
9、  ViewReslover解析后返回具体View。
10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。
11、 DispatcherServlet响应用户。2019-02-15 星期五 下午 22:30:00
2019-02-15 22:30:00.861[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:30:00.862[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  5SpringMVC原理1、  用户发送请求至前端控制器DispatcherServlet。
2、  DispatcherServlet收到请求调用HandlerMapping处理器映射器。
3、  处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
4、  DispatcherServlet调用HandlerAdapter处理器适配器。
5、  HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。
6、  Controller执行完成返回ModelAndView。
7、  HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。
8、  DispatcherServlet将ModelAndView传给ViewReslover视图解析器。
9、  ViewReslover解析后返回具体View。
10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。
11、 DispatcherServlet响应用户。2019-02-15 星期五 下午 22:30:00
2019-02-15 22:30:01.116[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [w0vxaa00033924]"}
2019-02-15 22:30:01.117[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [w0vxaa00033924]"}
2019-02-15 22:30:30.865[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  226 一致性非锁定读和锁定读
锁定读
　　在一个事务中，标准的SELECT语句是不会加锁，但是有两种情况例外。SELECT ... LOCK IN SHARE MODE 和 SELECT ... FOR UPDATE。
　　SELECT ... LOCK IN SHARE MODE
　　给记录假设共享锁，这样一来的话，其它事务只能读不能修改，直到当前事务提交
　　SELECT ... FOR UPDATE
　　给索引记录加锁，这种情况下跟UPDATE的加锁情况是一样的
一致性非锁定读
　　consistent read （一致性读），InnoDB用多版本来提供查询数据库在某个时间点的快照。如果隔离级别是REPEATABLE READ，那么在同一个事务中的所有一致性读都读的是事务中第一个这样的读读到的快照；如果是READ COMMITTED，那么一个事务中的每一个一致性读都会读到它自己刷新的快照版本。Consistent read（一致性读）是READ COMMITTED和REPEATABLE READ隔离级别下普通SELECT语句默认的模式。一致性读不会给它所访问的表加任何形式的锁，因此其它事务可以同时并发的修改它们。2019-02-15 星期五 下午 22:30:30
2019-02-15 22:30:30.865[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:30:30.865[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  226 一致性非锁定读和锁定读
锁定读
　　在一个事务中，标准的SELECT语句是不会加锁，但是有两种情况例外。SELECT ... LOCK IN SHARE MODE 和 SELECT ... FOR UPDATE。
　　SELECT ... LOCK IN SHARE MODE
　　给记录假设共享锁，这样一来的话，其它事务只能读不能修改，直到当前事务提交
　　SELECT ... FOR UPDATE
　　给索引记录加锁，这种情况下跟UPDATE的加锁情况是一样的
一致性非锁定读
　　consistent read （一致性读），InnoDB用多版本来提供查询数据库在某个时间点的快照。如果隔离级别是REPEATABLE READ，那么在同一个事务中的所有一致性读都读的是事务中第一个这样的读读到的快照；如果是READ COMMITTED，那么一个事务中的每一个一致性读都会读到它自己刷新的快照版本。Consistent read（一致性读）是READ COMMITTED和REPEATABLE READ隔离级别下普通SELECT语句默认的模式。一致性读不会给它所访问的表加任何形式的锁，因此其它事务可以同时并发的修改它们。2019-02-15 星期五 下午 22:30:30
2019-02-15 22:30:31.125[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [NN7xEA00333933]"}
2019-02-15 22:30:31.125[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [NN7xEA00333933]"}
2019-02-15 22:31:00.865[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  156 10、500台db，在最快时间之内重启

可以使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。 也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务器

2019-02-15 星期五 下午 22:31:00
2019-02-15 22:31:00.865[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:31:00.865[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  156 10、500台db，在最快时间之内重启

可以使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。 也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务器

2019-02-15 星期五 下午 22:31:00
2019-02-15 22:31:01.145[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [h8R4_a00634108]"}
2019-02-15 22:31:01.145[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [h8R4_a00634108]"}
2019-02-15 22:31:30.865[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  278 redis 分布式锁加锁正确姿势
可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：
第一个为key，我们使用key来当锁，因为key是唯一的。
第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。
第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；
第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。
第五个为time，与第四个参数相呼应，代表key的过期时间。
总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。
心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。
可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。
那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读【解锁代码-错误示例2】 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：
简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。2019-02-15 星期五 下午 22:31:30
2019-02-15 22:31:30.865[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:31:30.865[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  278 redis 分布式锁加锁正确姿势
可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：
第一个为key，我们使用key来当锁，因为key是唯一的。
第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。
第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；
第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。
第五个为time，与第四个参数相呼应，代表key的过期时间。
总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。
心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。
可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。
那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读【解锁代码-错误示例2】 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：
简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。2019-02-15 星期五 下午 22:31:30
2019-02-15 22:31:31.155[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [gX00933941]"}
2019-02-15 22:31:31.155[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [gX00933941]"}
2019-02-15 22:32:00.867[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  28mysql优化2019-02-15 星期五 下午 22:32:00
2019-02-15 22:32:00.867[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:32:00.867[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  28mysql优化2019-02-15 星期五 下午 22:32:00
2019-02-15 22:32:01.147[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [8sbPRA01234123]"}
2019-02-15 22:32:01.147[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [8sbPRA01234123]"}
2019-02-15 22:32:30.867[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  4集合框架1.java集合 集合的好处：1是可变容量 2.是可以存放不同类型的元素 3.增删改查算法优化 4.部分支持线程安全 Collections - List接口 -Map接口 -Queue接口 HashMap 源码解读  http://blog.csdn.net/mrb1289798400/article/details/76761423  第一层是数组，第二层是Node元素的单向链表 ConcurrentHashMap源码解读  http://www.importnew.com/16142.html 用到了segment，然后更重要的是在segment里面用到了重入锁，用读写所，在 读多写少的情况下，性能有显著提升，如果写多读少到不见得比synchrnized能好到哪里去。
List接口 ： 有序可重复 Arraylist 查快 增删改慢（用挪动其他元素） LinkedList 查比较慢 增删改快（不用挪动其他元素） Vector 3个 可以用List的特性做队列和栈容器 用addLast/First pollFirst/Last removeFirst/Last（）在在集合为空的时候会报空指针异常。 List接口里面有contains()方法，不要傻逼比再去用for循环一个元素一个元素在那里比较了了。 set接口 : 无序不可重复 HashSet treeSet 2个

Map 接口 ： treeMap HashMap HashTable 3个
也很重要，能装逼的类：ArrayQueue， Stack（Verctor子类） WeakHashMap() SortedMap() SortedSet() EnumHashMap EnumHashSet LinkedHashMap LinkedHashSet NavigableMap NavigableSet RegularEnumSet 还有并发包下面的集合
BlockingQueue BlockingDequeue ArrayBlockingQueue 还有SynchronousQueue （用在缓冲线程池里面） ConcurrentHashMap ConcurrentLinkedDequeue ConcurrentLinkedQueue ConcurrentSkipListMap ConcurrentSkipListSet CopyOnWriteArrayList CopyOnWriteArraySet DelayQueue2019-02-15 星期五 下午 22:32:30
2019-02-15 22:32:30.867[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:32:30.867[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  4集合框架1.java集合 集合的好处：1是可变容量 2.是可以存放不同类型的元素 3.增删改查算法优化 4.部分支持线程安全 Collections - List接口 -Map接口 -Queue接口 HashMap 源码解读  http://blog.csdn.net/mrb1289798400/article/details/76761423  第一层是数组，第二层是Node元素的单向链表 ConcurrentHashMap源码解读  http://www.importnew.com/16142.html 用到了segment，然后更重要的是在segment里面用到了重入锁，用读写所，在 读多写少的情况下，性能有显著提升，如果写多读少到不见得比synchrnized能好到哪里去。
List接口 ： 有序可重复 Arraylist 查快 增删改慢（用挪动其他元素） LinkedList 查比较慢 增删改快（不用挪动其他元素） Vector 3个 可以用List的特性做队列和栈容器 用addLast/First pollFirst/Last removeFirst/Last（）在在集合为空的时候会报空指针异常。 List接口里面有contains()方法，不要傻逼比再去用for循环一个元素一个元素在那里比较了了。 set接口 : 无序不可重复 HashSet treeSet 2个

Map 接口 ： treeMap HashMap HashTable 3个
也很重要，能装逼的类：ArrayQueue， Stack（Verctor子类） WeakHashMap() SortedMap() SortedSet() EnumHashMap EnumHashSet LinkedHashMap LinkedHashSet NavigableMap NavigableSet RegularEnumSet 还有并发包下面的集合
BlockingQueue BlockingDequeue ArrayBlockingQueue 还有SynchronousQueue （用在缓冲线程池里面） ConcurrentHashMap ConcurrentLinkedDequeue ConcurrentLinkedQueue ConcurrentSkipListMap ConcurrentSkipListSet CopyOnWriteArrayList CopyOnWriteArraySet DelayQueue2019-02-15 星期五 下午 22:32:30
2019-02-15 22:32:31.127[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [OM_OMA01534105]"}
2019-02-15 22:32:31.127[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [OM_OMA01534105]"}
2019-02-15 22:33:00.867[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  309  阿里巴巴Java开发手册  线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决系统资源不足的问题。如果不适用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者"过度切换的问题"。
应该将要并行运行的任务与运行机制解耦合。如果有很多任务，要为每个任务创建一个独立的线程所付出的代价太大了，可以使用线程池来解决这个问题。（摘自java核心技术）
可见线程池的重要性。
简单来说使用线程池有以下几个目的：
线程是稀缺资源，不能频繁的创建。
解耦作用；线程的创建于执行完全分开，方便维护。
应当将其放入一个池子中，可以给其他任务进行复用。2019-02-15 星期五 下午 22:33:00
2019-02-15 22:33:00.867[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:33:00.867[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  309  阿里巴巴Java开发手册  线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决系统资源不足的问题。如果不适用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者"过度切换的问题"。
应该将要并行运行的任务与运行机制解耦合。如果有很多任务，要为每个任务创建一个独立的线程所付出的代价太大了，可以使用线程池来解决这个问题。（摘自java核心技术）
可见线程池的重要性。
简单来说使用线程池有以下几个目的：
线程是稀缺资源，不能频繁的创建。
解耦作用；线程的创建于执行完全分开，方便维护。
应当将其放入一个池子中，可以给其他任务进行复用。2019-02-15 星期五 下午 22:33:00
2019-02-15 22:33:01.187[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [SWuYtA01838630]"}
2019-02-15 22:33:01.187[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [SWuYtA01838630]"}
2019-02-15 22:33:30.868[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  94 什么是乐观锁和悲观锁
乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。
悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。乐观锁是可以让你读，但是你先取版本号，update的时候版本号对不上,update语句后面的条件不满足，不让你update,这就是乐观锁；悲观锁，让你先取锁，拿到锁再来读，没拿到，读都不让你读，更不用说写了2019-02-15 星期五 下午 22:33:30
2019-02-15 22:33:30.868[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:33:30.868[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  94 什么是乐观锁和悲观锁
乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。
悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。乐观锁是可以让你读，但是你先取版本号，update的时候版本号对不上,update语句后面的条件不满足，不让你update,这就是乐观锁；悲观锁，让你先取锁，拿到锁再来读，没拿到，读都不让你读，更不用说写了2019-02-15 星期五 下午 22:33:30
2019-02-15 22:33:31.138[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [5hvzia02133951]"}
2019-02-15 22:33:31.138[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [5hvzia02133951]"}
2019-02-15 22:34:00.868[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  26springmvc的原理2019-02-15 星期五 下午 22:34:00
2019-02-15 22:34:00.868[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:34:00.868[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  26springmvc的原理2019-02-15 星期五 下午 22:34:00
2019-02-15 22:34:01.148[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [dwHqGA02434104]"}
2019-02-15 22:34:01.148[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [dwHqGA02434104]"}
2019-02-15 22:34:30.868[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  46过滤器中如何重新整理请求头，请求体中的数据 用ServletRequestWrapper,因为用了new来创建Wrapper实例，所以不会影响原始的request，和response2019-02-15 星期五 下午 22:34:30
2019-02-15 22:34:30.868[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:34:30.868[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  46过滤器中如何重新整理请求头，请求体中的数据 用ServletRequestWrapper,因为用了new来创建Wrapper实例，所以不会影响原始的request，和response2019-02-15 星期五 下午 22:34:30
2019-02-15 22:34:31.128[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [mew.la02733950]"}
2019-02-15 22:34:31.128[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [mew.la02733950]"}
2019-02-15 22:35:00.868[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  212 Spring的核心类有哪些，各有什么作用？

BeanFactory：产生一个新的实例，可以实现单例模式

BeanWrapper：提供统一的get及set方法

ApplicationContext:提供框架的实现，包括BeanFactory的所有功能
2019-02-15 星期五 下午 22:35:00
2019-02-15 22:35:00.868[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:35:00.868[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  212 Spring的核心类有哪些，各有什么作用？

BeanFactory：产生一个新的实例，可以实现单例模式

BeanWrapper：提供统一的get及set方法

ApplicationContext:提供框架的实现，包括BeanFactory的所有功能
2019-02-15 星期五 下午 22:35:00
2019-02-15 22:35:01.138[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [ybWLcA03033948]"}
2019-02-15 22:35:01.138[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [ybWLcA03033948]"}
2019-02-15 22:35:30.868[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  222  MySQL事务隔离级别的实现原理
  https://www.cnblogs.com/cjsblog/p/8365921.html2019-02-15 星期五 下午 22:35:30
2019-02-15 22:35:30.868[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:35:30.868[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  222  MySQL事务隔离级别的实现原理
  https://www.cnblogs.com/cjsblog/p/8365921.html2019-02-15 星期五 下午 22:35:30
2019-02-15 22:35:31.158[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [xYNquA03334102]"}
2019-02-15 22:35:31.158[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [xYNquA03334102]"}
2019-02-15 22:36:00.868[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  374 mysql  执行计划9个列  id select_type table type possible_keys key key_len ref rows Extra2019-02-15 星期五 下午 22:36:00
2019-02-15 22:36:00.868[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:36:00.868[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  374 mysql  执行计划9个列  id select_type table type possible_keys key key_len ref rows Extra2019-02-15 星期五 下午 22:36:00
2019-02-15 22:36:01.168[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [rnznFA03638630]"}
2019-02-15 22:36:01.168[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [rnznFA03638630]"}
2019-02-15 22:36:30.870[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2462019-02-15 星期五 下午 22:36:30
2019-02-15 22:36:30.870[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:36:30.870[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2462019-02-15 星期五 下午 22:36:30
2019-02-15 22:36:31.120[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [ErU0Ka03933114]"}
2019-02-15 22:36:31.120[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [ErU0Ka03933114]"}
2019-02-15 22:37:00.870[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  200  5. Memcache与Redis的区别都有哪些？

1)、存储方式

Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。

Redis有部份存在硬盘上，这样能保证数据的持久性。

2)、数据支持类型

Memcache对数据类型支持相对简单。

Redis有复杂的数据类型。

3)、使用底层模型不同

它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。

Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

4），value大小

redis最大可以达到1GB，而memcache只有1MB2019-02-15 星期五 下午 22:37:00
2019-02-15 22:37:00.870[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:37:00.870[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  200  5. Memcache与Redis的区别都有哪些？

1)、存储方式

Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。

Redis有部份存在硬盘上，这样能保证数据的持久性。

2)、数据支持类型

Memcache对数据类型支持相对简单。

Redis有复杂的数据类型。

3)、使用底层模型不同

它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。

Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

4），value大小

redis最大可以达到1GB，而memcache只有1MB2019-02-15 星期五 下午 22:37:00
2019-02-15 22:37:01.150[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [04233934]"}
2019-02-15 22:37:01.150[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [04233934]"}
2019-02-15 22:37:30.870[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  44门面模式如何实现 
  https://blog.csdn.net/xingjiarong/article/details/500661332019-02-15 星期五 下午 22:37:30
2019-02-15 22:37:30.870[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:37:30.870[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  44门面模式如何实现 
  https://blog.csdn.net/xingjiarong/article/details/500661332019-02-15 星期五 下午 22:37:30
2019-02-15 22:37:31.150[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [WVrIFa04533945]"}
2019-02-15 22:37:31.150[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [WVrIFa04533945]"}
2019-02-15 22:38:00.870[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  307  接口设计原则     高内聚 低耦合
好的接口应当满足设计模式六大原则, 很多设计模式, 框架都是基于高内聚低耦合这个出发点的.
1单一职责原则: 一个类只负责一个功能领域中的相应职责.
2开闭原则: 一个软件实体应当对扩展开放，对修改关闭.
3里氏代换原则: 所有引用基类（父类）的地方必须能透明地使用其子类的对象.
4依赖倒转原则: 抽象不应该依赖于细节, 细节应当依赖于抽象. 换言之, 要针对接口编程, 而不是针对实现编程.
5接口隔离原则: 使用多个专门的接口, 而不使用单一的总接口, 即客户端不应该依赖那些它不需要的接口.
6迪米特法则: 一个软件实体应当尽可能少地与其他实体发生相互作用, 例如外观模式, 对外暴露统一接口.2019-02-15 星期五 下午 22:38:00
2019-02-15 22:38:00.870[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:38:00.870[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  307  接口设计原则     高内聚 低耦合
好的接口应当满足设计模式六大原则, 很多设计模式, 框架都是基于高内聚低耦合这个出发点的.
1单一职责原则: 一个类只负责一个功能领域中的相应职责.
2开闭原则: 一个软件实体应当对扩展开放，对修改关闭.
3里氏代换原则: 所有引用基类（父类）的地方必须能透明地使用其子类的对象.
4依赖倒转原则: 抽象不应该依赖于细节, 细节应当依赖于抽象. 换言之, 要针对接口编程, 而不是针对实现编程.
5接口隔离原则: 使用多个专门的接口, 而不使用单一的总接口, 即客户端不应该依赖那些它不需要的接口.
6迪米特法则: 一个软件实体应当尽可能少地与其他实体发生相互作用, 例如外观模式, 对外暴露统一接口.2019-02-15 星期五 下午 22:38:00
2019-02-15 22:38:01.140[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [fCbZ404832066]"}
2019-02-15 22:38:01.140[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [fCbZ404832066]"}
2019-02-15 22:38:30.870[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  283 sun eclipse里面的merge tool 怎么使用 https://www.cnblogs.com/wavky/p/3504060.html  merge tool里面是可以左右复制代码的2019-02-15 星期五 下午 22:38:30
2019-02-15 22:38:30.870[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:38:30.870[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  283 sun eclipse里面的merge tool 怎么使用 https://www.cnblogs.com/wavky/p/3504060.html  merge tool里面是可以左右复制代码的2019-02-15 星期五 下午 22:38:30
2019-02-15 22:38:31.100[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [hvKWCa05134128]"}
2019-02-15 22:38:31.100[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [hvKWCa05134128]"}
2019-02-15 22:39:00.870[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  375 2019-02-15 星期五 下午 22:39:00
2019-02-15 22:39:00.870[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:39:00.870[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  375 2019-02-15 星期五 下午 22:39:00
2019-02-15 22:39:01.130[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [dnQbia05434128]"}
2019-02-15 22:39:01.130[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [dnQbia05434128]"}
2019-02-15 22:39:30.872[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  176 https://www.cnblogs.com/panxuejun/p/8630779.html     JVM调优总结（7）：调优方法2019-02-15 星期五 下午 22:39:30
2019-02-15 22:39:30.872[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:39:30.872[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  176 https://www.cnblogs.com/panxuejun/p/8630779.html     JVM调优总结（7）：调优方法2019-02-15 星期五 下午 22:39:30
2019-02-15 22:39:31.172[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [dO3SQA05734104]"}
2019-02-15 22:39:31.172[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [dO3SQA05734104]"}
2019-02-15 22:40:00.872[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  12mysql优化：sql优化；索引优化，执行计划，配置参数优化2019-02-15 星期五 下午 22:40:00
2019-02-15 22:40:00.872[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:40:00.872[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  12mysql优化：sql优化；索引优化，执行计划，配置参数优化2019-02-15 星期五 下午 22:40:00
2019-02-15 22:40:01.172[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [dx62506033936]"}
2019-02-15 22:40:01.172[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [dx62506033936]"}
2019-02-15 22:40:30.872[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  141 4.drop,delete与truncate的区别

drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始 delete删除表中数据，可以加where字句。

（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。

（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。

（3） 一般而言，drop > truncate > delete

（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view

（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。

（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。

（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。

（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚

（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。

（10） Truncate table 表名 速度快,而且效率高,因为:
truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。

（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。

（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。2019-02-15 星期五 下午 22:40:30
2019-02-15 22:40:30.872[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:40:30.872[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  141 4.drop,delete与truncate的区别

drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始 delete删除表中数据，可以加where字句。

（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。

（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。

（3） 一般而言，drop > truncate > delete

（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view

（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。

（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。

（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。

（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚

（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。

（10） Truncate table 表名 速度快,而且效率高,因为:
truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。

（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。

（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。2019-02-15 星期五 下午 22:40:30
2019-02-15 22:40:31.172[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [xQA_5a06333951]"}
2019-02-15 22:40:31.172[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [xQA_5a06333951]"}
2019-02-15 22:41:00.872[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  19zookepper2019-02-15 星期五 下午 22:41:00
2019-02-15 22:41:00.872[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:41:00.872[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  19zookepper2019-02-15 星期五 下午 22:41:00
2019-02-15 22:41:01.112[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [xmFA_a06634123]"}
2019-02-15 22:41:01.122[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [xmFA_a06634123]"}
2019-02-15 22:41:30.872[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  194 （9）数据分片模型

为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。

可以将每个节点看成都是独立的master，然后通过业务实现数据分片。

结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。2019-02-15 星期五 下午 22:41:30
2019-02-15 22:41:30.872[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:41:30.872[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  194 （9）数据分片模型

为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。

可以将每个节点看成都是独立的master，然后通过业务实现数据分片。

结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。2019-02-15 星期五 下午 22:41:30
2019-02-15 22:41:31.172[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [dhYmSa06934113]"}
2019-02-15 22:41:31.182[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [dhYmSa06934113]"}
2019-02-15 22:42:00.872[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  2802019-02-15 星期五 下午 22:42:00
2019-02-15 22:42:00.872[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:42:00.872[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  2802019-02-15 星期五 下午 22:42:00
2019-02-15 22:42:01.092[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [R3OmRa07234114]"}
2019-02-15 22:42:01.092[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [R3OmRa07234114]"}
2019-02-15 22:42:30.882[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  256 注意看 当你ll 的时候 linux 界面前方会出现-xrwxrwxwr  这种东西表示什么含义 drwxr-xr-x 2 root root 4096 06-29 14:30 Test 分段解释
d: 这个应该是目录吧 然后2 就是如果是文件夹表示子文件夹数个数. 文件硬链接数或目录子目录数  注意这里的或字
如果一个文件不是目录那么这一字段表示,这个文件所具有的硬链接数,即这个文件总共有多少个文件名.
rwxr-xr-x 这里是三段分开解释.r表示可读W表示可写x表示运行
rwx 表示文件所有者的权限
r-x 表示文件所有者所在组的权限
r-x 表示其他人的权限
第一个 root 用户
第二个 root 用户组
4096 是文件大小
06-29 14:30 是创建时间  不对 是最后更新时间吧 
test 文件名  2019-02-15 星期五 下午 22:42:30
2019-02-15 22:42:30.882[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:42:30.882[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  256 注意看 当你ll 的时候 linux 界面前方会出现-xrwxrwxwr  这种东西表示什么含义 drwxr-xr-x 2 root root 4096 06-29 14:30 Test 分段解释
d: 这个应该是目录吧 然后2 就是如果是文件夹表示子文件夹数个数. 文件硬链接数或目录子目录数  注意这里的或字
如果一个文件不是目录那么这一字段表示,这个文件所具有的硬链接数,即这个文件总共有多少个文件名.
rwxr-xr-x 这里是三段分开解释.r表示可读W表示可写x表示运行
rwx 表示文件所有者的权限
r-x 表示文件所有者所在组的权限
r-x 表示其他人的权限
第一个 root 用户
第二个 root 用户组
4096 是文件大小
06-29 14:30 是创建时间  不对 是最后更新时间吧 
test 文件名  2019-02-15 星期五 下午 22:42:30
2019-02-15 22:42:31.192[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [9OIDma07533955]"}
2019-02-15 22:42:31.192[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [9OIDma07533955]"}
2019-02-15 22:43:00.882[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  344 Arraylist与linkedlist的区别

a) 都是实现list接口的列表，arraylist是基于数组的数据结构，linkedlist是基于链表的数据结构，当获取特定元素时，ArrayList效率比较快，它通过数组下标即可获取，而linkedlist则需要移动指针。当存储元素与删除元素时linkedlist效率较快，只需要将指针移动指定位置增加或者删除即可，而arraylist需要移动数据。
--------------------- 
作者：白衣染霜华丶 
来源：CSDN 
原文：https://blog.csdn.net/zhangcc233/article/details/77847104 
版权声明：本文为博主原创文章，转载请附上博文链接！2019-02-15 星期五 下午 22:43:00
2019-02-15 22:43:00.882[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:43:00.882[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  344 Arraylist与linkedlist的区别

a) 都是实现list接口的列表，arraylist是基于数组的数据结构，linkedlist是基于链表的数据结构，当获取特定元素时，ArrayList效率比较快，它通过数组下标即可获取，而linkedlist则需要移动指针。当存储元素与删除元素时linkedlist效率较快，只需要将指针移动指定位置增加或者删除即可，而arraylist需要移动数据。
--------------------- 
作者：白衣染霜华丶 
来源：CSDN 
原文：https://blog.csdn.net/zhangcc233/article/details/77847104 
版权声明：本文为博主原创文章，转载请附上博文链接！2019-02-15 星期五 下午 22:43:00
2019-02-15 22:43:01.142[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [qooh407838651]"}
2019-02-15 22:43:01.142[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [qooh407838651]"}
2019-02-15 22:43:30.882[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3332019-02-15 星期五 下午 22:43:30
2019-02-15 22:43:30.882[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:43:30.882[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3332019-02-15 星期五 下午 22:43:30
2019-02-15 22:43:31.162[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [ZB9i608133933]"}
2019-02-15 22:43:31.162[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [ZB9i608133933]"}
2019-02-15 22:44:00.882[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  34ConcurrentHashMap实现原理2019-02-15 星期五 下午 22:44:00
2019-02-15 22:44:00.882[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:44:00.882[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  34ConcurrentHashMap实现原理2019-02-15 星期五 下午 22:44:00
2019-02-15 22:44:01.122[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [XI9HDa08438641]"}
2019-02-15 22:44:01.122[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [XI9HDa08438641]"}
2019-02-15 22:44:30.882[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  96  【深圳】【今日头条深圳研发中心】这真的是一封很认真的招聘贴~~~
liuyaqiu_150 · 3月之前 · 1595 次点击
我们是谁？ Developing a company as a product 是我们的理念 公司是我们团队的产品，员工是我们的用户 我们的工作是打造强大的效率工具和系统，支撑和推动公司更快更好地发展 业务范围涉及企业沟通工具、在线文档、共享日历、人力资源系统等 未来我们会推向市场，帮助更多优秀企业成长 甚至推动全球企业办公模式的变革
我们希望你来， 但我们希望吸引你来的不是免费的咖啡、漂亮的办公室和精美的下午茶 我们希望你和我们一样，最看重的是：『和优秀的人，做有挑战的事』 我们需要一群有才华、有志向的产品、技术、设计人才 能够像今日头条成立之初一样，从零开始打造一个团队
目前效率工程团队已经有数百人的规模 我们的管理理念是 【和优秀的人做有挑战的事，保持简单灵活的机制。提高透明度和信息分享效率，基于愿景目标自我驱动】 我们需要大量的leader、前后端高级工程师、客户端工程师、产品经理和UI设计师 如果你认同我们的价值观 如果你也期望加入这个推动字节跳动高速发展的团队 请和我们联系：liuyaqiu@bytedance.com
需求岗位： 服务端 /后台开发工程师 前端开发工程师 移动端（ Android 、 iOS ）开发工程师 产品经理 UI设计师
工作经验： 2 年以上
工作地点：深圳市南山区南海大道 2163 号来福士广场 15 层
简历投递邮箱：liuyaqiu@bytedance.com2019-02-15 星期五 下午 22:44:30
2019-02-15 22:44:30.882[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:44:30.882[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  96  【深圳】【今日头条深圳研发中心】这真的是一封很认真的招聘贴~~~
liuyaqiu_150 · 3月之前 · 1595 次点击
我们是谁？ Developing a company as a product 是我们的理念 公司是我们团队的产品，员工是我们的用户 我们的工作是打造强大的效率工具和系统，支撑和推动公司更快更好地发展 业务范围涉及企业沟通工具、在线文档、共享日历、人力资源系统等 未来我们会推向市场，帮助更多优秀企业成长 甚至推动全球企业办公模式的变革
我们希望你来， 但我们希望吸引你来的不是免费的咖啡、漂亮的办公室和精美的下午茶 我们希望你和我们一样，最看重的是：『和优秀的人，做有挑战的事』 我们需要一群有才华、有志向的产品、技术、设计人才 能够像今日头条成立之初一样，从零开始打造一个团队
目前效率工程团队已经有数百人的规模 我们的管理理念是 【和优秀的人做有挑战的事，保持简单灵活的机制。提高透明度和信息分享效率，基于愿景目标自我驱动】 我们需要大量的leader、前后端高级工程师、客户端工程师、产品经理和UI设计师 如果你认同我们的价值观 如果你也期望加入这个推动字节跳动高速发展的团队 请和我们联系：liuyaqiu@bytedance.com
需求岗位： 服务端 /后台开发工程师 前端开发工程师 移动端（ Android 、 iOS ）开发工程师 产品经理 UI设计师
工作经验： 2 年以上
工作地点：深圳市南山区南海大道 2163 号来福士广场 15 层
简历投递邮箱：liuyaqiu@bytedance.com2019-02-15 星期五 下午 22:44:30
2019-02-15 22:44:31.152[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [Rawgea08734122]"}
2019-02-15 22:44:31.152[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [Rawgea08734122]"}
2019-02-15 22:45:00.882[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  28mysql优化2019-02-15 星期五 下午 22:45:00
2019-02-15 22:45:00.882[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:45:00.882[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  28mysql优化2019-02-15 星期五 下午 22:45:00
2019-02-15 22:45:01.122[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [n4CwMa09033924]"}
2019-02-15 22:45:01.122[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [n4CwMa09033924]"}
2019-02-15 22:45:30.883[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  113 
volatile关键字解析
http://www.cnblogs.com/dolphin0520/p/3920373.html 这一篇对volatile的解读算挖到根了  
这里面引入了intel CPU 的一个高速缓存的概念
我的理解没错，这个高速缓存是属于CPU的一部分的。
https://jingyan.baidu.com/article/d169e1866d0e6d436711d87d.html
它如何保证它修饰的变量在线程之间的可见性。
缓存里面用的也是Lock机制，当一个线程修改该变量时候，其他等待若要读取该变量只能等待。知道update过程结束，锁释放。
那既然加了锁为什么还是不能解决线程安全性呢，因为这个锁控制的力度太细并不是在业务代码上保证原子性。
比如i++,这个命令的操作是分两部完成的，先读取i的值，然后加1，可是中间有可能被另一个线程干扰。
你刚读完值，别的线程已经将该值修改了，你再加1并不是在新值上面加，为什么呢，如果你重新读取这个值你可以读到update 后的值，问题是你以及你给读过了，
不可能重复读第二回。
再举个例子，火车票多线程出售，if(count>0){count--;} if判断跟后面的count-- 操作有可能被截胡。被干扰。count被其他线程修改了。2019-02-15 星期五 下午 22:45:30
2019-02-15 22:45:30.883[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:45:30.883[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  113 
volatile关键字解析
http://www.cnblogs.com/dolphin0520/p/3920373.html 这一篇对volatile的解读算挖到根了  
这里面引入了intel CPU 的一个高速缓存的概念
我的理解没错，这个高速缓存是属于CPU的一部分的。
https://jingyan.baidu.com/article/d169e1866d0e6d436711d87d.html
它如何保证它修饰的变量在线程之间的可见性。
缓存里面用的也是Lock机制，当一个线程修改该变量时候，其他等待若要读取该变量只能等待。知道update过程结束，锁释放。
那既然加了锁为什么还是不能解决线程安全性呢，因为这个锁控制的力度太细并不是在业务代码上保证原子性。
比如i++,这个命令的操作是分两部完成的，先读取i的值，然后加1，可是中间有可能被另一个线程干扰。
你刚读完值，别的线程已经将该值修改了，你再加1并不是在新值上面加，为什么呢，如果你重新读取这个值你可以读到update 后的值，问题是你以及你给读过了，
不可能重复读第二回。
再举个例子，火车票多线程出售，if(count>0){count--;} if判断跟后面的count-- 操作有可能被截胡。被干扰。count被其他线程修改了。2019-02-15 星期五 下午 22:45:30
2019-02-15 22:45:31.203[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [7h2MQA09334100]"}
2019-02-15 22:45:31.203[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [7h2MQA09334100]"}
2019-02-15 22:46:00.883[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  3342019-02-15 星期五 下午 22:46:00
2019-02-15 22:46:00.883[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:46:00.883[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  3342019-02-15 星期五 下午 22:46:00
2019-02-15 22:46:01.183[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [xB6Npa09634121]"}
2019-02-15 22:46:01.183[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [xB6Npa09634121]"}
2019-02-15 22:46:30.113[INFO ][com.hl.Hao123Application ] -----------{"access_token":"18_UGwOL_FJFrNlfiRkHxZ1Oxe8VABvrrYGgGGRaqpB39VWf2BCvZWgEjo6V8qyK1NJUQiGfhBKyMsYBt8jImjTapKIIuea77Qnah5XFmhUw26KNbuG6ipWhMbxbg4cXZoQaMEGGVJvDNAOL30APKAbADAYTJ","expires_in":7200}
2019-02-15 22:46:30.113[INFO ][com.hl.Hao123Application ] 更新access_token, 18_UGwOL_FJFrNlfiRkHxZ1Oxe8VABvrrYGgGGRaqpB39VWf2BCvZWgEjo6V8qyK1NJUQiGfhBKyMsYBt8jImjTapKIIuea77Qnah5XFmhUw26KNbuG6ipWhMbxbg4cXZoQaMEGGVJvDNAOL30APKAbADAYTJ
2019-02-15 22:46:30.883[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  222  MySQL事务隔离级别的实现原理
  https://www.cnblogs.com/cjsblog/p/8365921.html2019-02-15 星期五 下午 22:46:30
2019-02-15 22:46:30.883[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:46:30.883[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  222  MySQL事务隔离级别的实现原理
  https://www.cnblogs.com/cjsblog/p/8365921.html2019-02-15 星期五 下午 22:46:30
2019-02-15 22:46:31.173[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [fQVFAA09933948]"}
2019-02-15 22:46:31.173[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [fQVFAA09933948]"}
2019-02-15 22:47:00.884[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  301  乞丐不好意思要饭，结果饿死了；商户不好意思要账，结果自己门店关了；不好意思向心仪的人表白，结果她跟别人走了；不好意思让客户签单，结果客户在别人那里成交了；不要让不好意思成为你人生的绊脚石，凡是让你觉得不好意思的都要马上去做，否则时间会把你的勇气完全消磨掉。说句实在的，我想要赞！2019-02-15 星期五 下午 22:47:00
2019-02-15 22:47:00.884[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:47:00.884[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  301  乞丐不好意思要饭，结果饿死了；商户不好意思要账，结果自己门店关了；不好意思向心仪的人表白，结果她跟别人走了；不好意思让客户签单，结果客户在别人那里成交了；不要让不好意思成为你人生的绊脚石，凡是让你觉得不好意思的都要马上去做，否则时间会把你的勇气完全消磨掉。说句实在的，我想要赞！2019-02-15 星期五 下午 22:47:00
2019-02-15 22:47:01.154[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [37haMA00234107]"}
2019-02-15 22:47:01.154[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [37haMA00234107]"}
2019-02-15 22:47:30.884[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  11mysql隔离级别  读未提交 读已提交  可重复读(锁行)  串行化(锁表)  1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

　　2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。（事务 A在这一次事务里面多次读了同一批数据）
　　3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
　　小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表事务隔离级别 	脏读 	不可重复读 	幻读
读未提交（read-uncommitted） 	是 	是 	是
不可重复读（read-committed） 	否 	是 	是
可重复读（repeatable-read） 	否 	否 	是
串行化（serializable） 	否 	否 	否2019-02-15 星期五 下午 22:47:30
2019-02-15 22:47:30.884[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:47:30.884[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  11mysql隔离级别  读未提交 读已提交  可重复读(锁行)  串行化(锁表)  1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

　　2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。（事务 A在这一次事务里面多次读了同一批数据）
　　3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
　　小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表事务隔离级别 	脏读 	不可重复读 	幻读
读未提交（read-uncommitted） 	是 	是 	是
不可重复读（read-committed） 	否 	是 	是
可重复读（repeatable-read） 	否 	否 	是
串行化（serializable） 	否 	否 	否2019-02-15 星期五 下午 22:47:30
2019-02-15 22:47:31.154[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [Bq.mDa00533950]"}
2019-02-15 22:47:31.154[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [Bq.mDa00533950]"}
2019-02-15 22:48:00.885[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  210 spring支持构造器注入和setter方法注入
接口注入    构造器注入，通过 <constructor-arg> 元素完成注入
    setter方法注入， 通过<property> 元素完成注入【开发中常用方式】 2019-02-15 星期五 下午 22:48:00
2019-02-15 22:48:00.885[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:48:00.885[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  210 spring支持构造器注入和setter方法注入
接口注入    构造器注入，通过 <constructor-arg> 元素完成注入
    setter方法注入， 通过<property> 元素完成注入【开发中常用方式】 2019-02-15 星期五 下午 22:48:00
2019-02-15 22:48:01.175[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [WgKLhA00833116]"}
2019-02-15 22:48:01.175[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [WgKLhA00833116]"}
2019-02-15 22:48:30.887[INFO ][com.hl.Hao123Application ] 22222222222222, 20-  148 (3)、各种不同 mysql 版本的Innodb的改进
复制代码

MySQL5.6 下 Innodb 引擎的主要改进：
（ 1） online DDL
（ 2） memcached NoSQL 接口
（ 3） transportable tablespace（ alter table discard/import tablespace）
（ 4） MySQL 正常关闭时，可以 dump 出 buffer pool 的（ space， page_no），重启时 reload，加快预热速度
（ 5） 索引和表的统计信息持久化到 mysql.innodb_table_stats 和mysql.innodb_index_stats，可提供稳定的执行计划
（ 6） Compressed row format 支持压缩表

MySQL 5.7 innodb 引擎主要改进
（ 1） 修改 varchar 字段长度有时可以使用 online DDL
（ 2） Buffer pool 支持在线改变大小
（ 3） Buffer pool 支持导出部分比例
（ 4） 支持新建 innodb tablespace，并可以在其中创建多张表
（ 5） 磁盘临时表采用 innodb 存储，并且存储在 innodb temp tablespace 里面，以前是 myisam 存储
（ 6） 透明表空间压缩功能2019-02-15 星期五 下午 22:48:30
2019-02-15 22:48:30.887[INFO ][com.hl.Hao123Application ] 11111111111111, {"touser":"orR4l1sSeLPOQRpLkCC57sBU1fE0","text":"{\"content\":\"123\"}","msgtype":"text"}
2019-02-15 22:48:30.887[INFO ][com.hl.Hao123Application ] 发送的内容,发送不易，且读且珍惜, 20-  148 (3)、各种不同 mysql 版本的Innodb的改进
复制代码

MySQL5.6 下 Innodb 引擎的主要改进：
（ 1） online DDL
（ 2） memcached NoSQL 接口
（ 3） transportable tablespace（ alter table discard/import tablespace）
（ 4） MySQL 正常关闭时，可以 dump 出 buffer pool 的（ space， page_no），重启时 reload，加快预热速度
（ 5） 索引和表的统计信息持久化到 mysql.innodb_table_stats 和mysql.innodb_index_stats，可提供稳定的执行计划
（ 6） Compressed row format 支持压缩表

MySQL 5.7 innodb 引擎主要改进
（ 1） 修改 varchar 字段长度有时可以使用 online DDL
（ 2） Buffer pool 支持在线改变大小
（ 3） Buffer pool 支持导出部分比例
（ 4） 支持新建 innodb tablespace，并可以在其中创建多张表
（ 5） 磁盘临时表采用 innodb 存储，并且存储在 innodb temp tablespace 里面，以前是 myisam 存储
（ 6） 透明表空间压缩功能2019-02-15 星期五 下午 22:48:30
2019-02-15 22:48:31.177[INFO ][com.hl.Hao123Application ] 2222222222result2222, {"errcode":45015,"errmsg":"response out of time limit or subscription is canceled hint: [mRrtCA01134125]"}
2019-02-15 22:48:31.177[INFO ][com.hl.Hao123Application ] retMap, {"errcode":45015.0,"errmsg":"response out of time limit or subscription is canceled hint: [mRrtCA01134125]"}
