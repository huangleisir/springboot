<!DOCTYPE HTML>
<html>
<head>
<title>我的123网址之家</title>
<script type="text/javascript" src="./jquery-3.3.1.js"></script>
<meta charset="UTF-8" />
<meta name="viewport"
	content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<link rel="shortcut icon" href="Z.ico" type="image/x-icon" />
<style type="text/css">

h3 {
	display: inline;
	margin-right: 30px;
	cursor: pointer;
	color: dodgerblue;
	transition: 0.1s;
}

a:hover {
	color: #FFBB00;
}

body {
	background-color: #e0ffff;
}

span {
	font-family: "微软雅黑";
	font-weight: bold;
}
</style>

<script type="text/javascript">
function func(value){
	$.ajax({
		  type: 'POST',
		  url: '/skip/'+value+'?name='+value,
		  data:{'name':value,'data':'123'},
		  dataType:'json',
		  success:function(data){
			  window.open(data.url);
		  }
		});
}
function init(){
	$.ajax({
		  type: 'POST',
		  url: '/skip/weather?name=weather',
		  data:{'name':'weather'},
		  dataType:'json',
		  success:function(data){
			  $("#bj").html(data.resultMap.citynm+'  		     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    '+data.resultMap.weather
			  +'  		     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     '+data.resultMap.temperature_curr+'   		     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    '
					  +data.resultMap.temperature + '  &nbsp;&nbsp;&nbsp;    '
					  +data.resultMap.days + '  		     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    '+data.resultMap.week);
			  
		  }
		});
	
	
	$.ajax({
		  type: 'POST',
		  url: '/skip/token?name=token',
		  data:{'name':'token'},
		  dataType:'json',
		  success:function(data){
			  $("#token").css("width",data.url.length*8+"px");
			  $("#token_time").css("width",data.token_time.length*8+"px");
			  $("#token").val(data.url);
			  $("#token_time").html(data.token_time);
			  
		  }
	});

    $.ajax({
        type: 'GET',
        url: '/home',
        data:{'name':'token'},
        dataType:'json',
        success:function(data){
            debugger;
            for (var i = 0; i < data.length; i++) {
                $("#apollo").append("<h2><a href='"+ data[i].url +"'>" + data[i].name  +"</a></h2>");
            }


        }
    });
	
}
</script>

</head>

<body style="background-image:url(bg_right.jpg)" onload="init()">
	<label></label>
	<span id="bj"></span>  
	<br/>   <input id="token" style="color:orange;" ></input>
	<br/>   <span id="token_time"  ></span>
	<br />
	<div id="apollo">
	</div>

	<h3 onclick="func('wangyi')">
		<a><span>网易</span></a>
	</h3>
	<h3 onclick="func('baidu')">
		<a>百度</a>
	</h3>
	<h3 onclick="func('qq')">
		<a>腾讯</a>
	</h3>
	<h3 onclick="func('douyu')">
		<a>斗鱼</a>
	</h3>
	<h3 onclick="func('iqiyi')">
		<a>爱奇艺</a>
	</h3>
	<h3 onclick="func('youku')">
		<a>优酷</a>
	</h3>
	<h3 onclick="func('imooc')">
		<a>慕课</a>
	</h3>
	<h3 onclick="func('panda')">
		<a>熊猫</a>
	</h3>
	<h3 onclick="func('yizhibo')">
		<a>一直播</a>
	</h3>
	<h3 onclick="func('38hao')">
		<a>38号</a>
	</h3>
	<h3 onclick="func('38haoBigFish')">
		<a>38号-大鱼</a>
	</h3>
	<h3 onclick="func('lilaoshuBigFish')">
		<a>李老鼠说车-大鱼</a>
	</h3>
	<h3 onclick="func('beitaiYouku')">
		<a>备胎说车-优酷</a>
	</h3>

	<h3 onclick="func('taobao')">
		<a>淘宝</a>
	</h3>
	<h3 onclick="func('tmall')">
		<a>天猫</a>
	</h3>
	<h3 onclick="func('jd')">
		<a>京东</a>
	</h3>
	<h3 onclick="func('cto51')">
		<a>51CTO</a>
	</h3>
	<h3 onclick="func('bjsxt')">
		<a>北京尚学堂</a>
	</h3>
	<h3 onclick="func('study163')">
		<a>网易云课堂</a>
	</h3>
	<hr>
	<h3 onclick="func('github')">
		<a>github</a>
	</h3>
	<h3 onclick="func('coding')">
		<a>coding</a>
	</h3>
	<h3 onclick="func('gitee')">
		<a>gitee</a>
	</h3>
	<h3 onclick="func('usstock')">
		<a>美道</a>
	</h3>
	<h3 onclick="func('ximalaya')">
		<a>喜马拉雅</a>
	</h3>
	<h3 onclick="func('qingting')">
		<a>蜻蜓</a>
	</h3>
	<hr />
	<h3 onclick="func('lagou')">
		<a>拉勾</a>
	</h3>
	<h3 onclick="func('recaihotline')">
		<a>人才热线</a>
	</h3>
	<h3 onclick="func('autoHome')">
		<a>汽车之家</a>
	</h3>
	<h3 onclick="func('bilibili')">
		<a>哔哩哔哩动画</a>
	</h3>
	<h3 onclick="func('tianya')">
		<a>天涯</a>
	</h3>
	<h3 onclick="func('kaikeba')">
		<a>开课吧</a>
	</h3>

	</h3>
	<h3 onclick="func('xiaozhupeiqi')">
		<a>小猪佩奇</a>
	</h3>

	<hr />

	<h3 style="color: red;" onclick="func('zealerChina')">
		<a>zealerChina</a>
	</h3>
	<h3 style="color: red;" onclick="func('cheshier')">
		<a>车事儿</a>
	</h3>
	<h3 style="color: red;" onclick="func('baihuaqiche')">
		<a>白话汽车</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="http://i.youku.com/i/UMTcwODYxMDY1Mg==/videos?spm=a2hzp.8244740.0.0" >
			萝卜报告-大鱼号</a>
	</h3>
	<hr />

	<h3 style="color: red;" onclick="func('gitchat')">
		<a>gitchat</a>
	</h3>
	<h3 style="color: red;" onclick="func('ershouchezhishidajiangtang')">
		<a>二手车知识大讲堂</a>
	</h3>
	<h3 style="color: red;" onclick="func('caijinglangxianping')">
		<a>财经郎咸平</a>
	</h3>
	<h3 style="color: red;" onclick="func('zhangxiaoxiangMultiThread')">
		<a>张孝祥多线程</a>
	</h3>
	<h3 style="color: red;" >
		<a href="https://www.iqiyi.com/v_19rsbzc8m8.html?spm=a2h0k.11417342.soresults.dtitle#curid=3129156300_d25f474353e41fa1b88b58a051df588c">
			xfun吃货俱乐部</a>
	</h3>

	<hr />

	<h3 style="color: red;" onclick="func('springDotIO')">
		<a>spring.io</a>
	</h3>
	<h3 style="color: red;" onclick="func('startSpringIO')">
		<a>start.spring.io</a>
	</h3>
	<h3 style="color: red;" onclick="func('redisDotIO')">
		<a>redis.io</a>
	</h3>
	<h3 style="color: purple;" onclick="func('dubboOfficial')">
		<a>dubboOfficial</a>
	</h3>
	<h3 style="color: purple;" onclick="func('mybatis')">
		<a>mybatis3</a>
	</h3>
	<h3 style="color: purple;" onclick="func('zk')">
		<a>zookeeper</a>
	</h3>
	<hr>
	<h3 style="color: blue;" onclick="func('pconline')">
		<a>太平洋电脑</a>
	</h3>
	<h3 style="color: blue;" onclick="func('xinwen1plus1')">
		<a>新闻1+1</a>
	</h3>
	<h3 style="color: blue;" onclick="func('dangdang')">
		<a>当当</a>
	</h3>
	<h3 style="color: blue;" onclick="func('wangzherongyao')">
		<a>王者荣耀职业赛</a>
	</h3>
	<h3 style="color: blue;" onclick="func('yingxionglianmeng')">
		<a>英雄联盟职业赛</a>
	</h3>
	<h3 style="color: blue;" onclick="func('ceshihao')">
		<a>测试号</a>
	</h3>
	<h3 style="color: blue;" onclick="func('sina')">
		<a>新浪</a>
	</h3>
	<h3 style="color: blue;" onclick="func('yeshengchufang')">
		<a>野生厨房</a>
	</h3>
	<h3 style="color: blue;" onclick="func('daVkai8')">
		<a>大V开8</a>
	</h3>
	<h3 style="color: blue;" onclick="func('toutiao')">
		<a>今日头条</a>
	</h3>
	<h3 style="color: blue;" onclick="func('wechatDevDoc')">
		<a>微信支付开发文档</a>
	</h3>
	<h3 style="color: blue;" onclick="func('aliPayDevDoc')">
		<a>支付宝支付开发文档</a>
	</h3>
	<h3 style="color: blue;" onclick="func('shenzhenzhujianju')">
		<a>深圳住建局</a>
	</h3>
	<h3 style="color: blue;" onclick="func('fandengdushu')">
		<a>樊登读书会</a>
	</h3>
	<h3 style="color: blue;" onclick="func('huangyeshengyan')">
		<a>荒野盛宴</a>
	</h3>
	<h3 style="color: blue;"  >
		<a  href="http://i.youku.com/u/UMjMwMTM1MDQ=?spm=a2h0k.11417342.soresults.dtitle" >moto晓峰</a>
	</h3>
	<h3 style="color: blue;"  >
		<a  href="http://i.youku.com/u/UNDY3MzY3ODY1Mg==?spm=a2h0k.11417342.soresults.dtitle" >汉咖-大鱼号</a>
	</h3>
	<h3>
		<a  href="https://www.iqiyi.com/v_19rshd1b90.html#curid=2384979800_ab69094c80c037df58f8c11c6954d4a1" >一席演讲</a>
	</h3>
	<h3 style="color: blue;"  >
		<a  href="https://www.iqiyi.com/v_19rs9wb7ww.html" >金口玉阆</a>
	</h3>
	<h3 style="color: blue;"  >
		<a  href="https://v.youku.com/v_show/id_XMjg0NDM3MjA1Mg==.html?spm=a2ha1.12492923.m_7951_c_16165.d_3&s=79efbfbd5a5d36efbfbd&scm=20140719.rcmd.7951.show_79efbfbd5a5d36efbfbd" >
		正北偏北</a>
	</h3>
	<h3 style="color: blue;"  >
		<a  href="https://v.youku.com/v_show/id_XMzc3ODAzNTY2MA==.html?spm=a2h0j.11185381.listitem_page1.5!39~A&&s=efbfbdefbfbd563fefbf" >
		天才简史</a>
	</h3>
	<h3 style="color: blue;"  >
		<a  href="https://v.youku.com/v_show/id_XNDI0MzUwMTYyMA==.html?spm=a2h0k.11417342.soresults.dtitle" >
		牛叔说电影</a>
	</h3>
	
	<h3 style="color: orange;"  >
		<a  href="https://v.youku.com/v_show/id_XNDI2MDIzNDAzNg==.html?spm=a2ha1.12538519.m_5815_c_12873.d_1&scm=20140719.rcmd.5815.video_XNDI2MDIzNDAzNg%3D%3D" >
		看财经</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="https://v.youku.com/v_show/id_XNDI1Mzk4NDg2OA==.html?spm=a2h0j.11185381.listitem_page1.5!4~A" >
		胡观正经</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="https://v.youku.com/v_show/id_XNDI2MTQ4NzAzMg==.html?spm=a2ha1.12538519.m_5813_c_12871.d_4&scm=20140719.rcmd.5813.video_XNDI2MTQ4NzAzMg%3D%3D" >
		金融民工</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="http://i.youku.com/u/UNDY3MzY3ODY1Mg==?spm=a2h0k.11417342.soresults.dtitle" >
		汉咖</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="http://www.iqiyi.com/w_19s2gzr5tt.html" >
		威尼斯-看了还想看可惜不是会员看FHD</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="https://v.youku.com/v_show/id_XODk4NTEzMTEy.html?spm=a2h0j.11185381.listitem_page1.5!5~A&&s=7f7a1ca0ace311e4b2ad" >
		武汉食堂</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="http://www.iqiyi.com/u/1599674333" >
		kanqo</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="https://www.iqiyi.com/v_19rs6qvi88.html" >
			左右视频</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="https://v.youku.com/v_show/id_XMTI2MDk4MTA5Ng==.html" >
			局部</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="https://v.youku.com/v_show/id_XMzUyMzk3OTk4NA==.html?spm=a2h0j.11185381.mdlikeshow.1~3~5~5~A" >
			局部第二季</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="https://www.iqiyi.com/v_19rt1zy9io.html" >
			迷彩虎</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="https://so.iqiyi.com/so/q_%E8%B6%8A%E7%8B%B1?source=input&sr=17097170544" >
			美剧越狱</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="http://bbs.tianya.cn/post-no20-685487-3.shtml" >
			天涯贴</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="https://www.iqiyi.com/v_19rtzoywa4.html" >
			军武次位面</a>
	</h3>
	<h3 style="color: orange;"  >
		<a  href="https://v.youku.com/v_show/id_XMzYzNDM0MDc5Mg==.html?spm=a2h0j.11185381.listitem_page1.5!3~A" >
			军武大本营</a>
	</h3>

	<h3 style="color: blue;"  >
		<a  href="https://note.youdao.com/web/#/file/recent" >
			有道云笔记</a>
	</h3>
	<h3 style="color: red;"  >
		<a  href="https://gitbook.cn/books/5d9054898e7d0276851ea85f/index.html" >
			好用到爆的 Java 代码技巧</a>
	</h3>
	<h3 style="color: red;"  >
		<a  href="https://gitbook.cn/books/5d9054898e7d0276851ea85f/index.html" >
			好用到爆的 Java 代码技巧</a>
	</h3>
	<h3 style="color: red;"  >
		<a  href="https://gitbook.cn/gitchat/activity/5d7afa5d73ab6550d11f4b19" >
			代码优雅之道：消除代码中的“坏味道”</a>
	</h3>
	<h3 style="color: red;"  >
		<a  href="https://gitbook.cn/gitchat/activity/5d8ed1d5f261bd7c2b9e4ba1" >
			微信小程序开发打车软件</a>
	</h3>
	<h3 style="color: red;"  >
		<a  href="https://gitbook.cn/gitchat/activity/5da4155ffce8c43ccf523a94" >
			混乱代码的血泪史，如何写出整洁、高质量、可测试的代码</a>
	</h3>
	<h3 style="color: red;"  >
		<a  href="https://gitbook.cn/books/5cac5f4b7eaf264c97446356/index.html" >
			gitchat-flink入门好教程</a>
	</h3>
	<h2 style="color: red;"  >
		<a  href="https://cloud.tencent.com/developer/labs/gallery" >
			腾讯实验室-203.1k</a>
	</h2>
	<hr>
	<div title="Java中CAS原理详解
在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁
锁机制存在以下问题：
（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。
（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。
（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。
volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。
独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。
一、什么是CAS
CAS,compare and swap的缩写，中文翻译成比较并交换。
我们都知道，在java语言之前，并发就已经广泛存在并在服务器领域得到了大量的应用。所以硬件厂商老早就在芯片中加入了大量直至并发操作的原语，从而在硬件层面提升效率。在intel的CPU中，使用cmpxchg指令。
在Java发展初期，java语言是不能够利用硬件提供的这些便利来提升系统的性能的。而随着java不断的发展,Java本地方法(JNI)的出现，使得java程序越过JVM直接调用本地方法提供了一种便捷的方式，因而java在并发的手段上也多了起来。而在Doug Lea提供的cucurenct包中，CAS理论是它实现整个java包的基石。
CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”
通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。
类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。
二、CAS的目的
利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。
三、CAS存在的问题
CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作
1.  ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。
从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
关于ABA问题参考文档: http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html
2. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。
3. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。
四、concurrent包的实现
由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现在有了下面四种方式：
1. A线程写volatile变量，随后B线程读这个volatile变量。
2. A线程写volatile变量，随后B线程用CAS更新这个volatile变量。
3. A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。
4. A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。
Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：
1. 首先，声明共享变量为volatile；
2. 然后，使用CAS的原子条件更新来实现线程之间的同步；
3. 同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。
AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下："> CAS </div>

	<div title="Spring Boot继承了Spring的优点，并新增了一些新功能和特性
		（0）从字面理解，Boot是引导的意思，因此SpringBoot帮助开发者快速搭建Spring框架，Spring 项目引导页面可以在几秒构建一个项目
		（1）Spring Boot 内置了多种种强大的测试框架，只需要在项目中引入spring-boot-start-test依赖包
		（2）Spring Boot 的自动配置让配置变简单；
		（3）SpringBoot的起步依赖让依赖管理更加简单；
		（4）Spring Boot Actuator对应用系统监控的集成功能；
		（5）现在spring boot和spring cloud是现在java开发框架的主流了

		Spring Boot提供了一种新的编程范式，能在最小的阻力下开发Spring应用程序。有了它，你可以更加敏捷地开发Spring应用程序，专注于应用程序的功能，不用在Spring的配置上多花功夫，甚至完全不用配置。实际上，Spring Boot的一项重要工作就是让Spring不再成为你成功路上的绊脚石。 ——《SpringBoot实战》
		------
		@SpringBootApplication实际是@SpringBootConfiguration，@EnableAutoConfiguration以及@ComponentScan的组合
		@SpringBootConfiguration而@Configuration有相同的作用，配备了该注解的类就能够以JavaConfig的方式完成一些配置，可以不再使用XML配置
		@ComponentScan注解完成的是自动扫描的功能，相当于Spring XML配置文件中的">springboot
	</div>
	<div title="SpringCloud面试题(一)
大家好，我是酷酷的韩~下面提供一些整理的springcloud面试题

一.微服务的优点缺点?说下开发项目中遇到的坑?

优点:

1.每个服务直接足够内聚，代码容易理解
2.开发效率高，一个服务只做一件事，适合小团队开发
3.松耦合，有功能意义的服务。
4.可以用不同语言开发，面向接口编程。
5.易于第三方集成
6.微服务只是业务逻辑的代码，不会和HTML,CSS或其他界面结合.
7.可以灵活搭配，连接公共库/连接独立库

缺点:
1.分布式系统的责任性
2.多服务运维难度加大。
3.系统部署依赖，服务间通信成本，数据一致性，系统集成测试，性能监控。

二.什么是springcloud？
Spring cloud流应用程序启动器是基于Spring Boot的Spring集成应用程序，提供与外部系统的集成。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序

三.spring cloud 和dubbo区别?

1.服务调用方式 dubbo是RPC springcloud Rest Api
2.注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper
3.服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。

四.REST 和RPC对比

1.RPC主要的缺陷是服务提供方和调用方式之间的依赖太强，需要对每一个微服务进行接口的定义，并通过持续继承发布，严格版本控制才不会出现冲突。
2.REST是轻量级的接口，服务的提供和调用不存在代码之间的耦合，只需要一个约定进行规范。

五.你所知道的微服务技术栈？

维度(springcloud)
服务开发：springboot spring springmvc
服务配置与管理:Netfix公司的Archaiusm ,阿里的Diamond
服务注册与发现:Eureka,Zookeeper
服务调用:Rest RPC gRpc
服务熔断器:Hystrix
服务负载均衡:Ribbon Nginx
服务接口调用:Fegin
消息队列:Kafka Rabbitmq activemq
服务配置中心管理:SpringCloudConfig
服务路由（API网关）Zuul
事件消息总线:SpringCloud Bus

六.负载均衡的意义是什么?

在计算中，负载均衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载均衡旨在优化资源使用，最大吞吐量，最小响应时间并避免任何单一资源的过载。使用多个组件进行负载均衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务进程。

七.微服务之间是如何独立通讯的?

1.远程调用，比如feign调用，直接通过远程过程调用来访问别的service。
2.消息中间件

八.springcloud如何实现服务的注册?

1.服务发布时，指定对应的服务名,将服务注册到 注册中心(eureka zookeeper)
2.注册中心加@EnableEurekaServer,服务用@EnableDiscoveryClient，然后用ribbon或feign进行服务直接的调用发现。

九.Eureka和Zookeeper区别

1.Eureka取CAP的AP，注重可用性，Zookeeper取CAP的CP注重
一致性。
2.Zookeeper在选举期间注册服务瘫痪，虽然服务最终会恢复，但选举期间不可用。
3.eureka的自我保护机制，会导致一个结果就是不会再从注册列表移除因长时间没收到心跳而过期的服务。依然能接受新服务的注册和查询请求，但不会被同步到其他节点。不会服务瘫痪。
4.Zookeeper有Leader和Follower角色，Eureka各个节点平等。
5.Zookeeper采用过半数存活原则，Eureka采用自我保护机制解决分区问题。
6.eureka本质是一个工程，Zookeeper只是一个进程。

十.eureka自我保护机制是什么?
1.当Eureka Server 节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式，保护注册信息，不再删除注册数据，故障恢复时，自动退出自我保护模式。

十一.什么是服务熔断？什么是服务降级?
服务直接的调用，比如在高并发情况下出现进程阻塞，导致当前线程不可用，慢慢的全部线程阻塞，导致服务器雪崩。
服务熔断：相当于保险丝，出现某个异常，直接熔断整个服务，而不是一直等到服务超时。通过维护一个自己的线程池，当线程到达阈值的时候就启动服务降级，如果其他请求继续访问就直接返回fallback的默认值。

十二.什么是Ribbon？
ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。feign默认集成了ribbon。

十三.什么是feigin？它的优点是什么？
1.feign采用的是基于接口的注解
2.feign整合了ribbon，具有负载均衡的能力
3.整合了Hystrix，具有熔断的能力

使用:
1.添加pom依赖。
2.启动类添加@EnableFeignClients
3.定义一个接口@FeignClient(name=“xxx”)指定调用哪个服务

十四.Ribbon和Feign的区别？
1.Ribbon都是调用其他服务的，但方式不同。
2.启动类注解不同，Ribbon是@RibbonClient feign的是@EnableFeignClients
3.服务指定的位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。
4.调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。Feign需要将调用的方法定义成抽象方法即可。

十五.什么是Spring Cloud Bus?
spring cloud bus 将分布式的节点用轻量的消息代理连接起来，它可以用于广播配置文件的更改或者服务直接的通讯，也可用于监控。
如果修改了配置文件，发送一次请求，所有的客户端便会重新读取配置文件。
使用:
1.添加依赖
2.配置rabbimq

十六.springcloud断路器作用?
当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）
断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务
半开:短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭
关闭：当服务一直处于正常状态 能正常调用

十七.什么是SpringCloudConfig?
在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。

使用：
1、添加pom依赖
2、配置文件添加相关配置
3、启动类添加注解@EnableConfigServer

十八.Spring Cloud Gateway?
Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。

使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。

十九.架构?
在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统

在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理，配置服务的配置文件放在git仓库，方便开发人员随时改配置。

二十.什么是Hystrix?
防雪崩利器，具备服务降级，服务熔断，依赖隔离，监控（Hystrix Dashboard）
服务降级:
双十一 提示 哎哟喂，被挤爆了。 app秒杀 网络开小差了，请稍后再试。
优先核心服务，非核心服务不可用或弱可用。通过HystrixCommand注解指定。
fallbackMethod(回退函数)中具体实现降级逻辑。

springcloud面试题（二）

后面也已经整理了一版springcloud面试题(二) 地址如下:

https://blog.csdn.net/hjq_ku/article/details/104598487

有时候，垃圾只是放错位置的人才。------酷酷的韩~
一.为什么要使用微服务？
1.随着互联网的快速发展，各行各业都在用互联网。互联网已经离不开人们的形形色色。随着越来越多的用户，业务场景也愈来愈复杂。
2.传统的单体架构已经很难满足互联网技术发展的要求，代码可维护性扩展性和可读性降低，维护成本的提高都是驱动微服务的发展趋势。

二.作为服务注册中心，Eureka比Zookeeper好在哪里?

1.Eureka保证的是可用性和分区容错性，Zookeeper 保证的是一致性和分区容错性 。
2.Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障。而不会像zookeeper那样使整个注册服务瘫痪。

三.什么是 Ribbon负载均衡？

1.Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端 负载均衡的工具。
2. Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。

四.Ribbon负载均衡能干什么？

1.将用户的请求平摊的分配到多个服务上
2.集中式LB即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；
3.进程内LB将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。

注意： Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。

五.什么是 zuul路由网关

1.Zuul 包含了对请求的路由和过滤两个最主要的功能:其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础、
2.Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。
注意： Zuul服务最终还是会注册进Eureka 提供=代理+路由+过滤 三大功能。

六.分布式配置中心能干嘛？

1.集中管理配置文件不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release
2.运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息
3.当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置将配置信息以REST接口的形式暴露

七.微服务的优缺点分别是什么？说下你在项目开发中碰到的坑？

这个问题感觉比较容易问到~~~~

优点:
1.每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求
2.开发简单、开发效率提高，一个服务可能就是专一的只干一件事。
3.微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成。
4.微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。
5.微服务能使用不同的语言开发。
6.易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins, Hudson, bamboo 。
7.微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。
8.微服务允许你利用融合最新技术。
9.微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合。
10.每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。
缺点:
1.多服务运维难度，随着服务的增加，运维的压力也在增大
2.系统部署依赖
3.服务间通信成本
4.数据一致性
5.系统集成测试
6.性能监控
八.什么是微服务？
1.微服务是一种架构模式或是一种架构风格，它提倡的是将单一的应用程序划分成若干个小的服务，每个服务都有独立的进程，服务之间相互协调，相互配合，最终完成目的。
2.服务之间采用轻量级的通信机制，通常是基于HTTP的TESTful API。
3.每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等
4.应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储~
5.微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合,每一个微服务提供单个业务功能的服务，一个服务做一件事，从技术角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动或销毁，拥有自己独立的数据库。"> springcloud </div>
<div title="这篇主要分析leader的选择机制，zookeeper提供了三种方式：
● LeaderElection
● AuthFastLeaderElection
● FastLeaderElection （最新默认）
默认的算法是FastLeaderElection，所以这篇主要分析它的选举机制。
二、选举流程简述
目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：
● 服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking(选举状态)。
● 服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。
● 服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为领导者，服务器1,2成为小弟。
● 服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为小弟。
● 服务器5启动，后面的逻辑同服务器4成为小弟。
三、选择机制中的概念
1、Serverid：服务器ID
比如有三台服务器，编号分别是1,2,3。
编号越大在选择算法中的权重越大。
2、Zxid：数据ID
服务器中存放的最大数据ID.
值越大说明数据越新，在选举算法中数据越新权重越大。
3、Epoch：逻辑时钟
或者叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。
4、Server状态：选举状态
● LOOKING，竞选状态。
● FOLLOWING，随从状态，同步leader状态，参与投票。
● OBSERVING，观察状态,同步leader状态，不参与投票。
● LEADING，领导者状态。
四、选举消息内容
在投票完成后，需要将投票信息发送给集群中的所有服务器，它包含如下内容。
● 服务器ID
● 数据ID
● 逻辑时钟
● 选举状态
五、选举流程图
因为每个服务器都是独立的，在启动时均从初始状态开始参与选举，下面是简易流程图。">zookeeper 选举</div>
	<div title="Spring的事务传播性与隔离级别
tianzongnihao 2018-05-09 16:36:10  712  收藏 2
展开
Spring的事务传播性与隔离级别
一、事务的四个特性
l  原子性：一个事务中所有对数据库的操作是一个不可分割的操作序列，要么全做，要么全部做。
l  一致性：数据不会因为事务的执行而遭到破坏。
l  隔离性：一个事务的执行，不受其他事务（进程）的干扰。既并发执行的个事务之间互不干扰。
l  持久性：一个事务一旦提交，它对数据库的改变将是永久的。

二、事务的实现方式
      实现方式共有两种：编码方式；声明式事务管理方式。
      基于AOP技术实现的声明式事务管理，实质就是：在方法执行前后进行拦截，然后在目标方法开始之前创建并加入事务，执行完目标方法后根据执行情况提交或回滚事务。
      声明式事务管理又有两种方式：一种是基于XML配置文件的方式；另一种是在业务方法上添加@Transactional注解，将事务规则应用到业务逻辑中（一般定义在service层）。

三、创建事务的时机
      是否需要创建事务，是由事务传播行为控制的。读数据不需要或只为其指定只读事务，而数据的插入、修改、删除就需要进行事务管理了，这是由事务的隔离级别控制的。
      事务具有7个传播级别和4个隔离级别，传播级别定义的是事务创建的时机，隔离级别定义的是对并发事务数据读取的控制。
四、传播行为
事务的第一个方面是传播行为。传播行为定义关于客户端和被调用方法的事务边界。Spring定义了7中传播行为。
1)PROPAGATION_REQUIRED(propagation_required):支持当前事务，没有事务就新建一个。
2)PROPAGATION_SUPPORTS(supports):支持当前事务，如果没有事务，以非事务方式处理
3)PROPAGATION_MANDATORY(mandatory):支持当前事务，没有事务就抛异常
4)PROPAGATION_REQUIRES_NEW(requires_new):新建事务，如果当前存在事务，把当前事务挂起
5)PROPAGATION_NOT_SUPPORTED(not_supported):以非事务方式执行操作，有事务则挂起
6)PROPAGATION_NEVER(never):以非事务方式处理，有事务则挂起
7)PROPAGATTION_NESTED(nested)：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作

以下是事务的7种传播级别：[prɒpə'ɡeɪʃn]:传播
l  PROPAGATION_REQUIRED:propagation_required
默认的Spring事务传播级别，使用该级别的特点是：如果上下文中已经存在事务，那么就加入到事务中执行；如果当前上下文中不存在事务，则新建事务执行。所以这个级别通常能满足处理大多数的业务场景。
l  PROPAGATION_SUPPORTS：supoorts
从字面意思就知道，supports，支持，该传播级别的特点是：如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行。所以说，并非所有的包含在TransactionTemplate.execute方法中的代码都会有事务支持。这个通常是用来处理那些并非原子性的非核心业务逻辑操作。应用场景较少。
l  PROPAGATION_MANDATORY ：mandatory
该级别的事务要求上下文中必须要存在事务，否则就会抛出异常！配置该方式的传播级别是有效的控制上下文调用代码遗漏添加事务控制的保证手段。比如一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用这个传播级别。
l  PROPAGATION_REQUIRES_NEW :  requires_new
从字面即可知道，new，每次都要一个新事务，该传播级别的特点是：每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。
这是一个很有用的传播级别，举一个应用场景：现在有一个发送100个红包的操作，在发送之前，要做一些系统的初始化、验证、数据记录操作，然后发送100封红包，然后再记录发送日志，发送日志要求100%的准确，如果日志不准确，那么整个父事务逻辑需要回滚。
怎么处理整个业务需求呢？就是通过这个PROPAGATION_REQUIRES_NEW级别的事务传播控制就可以完成。发送红包的子事务不会直接影响到父事务的提交和回滚。
l  PROPAGATION_NOT_SUPPORTED
这个也可以从字面得知，not supported，不支持，当前级别的特点是：若上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务。
这个级别有什么好处？可以帮助你将事务尽可能的缩小。我们知道一个事务越大，它存在的风险也就越多。所以在处理事务的过程中，要保证尽可能的缩小范围。比如一段代码，是每次逻辑操作都必须调用的，比如循环1000次的某个非核心业务逻辑操作。这样的代码如果包在事务中，势必造成事务太大，导致出现一些难以考虑周全的异常情况，所以事务的这个传播级别就派上用场了。用当前级别的事务模板包含起来就可以了。
l  PROPAGATION_NEVER
该事务更严格，上面一个事务传播级别只是不支持而已，有事务就挂起，而PROPAGATION_NEVER传播级别要求上下文中不能存在事务，一旦有事务，就抛出runtime异常，强制停止执行！这个级别上辈子跟事务有仇。
l  PROPAGATION_NESTED
从字面也可知道，nested，嵌套级别事务。该传播级别的特征是：如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。
那么什么是嵌套事务呢？很多人都不理解，我看过一些博客，都是有些理解偏差。
嵌套是子事务嵌套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：
（1）   如果子事务回滚，会发生什么？
父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。
（2）   如果父事务回滚，会发生什么？
父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。
（3）   事务的提交，是什么情况？
是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。
现在你再体会一下这个”嵌套“，是不是有那么点意思了？
以上是事务的7个传播级别，在日常应用中，通常可以满足各种业务需求，但是除了传播级别，在读取数据库的过程中，如果两个事务并发执行，那么彼此之间的数据是如何影响的呢？这就需要了解一下事务的另一个特性：数据隔离级别。

五、事务的隔离级别
数据4种隔离级别：
Read uncommitted(未授权读取、读未提交)：
如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。
避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。
Read committed（授权读取、读提交）：
读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。
该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。
Repeatable read（可重复读取）：
读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。
避免了不可重复读取和脏读，但是有时可能出现幻读。这可以通过“共享读锁”和“排他写锁”实现。

Serializable（序列化）：
提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。
序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。

隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。

MYSQL: 默认为REPEATABLE_READ级别
SQLSERVER: 默认为READ_COMMITTED
详细介绍：
l  SERIALIZABLE
最严格的级别，事务串行执行，资源消耗最大。
l  REPEATABLE_READ  类似于读写事务互斥
保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失。
l  READ_COMMITTED  读写没有互斥
大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”。该级别适用于大多数系统。
l  READ_UNCOMMITTED
保证了读取过程中不会读取到非法数据。

上面的解释其实每个定义都有一些拗口，其中涉及到几个术语：脏读、不可重复读、幻读。这里解释一下：
l  脏读（Dirty Reads）
所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
l  不可重复读（Non-RepeatableReads）
不可重复读字面含义已经很明了了，比如事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。
l  幻读
小的时候数手指，第一次数十10个，第二次数是11个，怎么回事？产生幻觉了？
幻读也是这样子，事务A首先根据条件索引得到10条数据，然后事务B改变了数据库一条数据，导致也符合事务A当时的搜索条件，这样事务A再次搜索发现有11条数据了，就产生了幻读。

事务隔离级别对照关系表：

脏读
不可重复读
幻读
SERIALIZABLE
不会
不会
不会
REPEATABLE_READ
不会
不会
会
READ_COMMITTED
不会
会
会
READ_UNCOMMITTED
会
会
会
      所以最安全的，是Serializable，但是伴随而来也是高昂的性能开销。
      另外，事务常用的两个属性：① readonly，设置事务为只读以提升性能；② timeout，设置事务的超时时间，一般用于防止大事务的发生。

六、Spring管理声明式事务的配置
1. 基于XML配置文件的AOP和TX配置方式">spring事务传播与隔离级别</div>
	<div title="redis相关原理及面试官由浅到深必问的15大问题（高级）

师长学不动了 2018-06-19 10:28:00  34992  收藏 137
展开
0.redis是什么？
redis是nosql(也是个巨大的map) 单线程，但是可处理1秒10w的并发（数据都在内存中）

使用java对redis进行操作类似jdbc接口标准对mysql，有各类实现他的实现类，我们常用的是druid

其中对redis，我们通常用Jedis(也为我们提供了连接池JedisPool)

在redis中,key就是byte[](string)

redis的数据结构(value):

String,list,set,orderset,hash

每种数据结构对应不同的命令语句~

1.redis怎么使用？
先安装好redis，然后运行，在pom文件中引入依赖，在要使用redis缓存的类的mapper.xml文件配置redis的全限定名。引入redis的redis.properties文件（如果要更改配置就可以使用）

2.应用场景:

String :

1存储json类型对象,2计数器,3优酷视频点赞等

list(双向链表)

1可以使用redis的list模拟队列,堆,栈

2朋友圈点赞(一条朋友圈内容语句,若干点赞语句)

规定:朋友圈内容的格式:

1,内容: user:x:post:x content来存储;

2,点赞: post:x:good list来存储;(把相应头像取出来显示)

hash(hashmap)

1保存对象

2分组

3.为什么redis是单线程的都那么快？
1.数据存于内存

2.用了多路复用I/O

3.单线程

5.redis也可以进行发布订阅消息吗？
可以，（然后可以引出哨兵模式（后面会讲）怎么互相监督的，就是因为每隔2秒哨兵节点会发布对某节点的判断和自身的信息到某频道，每个哨兵订阅该频道获取其他哨兵节点和主从节点的信息，以达到哨兵间互相监控和对主从节点的监控）和很多专业的消息队列系统（例如Kafka、RocketMQ）相比，Redis的发布订阅略显粗糙，例如无法实现消息堆积和回溯。但胜在足够简单。


6.redis能否将数据持久化，如何实现？
能，将内存中的数据异步写入硬盘中，两种方式：RDB（默认）和AOF

RDB持久化原理：通过bgsave命令触发，然后父进程执行fork操作创建子进程，子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换（定时一次性将所有数据进行快照生成一份副本存储在硬盘中）

优点：是一个紧凑压缩的二进制文件，Redis加载RDB恢复数据远远快于AOF的方式。

缺点：由于每次生成RDB开销较大，非实时持久化，

AOF持久化原理：开启后，Redis每执行一个修改数据的命令，都会把这个命令添加到AOF文件中。

优点：实时持久化。

缺点：所以AOF文件体积逐渐变大，需要定期执行重写操作来降低文件体积，加载慢

7.主从复制模式下，主挂了怎么办？redis提供了哨兵模式（高可用）
何谓哨兵模式？就是通过哨兵节点进行自主监控主从节点以及其他哨兵节点，发现主节点故障时自主进行故障转移。


8.哨兵模式实现原理？（2.8版本或更高才有）
1.三个定时监控任务：

1.1 每隔10s，每个S节点（哨兵节点）会向主节点和从节点发送info命令获取最新的拓扑结构

1.2 每隔2s，每个S节点会向某频道上发送该S节点对于主节点的判断以及当前Sl节点的信息，

同时每个Sentinel节点也会订阅该频道，来了解其他S节点以及它们对主节点的判断（做客观下线依据）

1.3 每隔1s，每个S节点会向主节点、从节点、其余S节点发送一条ping命令做一次心跳检测(心跳检测机制)，来确认这些节点当前是否可达

2.主客观下线：

2.1主观下线：根据第三个定时任务对没有有效回复的节点做主观下线处理

2.2客观下线：若主观下线的是主节点，会咨询其他S节点对该主节点的判断，超过半数，对该主节点做客观下线

3.选举出某一哨兵节点作为领导者，来进行故障转移。选举方式：raft算法。每个S节点有一票同意权，哪个S节点做出主观下线的时候，就会询问其他S节点是否同意其为领导者。获得半数选票的则成为领导者。基本谁先做出客观下线，谁成为领导者。

4.故障转移（选举新主节点流程）：

.


9.redis集群（采用虚拟槽方式，高可用）原理（和哨兵模式原理类似，3.0版本或以上才有）？
1.Redis集群内节点通过ping/pong消息实现节点通信，消息不但可以传播节点槽信息，还可以传播其他状态如：主从状态、节点故障等。因此故障发现也是通过消息传播机制实现的，主要环节包括：主观下线（pfail）和客观下线（fail）

2.主客观下线：

2.1主观下线：集群中每个节点都会定期向其他节点发送ping消息，接收节点回复pong消息作为响应。如果通信一直失败，则发送节点会把接收节点标记为主观下线（pfail）状态。

2.2客观下线：超过半数，对该主节点做客观下线

3.主节点选举出某一主节点作为领导者，来进行故障转移。

4.故障转移（选举从节点作为新主节点）

10.缓存更新策略（即如何让缓存和mysql保持一致性）？

10.1 key过期清除（超时剔除）策略

惰性过期（类比懒加载，这是懒过期）：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。

定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)

问：比如这么个场景，我设计了很多key，过期时间是5分钟，当前内存占用率是50%。但是5分钟到了，内存占用率还是很高，请问为什么？

Redis中同时使用了惰性过期和定期过期两种过期策略，即使过期时间到了，但是有部分并没有真正删除，等待惰性删除。

为什么有定期还要有惰性呢？其实很简单，比如10万个key就要过期了，Redis默认是100ms检查一波。如果他检查出10万个即将要清除，那他接下来的时间基本都是在干这些清空内存的事了，那肯定影响性能，所以他只会部分删除，剩下的等惰性

10.2 Redis的内存淘汰策略

Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。

noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。

allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。

allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。

volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。

volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。

volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

11.缓存粒度控制？

12.如何防止缓存穿透？
（缓存穿透指的是查询一个根本不存在的数据，缓存层不命中，又去查存储层，又不命中。但如果有大量这种查询不存在的数据的请求过来，会对存储层有较大压力，若是恶意攻击，后果就）


12.1：缓存空值存在的问题：


12.2：布隆过滤器：


布隆过滤器存在的问题：相对来说布隆过滤器搞起来代码还是比较复杂的，现阶段我们暂时还不需要，后面实在需要再考虑去做，什么阶段做什么样的事情，不是说这个系统一下子就能做的各种完美。

13.无底洞优化？
造成原因：redis分布式越来越多，导致性能反而下降，因为键值分布到更多的 节点上，所以无论是Memcache还是Redis的分布式，批量操作通常需要从不 同节点上获取，相比于单机批量操作只涉及一次网络操作，分布式批量操作 会涉及多次网络时间。 即分布式过犹不及。


14.雪崩优化
如果缓存层由于某些原因不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。


15.热点key优化
当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。">redis原理</div>
<div title="常用MQ及其原理
深山猿 2018-07-20 17:56:42  10873  收藏 15
展开
mq为了解决什么问题？
1、异步通信
   有些业务不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。
2、解耦
   降低工程间的强依赖程度，针对异构系统进行适配。在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束
3、冗余
   有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的 插入-获取-删除 范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。
	4、扩展性
	因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。便于分布式扩容
	5、过载保护
	在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃
	6、可恢复性
	系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。
	7、顺序保证
	在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。
	8、缓冲
	在任何重要的系统中，都会有需要不同的处理时间的元素。消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度。以调节系统响应时间。
	9、数据流处理
	分布式系统产生的海量数据流，如：业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择
	Mq原理
	1)MQ原型-Pub/Sub发布订阅
	（广播：生产者-消费之1对多）：使用topic作为通信载体
	希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型
	2) MQ原型-PTP点对点
	:使用queue作为通信载体
	如果希望发送的每个消息都会被成功处理的话，那么需要P2P模式。
	3 MQ原型-多点广播：
	MQ适用于不同类型的应用。其中重要的，也是正在发展中的是"多点广播"应用，即能够将消息发送到多个目标站点(Destination List)。可以使用一条MQ指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。MQ不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，MQ将消息的一个复制版本和该系统上接收者的名单发送到目标MQ系统。目标MQ系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。
	4 MQ原型-群集(Cluster)：
	为了简化点对点通讯模式中的系统配置，MQ提供Cluster(群集)的解决方案。群集类似于一个域(Domain)，群集内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用群集(Cluster)通道与其它成员通讯，从而大大简化了系统配置。此外，群集中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性
	2、MQ组成结构
	Broker：消息服务器，作为server提供消息核心服务
	Producer:消息生产者，业务的发起方，负责生产消息传输给broker，
	Consumer：消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理
	Topic:主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅 者，实现消息的广播
	Queue：队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收
	Message：消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输
	RabbitMq与kafaka选型比较
	https://blog.csdn.net/yifansj/article/details/79248586
	架构方面：
	Kafaka是正常的mq架构，包括provider broker consumer。，kafaka没有消息确认机制
	rabbitMq 中的broker由exchange、binder queue三部分组成，其中exchange和binding组成了消息的路由键；客户端Producer通过连接channel和server进行通信，Consumer从queue获取消息进行消费，rabbit有消息确认机制
	吞吐量方面：
	Kafaka采用zero-copy方式，即数据存储和获取是本地磁盘顺序批量操作，具有O（1）复杂度，数据处理效率很高
	RabbitMq在吞吐量方面不如kafaka，RabbitMq支持对消息可靠的传递，支持事务，不支持批量的操作。
	可用性方面
	Kafaka的broker采用主备模式，所以可用性很高
	RabbitMq支持miror queue，主queue失效，minor queue生效
	集群负载方面
	Kafaka使用zookeeper实现负载均衡，zookeeper管理集群中的broker sonsumer，通过zookeeper的协调机制，producer会记录topic对应的broker，对broker进行轮询或者随机访问broker，实现负载均衡
	RabbitMq需要单独自定义负载均衡
	一般推荐使用mq，例如RabbitMq，activeMq等，已经比较成熟和稳定了，性能也一般，一般推荐使用这些。Redies适用于在内存中存储数据库，作为消息队列可靠性较差，而且依赖于网络IO;kafaka设计的初衷是日志统计分析，现在也可以配合zookeeper用于消息">MQ常见面试会提的问题</div>
<div title=""></div>
	<div title="分布式事务的四种解决方案简述分布式事务指事务的操作位于不同的节点上，需要保证事务的 AICD 特性。
例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。
解决方案
在分布式系统中，要实现分布式事务，无外乎那几种解决方案。
一、两阶段提交（2PC）
两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。
1. 运行过程
1.1 准备阶段
协调者询问参与者事务是否执行成功，参与者发回事务执行结果。
1.2 提交阶段
如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。
需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。
2. 存在的问题
2.1 同步阻塞 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。
2.2 单点问题 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。
2.3 数据不一致 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。
2.4 太过保守 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。
二、补偿事务（TCC）
TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：
● Try 阶段主要是对业务系统做检测及资源预留
● Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
● Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。
举个例子，假入 Bob 要向 Smith 转账，思路大概是： 我们有一个本地方法，里面依次调用
1. 首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。
2. 在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。
3. 如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。
优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些
缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。
三、本地消息表（异步确保）
本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。
1. 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
2. 之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。
3. 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。
优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。
缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。
四、MQ 事务消息
有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。
以阿里的 RocketMQ 中间件为例，其思路大致为：
第一阶段Prepared消息，会拿到消息的地址。 第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。
也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。
优点： 实现了最终一致性，不需要依赖本地数据库事务。
缺点： 实现难度大，主流MQ不支持，RocketMQ事务消息部分代码也未开源。
总结
通过本文我们总结并对比了几种分布式分解方案的优缺点，分布式事务本身是一个技术难题，是没有一种完美的方案应对所有场景的，具体还是要根据业务场景去抉择吧。阿里RocketMQ去实现的分布式事务，现在也有除了很多分布式事务的协调器，比如LCN等，大家可以多去尝试。">分布式事务</div>
<div title="mybatis中#{}和${}符号的区别

最胖的胖胖虎 2019-01-17 13:44:20  2128  收藏 3
展开
#{}  使用#{}意味着使用的预编译的语句，即在使用jdbc时的preparedStatement，sql语句中如果存在参数则会使用?作占位符，我们知道这种方式可以防止sql注入，并且在使用#{}时形成的sql语句，已经带有引号，例，select  * from table where id=#{id} 在调用这个sql时我们可以通过后台看到打印出的sql为：select * from table where id='2' 假如传的id值为2.也就是说在组成sql语句的时候把参数默认为字符串。

${} 使用${}时的sql不会当做字符串处理，如上边的语句：select * from table where id=${id} 在调用这个语句时控制台打印的为：select * from table where id=2 and name=3 ，假设传的参数id值为（2 and name=3），这样就会带来sql注入。

这里也不是说${}一无是处，比如在MyBatis动态排序时使用order by +${动态参数}，使用${}而不是#{}。">mybatis</div>
<div title="根据业务规划以及域的划分来拆分微服务，域的划分其实是基于PO的分类划分，一般来讲一个po的读写只能划分在一个域里面
一般讲到如何划分域，我交流过的绝大多数同学从大的道理上还是能说得七七八八。比如按职责划分、职责要清晰、边界要清晰、要高内聚松耦合等等。这些说得都没错，不过呢还都停留在表层，还需要能进一步打开，要能再进一步说明：
● 究竟用什么衡量标准来判定“职责是否清晰”？
● 我们所说的域的“职责”，这个“职责”指的是什么东西的职责？
● 边界是什么？特别是什么是域的边界，什么是系统的边界？ 域的边界是否等同于系统边界？
● 高内聚、松耦合如何衡量？如果有个打分的标准，耦合度得分是60分，不是61分，差的这一分是怎么打出来的？
如果能够把这几个问题都能回答上来，那么关于一个域是如何划分就很容易了。关于这几个问题，我觉得最最关键的问题是回答清楚一个“域”的“职责”，这个“职责”究竟指的是啥。
关于这个问题，我也业界多位大牛，在经过多次讨论。我们认为，这个所谓域的“职责”最终就体现为对具体能被持久化对象的管理职责。
域的划分明确之后，其实纵向的界限的清晰了，横向的话   微服务划分的姿势
加瓦一美 2019-08-22 09:53:20  95  收藏
展开
我们知道微服务是一种理念，没有确切的定义和边界，好比设计原则，是属于抽象的概念。在定义不明确的情况下谈划分也是一种各说各话，具体问题需要具体分析，所以这篇文章谈到的划分也不是绝对标准，仅供参考。
　　有人说微幅不难，难的是服务的划分，虽然我持保留意见。但是从侧面也反应了划分具有一定的困难。这里的矛盾在于粒度。如果粒度太大了，分和不分似乎都差不多；如果粒度太小了，聚合、发布、调用链、调试等都是坑。
　　以下谈到的拆分是前人经验的总结，我罗列了三种行家的拆分姿势，每个的的经验和视野不同，各有偏颇，我在这里更多的是谈共鸣和感受，希望对你有所启发。
一、拆分姿势
1.姿势一：
　　新浪微博微服务专家胡忠想从纵横两个维度来划分，简单粗暴：
1.1 纵向拆分
　　从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。
1.2 横向拆分
　　从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。
　　纵向以业务为基准，关系铁的在一起；横向功能独立的在一起。我想如果拆分这么简单，你有底气拆，敢拆吗？所以我们又继续比对一下其他专家的言论。

2.姿势二：
　　阿里的小伙伴从综合的维度来看，部分维度和上面会有重合。
2.1 服务拆分要迎合业务的需要
　　充分考虑业务独立性和专业性，避免以团队来定义服务边界，从而出现“土匪”抢地盘，影响团队信任。
　　这个维度和上面的类似，但是强调的是业务和团队成员的各自独立性，对上面是一种很好的补充。
2.2 拆分后的维护成本要低于拆分前
　　这里的维护成本包括：人力、物力、时间。
　　这里的成本对大部分中小团队来说都是必须要考虑的重要环节，如果投入和收益不能成正比，或者超出领导的预算或者市场窗口，那么先进的技术就是绊脚石，千万不要迷恋技术，所谓工程师思维千万要不得。
2.3 拆分不仅仅是架构的调整，组织结构上也要做响应的适应性优化
　　确保拆分后的服务由相对独立的团队负责维护。
　　这句话怎么理解呢？传统的团队划分是按照产品部、前端、后端横向划分，微服务化以后的团队可能就会是吃一张披萨饼的人数，产品、前端、后端被归类到服务里面，以服务为中心来分配人数。
2.4 拆分最有价值的结果是提高了系统的可扩展性
　　把具有不同扩展性要求的服务拆分出来，分别进行部署，降低成本，提高效率。比如全文搜索服务。
　　这点和上面的按功能独立性来拆分有点类似，功能独立其实就是面向可扩展性。
2.5 考虑软件发布频率
　　比如把20%经常变动的部分进行抽离，80%不经常变动的单独部署和管理。说白了就是按照8/2原则进行拆分。这个拆分的好处很明显，可以尽可能的减少发布产生的后遗症，比如用户体验、服务相互干扰等。
　　但是这里有一个问题，假如20%的服务分属于不同的业务层面，那该怎么办？所以这里的拆分应该有个优先级，在拆分相互冲突的时候应该要优先考虑权重比较高的那个。

3.姿势三：
　　资深技术专家李运华在他的架构书中给出的拆分：
3.1 基于业务逻辑
　　将系统中的业务按照职责范围进行识别，职责相同的划分为一个单独的服务。这种业务优先的方式在前面两种姿势当中都出现过，可见是最基本，最重要的划分方式（没有之一）。
3.2 基于稳定性
　　将系统中的业务模块按照稳定性进行排序。稳定的、不经常修改的划分一块；将不稳定的，经常修改的划分为一个独立服务。比如日志服务、监控服务都是相对稳定的服务，可以归到一起。这个很类似上面提到的2/8原则，80%的业务是稳定的。
　　至此你会发现服务的拆分真的没有绝对的标准，只有合理才是标准。
3.3 基于可靠性
　　同样，将系统中的业务模块按照可靠性进行排序。对可靠性要求比较高的核心模块归在一起，对可靠性要求不高的非核心模块归在一块。
　　这种拆分的高明可以很好的规避因为一颗老鼠屎坏了一锅粥的单体弊端，同时将来要做高可用方案也能很好的节省机器或带宽的成本。
3.4 基于高性能
　　同上，将系统中的业务模块按照对性能的要求进行优先级排序。把对性能要求较高的模块独立成一个服务，对性能要求不高的放在一起。比如全文搜索，商品查询和分类，秒杀就属于高性能的核心模块。">微服务拆分</div>

<div title="分布式事务的四种解决方案
简述
分布式事务指事务的操作位于不同的节点上，需要保证事务的 AICD 特性。
例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。
解决方案
在分布式系统中，要实现分布式事务，无外乎那几种解决方案。
一、两阶段提交（2PC）
两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。
1. 运行过程
1.1 准备阶段
协调者询问参与者事务是否执行成功，参与者发回事务执行结果。
1.2 提交阶段
如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。
需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。
2. 存在的问题
2.1 同步阻塞 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。
2.2 单点问题 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。
2.3 数据不一致 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。
2.4 太过保守 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。
二、补偿事务（TCC）
TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：
● Try 阶段主要是对业务系统做检测及资源预留
● Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
● Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。
举个例子，假入 Bob 要向 Smith 转账，思路大概是： 我们有一个本地方法，里面依次调用
1. 首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。
2. 在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。
3. 如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。
优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些
缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。
三、本地消息表（异步确保）
本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。
1. 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
2. 之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。
3. 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。
优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。
缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。
四、MQ 事务消息
有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。
以阿里的 RocketMQ 中间件为例，其思路大致为：
第一阶段Prepared消息，会拿到消息的地址。 第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。
也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。
优点： 实现了最终一致性，不需要依赖本地数据库事务。
缺点： 实现难度大，主流MQ不支持，RocketMQ事务消息部分代码也未开源。
总结
通过本文我们总结并对比了几种分布式分解方案的优缺点，分布式事务本身是一个技术难题，是没有一种完美的方案应对所有场景的，具体还是要根据业务场景去抉择吧。阿里RocketMQ去实现的分布式事务，现在也有除了很多分布式事务的协调器，比如LCN等，大家可以多去尝试。">分布式事务</div>
<div title="缓存穿透、缓存击穿、缓存雪崩区别和解决方案
展开 一、缓存处理流程
      前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。
二、缓存穿透
       描述：
       缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。
      解决方案：
接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
三、缓存击穿
      描述：
      缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力
      解决方案：
设置热点数据永远不过期。
加互斥锁，互斥锁参考代码如下：   说明：
          1）缓存中有数据，直接走上述代码13行后就返回结果了

         2）缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。
          3）当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。
四、缓存雪崩
      描述：    缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，        缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
     解决方案：缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
设置热点数据永远不过期。
">缓存穿透 缓存血崩</div>
	<div title="注：Spring Boot Bean的生命周期，什么是Bean的生命周期，就是Bean从创建到销毁的过程。
Bean的生命周期过程描述
我们先看一下Bean的生命周期过程中都会经历些什么，我先简单解释一下，后面我们通过源码进行详细解释。首先Spring在实例化Bean的时候，会先调用它的构造函数，进行Bean的实例化，然后进行Bean的初始化，Bean的初始化经过三个阶段初始化之前（applyBeanPostProcessorsBeforeInitialization），其次是进行初始化（invokeInitMethods），最后是初始化之后（postProcessAfterInitialization），这就是Bean的初始化过程；然后就开始利用Bean进行业务逻辑处理，最后容器正常关闭，Spring开始销毁Bean，Bean的销毁过程相对比较简单，调用DisposableBeanAdapter.destroy()方法，该方法中有三个地方比较重要，分别触发Bean的生命周期方法，它们是：processor.postProcessBeforeDestruction(this.bean, this.beanName);
((DisposableBean) bean).destroy();
invokeCustomDestroyMethod(this.destroyMethod);
下面我把用图片来进行直观展示：
Bean的生命周期.png
实例运行
User类，这里就是普通的一个Bean,用来添加到容器中，观察其生命周期
	运行结果查看
	运行结果.png
	源码解析
	初始化过程
	首先我们将断点打到CustomBeanPostProcessor.postProcessBeforeInitialization的第一行代码，然后我看一下其方法调用栈：


	方法调用栈.png

	主要包括两个地方，一个是容器刷新，第二个是初始化Bean，我们先对这容器刷新的源码进行简单查看
				结束语
				至此，我们Bean的生命周期探索初步结束，后面再做进一步深入学习，在学习本节课时要多进行调试，断点跟踪，会更加有效果。另外无论是在初始化还是在结束时都是处理的单例的Bean,而且在初始化时，处理的Bean还是非懒加载的，所以需要特殊说明：非懒加载的单实例Bean的生命周期如上;懒加载的单实例Bean是在第一次获取进行初始化过程;原型Bean是在每次获取时都进行初始化，而且Spring容器不会管理器销毁。
				最近在网上看到了一篇文章，很不错，详细的介绍了Spring IOC的原理，如果大家想详细了解Spring的IOC可以看一下：https://www.cnblogs.com/ITtangtang/p/3978349.html，好东西大家一起分享，🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔫🏀⚽⚡👄🔥"></div>
<hr />
<div title="自旋锁以及Java中的自旋锁的实现
置顶 csucoderlee 2018-08-07 00:45:18  11051  收藏 16
什么是自旋锁
多线程中，对共享资源进行访问，为了防止并发引起的相关问题，通常都是引入锁的机制来处理并发问题。
获取到资源的线程A对这个资源加锁，其他线程比如B要访问这个资源首先要获得锁，而此时A持有这个资源的锁，只有等待线程A逻辑执行完，释放锁，这个时候B才能获取到资源的锁进而获取到该资源。
这个过程中，A一直持有着资源的锁，那么没有获取到锁的其他线程比如B怎么办？通常就会有两种方式：
1. 一种是没有获得锁的进程就直接进入阻塞（BLOCKING），这种就是互斥锁
2. 另外一种就是没有获得锁的进程，不进入阻塞，而是一直循环着，看是否能够等到A释放了资源的锁。
上述的两种方式，学术上，就有几种不同的定义方式，大学的时候 学习的是C++， 《C++ 11》中就有这样的描述：
自旋锁（spin lock）是一种非阻塞锁，也就是说，如果某线程需要获取锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取锁。
互斥量（mutex）是阻塞锁，当某线程无法获取锁时，该线程会被直接挂起，该线程不再消耗CPU时间，当其他线程释放锁后，操作系统会激活那个被挂起的线程，让其投入运行。
而《linux内核设计与实现》经常提到两种态，一种是内核态，一种是用户态，对于自旋锁来说，自旋锁使线程处于用户态，而互斥锁需要重新分配，进入到内核态。这里大家对内核态和用户态有个初步的认知就行了，用户态比较轻，内核态比较重。用户态和内核态这个也是linux中必备的知识基础，借鉴这个，可以进行很多程序设计语言API上的优化，就比如说javaio的部分，操作io的时候，先是要从用户态，进入内核态，再用内核态去操作输入输出设备的抽象，这里减少用户态到内核态的转换就是新io的一部分优化，后面再聊。
wiki中的定义如下：
自旋锁是计算机科学用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。
自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。因此操作系统的实现在很多地方往往用自旋锁。Windows操作系统提供的轻型读写锁（SRW Lock）内部就用了自旋锁。显然，单核CPU不适于使用自旋锁，这里的单核CPU指的是单核单线程的CPU，因为，在同一时间只有一个线程是处在运行状态，假设运行线程A发现无法获取锁，只能等待解锁，但因为A自身不挂起，所以那个持有锁的线程B没有办法进入运行状态，只能等到操作系统分给A的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。（红字部分是我给wiki编辑的词条，单核CPU不适合自旋锁，这个也只是针对单核单线程的情况，现在的技术基本单核都是支持多线程的）
为什么要使用自旋锁
互斥锁有一个缺点，他的执行流程是这样的 托管代码  - 用户态代码 - 内核态代码、上下文切换开销与损耗，假如获取到资源锁的线程A立马处理完逻辑释放掉资源锁，如果是采取互斥的方式，那么线程B从没有获取锁到获取锁这个过程中，就要用户态和内核态调度、上下文切换的开销和损耗。所以就有了自旋锁的模式，让线程B就在用户态循环等着，减少消耗。
自旋锁比较适用于锁使用者保持锁时间比较短的情况，这种情况下自旋锁的效率要远高于互斥锁。
自旋锁可能潜在的问题
过多占用CPU的资源，如果锁持有者线程A一直长时间的持有锁处理自己的逻辑，那么这个线程B就会一直循环等待过度占用cpu资源
递归使用可能会造成死锁，不过这种场景一般写不出来
CAS
就不写术语定义了，简单的理解就是这个CAS是由操作系统定义的，由若干指令组成的，这个操作具有原子性，这些指令如果执行，就会全部执行完，不会被中断。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
CAS的问题
经典的CAS的ABA问题，上面提到了CAS操作的时候，要检测值有没有变化，如果一个值原来是A，后来变成了B， 后来又变成了A，CAS会认为没有发生变化。
       解决方案：
       1. 加版本号   1A - 2B -  3A
       2. 对java而言，jdk1.5提供了AtomicStampedReference来解决这个问题
只能保证一个共享变量的原子操作 
        CAS通常是对一个变量来进行原子操作的，所以如果对多个变量进行原子操作就会有问题了。
        解决方案     1. 简单粗暴，加锁，反而加入了复杂性，最low的方式
        2. 跟上面的加版本号的道理一样，就是将多个变量拼成一个变量（可以拼成一个字符串）
        3. 对java而言，jdk1.5 提供了AtomicStampedReference，这个reference 就是个对象引用，把多个变量放在这个对象里即可
JAVA CAS封装
 sun.misc.Unsafe是JDK里面的一个内部类，这个类当中有三个CAS的操作
JAVA自旋锁应用
Jdk1.5以后，提供了java.util.concurrent.atomic包，这个包里面提供了一组原子类。基本上就是当前获取锁的线程，执行更新的方法，其他线程自旋等待，比如atomicInteger类中的getAndAdd方法内部实际上使用的就是Unsafe的方法。
    /**
     * Atomically adds the given value to the current value.
     *
     * @param delta the value to add
     * @return the previous value
     */
    public final int getAndAdd(int delta) {
        return unsafe.getAndAddInt(this, valueOffset, delta);
    }
当然java中的synchronized关键字，在1.5中有了很大的优化，加入了偏隙锁也有人叫偏向锁，主要的实现方式就是在对象头markword中打上线程的信息，这样资源上的锁的获取就偏向了这个线程，后面，会涉及一系列的锁升级的问题，间隙锁 - 轻量锁 - 重量级锁 ，锁升级后面单独抽出来写一篇，这个轻量锁实际上就是使用的也是自旋锁的实现方式。">计算机领域的自旋锁及java中的具体实现</div>
</body>
</html>